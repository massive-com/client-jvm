/**
 *
 * Please note:
 * This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * Do not edit this file manually.
 *
 */

@file:Suppress(
    "ArrayInDataClass",
    "EnumEntryName",
    "RemoveRedundantQualifierName",
    "UnusedImport"
)

package org.openapitools.client.apis

import java.io.IOException
import okhttp3.Call
import okhttp3.HttpUrl

import org.openapitools.client.models.ContractDetails200Response
import org.openapitools.client.models.DailySchedules200Response
import org.openapitools.client.models.DeprecatedGetCryptoSnapshotTickerBook200Response
import org.openapitools.client.models.DeprecatedGetHistoricCryptoTrades200Response
import org.openapitools.client.models.DeprecatedGetHistoricForexQuotes200Response
import org.openapitools.client.models.DeprecatedGetHistoricStocksQuotes200Response
import org.openapitools.client.models.DeprecatedGetHistoricStocksTrades200Response
import org.openapitools.client.models.GetBenzingaV1AnalystInsights200Response
import org.openapitools.client.models.GetBenzingaV1AnalystInsights400Response
import org.openapitools.client.models.GetBenzingaV1Analysts200Response
import org.openapitools.client.models.GetBenzingaV1ConsensusRatings200Response
import org.openapitools.client.models.GetBenzingaV1Earnings200Response
import org.openapitools.client.models.GetBenzingaV1Firms200Response
import org.openapitools.client.models.GetBenzingaV1Guidance200Response
import org.openapitools.client.models.GetBenzingaV1Ratings200Response
import org.openapitools.client.models.GetBenzingaV2News200Response
import org.openapitools.client.models.GetCryptoAggregates200Response
import org.openapitools.client.models.GetCryptoOpenClose200Response
import org.openapitools.client.models.GetCryptoSnapshotDirection200Response
import org.openapitools.client.models.GetCryptoSnapshotTicker200Response
import org.openapitools.client.models.GetCryptoSnapshotTickers200Response
import org.openapitools.client.models.GetCryptoV1Exchanges200Response
import org.openapitools.client.models.GetCurrencyConversion200Response
import org.openapitools.client.models.GetEtfGlobalV1Analytics200Response
import org.openapitools.client.models.GetEtfGlobalV1Constituents200Response
import org.openapitools.client.models.GetEtfGlobalV1FundFlows200Response
import org.openapitools.client.models.GetEtfGlobalV1Profiles200Response
import org.openapitools.client.models.GetEtfGlobalV1Taxonomies200Response
import org.openapitools.client.models.GetEvents200Response
import org.openapitools.client.models.GetFedV1Inflation200Response
import org.openapitools.client.models.GetFedV1InflationExpectations200Response
import org.openapitools.client.models.GetFedV1TreasuryYields200Response
import org.openapitools.client.models.GetForexSnapshotTicker200Response
import org.openapitools.client.models.GetForexSnapshotTickers200Response
import org.openapitools.client.models.GetForexV1Exchanges200Response
import org.openapitools.client.models.GetFuturesAggregates200Response
import org.openapitools.client.models.GetFuturesQuotes200Response
import org.openapitools.client.models.GetFuturesTrades200Response
import org.openapitools.client.models.GetFuturesVXContractsNew200Response
import org.openapitools.client.models.GetFuturesVXExchanges200Response
import org.openapitools.client.models.GetFuturesVXProductsNew200Response
import org.openapitools.client.models.GetFuturesVXSnapshot200Response
import org.openapitools.client.models.GetGroupedCryptoAggregates200Response
import org.openapitools.client.models.GetGroupedStocksAggregates200Response
import org.openapitools.client.models.GetIndicesOpenClose200Response
import org.openapitools.client.models.GetIndicesSnapshot200Response
import org.openapitools.client.models.GetLastCryptoTrade200Response
import org.openapitools.client.models.GetLastCurrencyQuote200Response
import org.openapitools.client.models.GetLastStocksQuote200Response
import org.openapitools.client.models.GetLastStocksTrade200Response
import org.openapitools.client.models.GetMarketHolidays200ResponseInner
import org.openapitools.client.models.GetMarketStatus200Response
import org.openapitools.client.models.GetOptionContract200Response
import org.openapitools.client.models.GetOptionsChain200Response
import org.openapitools.client.models.GetOptionsContract200Response
import org.openapitools.client.models.GetOptionsOpenClose200Response
import org.openapitools.client.models.GetOptionsV1Exchanges200Response
import org.openapitools.client.models.GetPreviousCryptoAggregates200Response
import org.openapitools.client.models.GetPreviousForexAggregates200Response
import org.openapitools.client.models.GetPreviousIndicesAggregates200Response
import org.openapitools.client.models.GetRelatedCompanies200Response
import org.openapitools.client.models.GetSnapshotSummary200Response
import org.openapitools.client.models.GetSnapshots200Response
import org.openapitools.client.models.GetStocksAggregates200Response
import org.openapitools.client.models.GetStocksEMA200Response
import org.openapitools.client.models.GetStocksFilingsVXRiskFactors200Response
import org.openapitools.client.models.GetStocksFilingsVXText200Response
import org.openapitools.client.models.GetStocksFinancialsV1BalanceSheets200Response
import org.openapitools.client.models.GetStocksFinancialsV1CashFlowStatements200Response
import org.openapitools.client.models.GetStocksFinancialsV1IncomeStatements200Response
import org.openapitools.client.models.GetStocksFinancialsV1Ratios200Response
import org.openapitools.client.models.GetStocksMACD200Response
import org.openapitools.client.models.GetStocksQuotes200Response
import org.openapitools.client.models.GetStocksRSI200Response
import org.openapitools.client.models.GetStocksSMA200Response
import org.openapitools.client.models.GetStocksSnapshotDirection200Response
import org.openapitools.client.models.GetStocksSnapshotTicker200Response
import org.openapitools.client.models.GetStocksSnapshotTickers200Response
import org.openapitools.client.models.GetStocksTaxonomiesVXRiskFactors200Response
import org.openapitools.client.models.GetStocksTrades200Response
import org.openapitools.client.models.GetStocksV1Dividends200Response
import org.openapitools.client.models.GetStocksV1Exchanges200Response
import org.openapitools.client.models.GetStocksV1ShortInterest200Response
import org.openapitools.client.models.GetStocksV1ShortVolume200Response
import org.openapitools.client.models.GetStocksV1Splits200Response
import org.openapitools.client.models.GetTicker200Response
import org.openapitools.client.models.GetTmxV1CorporateEvents200Response
import org.openapitools.client.models.ListConditions200Response
import org.openapitools.client.models.ListConditions400Response
import org.openapitools.client.models.ListContracts200Response
import org.openapitools.client.models.ListDividends200Response
import org.openapitools.client.models.ListExchanges200Response
import org.openapitools.client.models.ListExchanges400Response
import org.openapitools.client.models.ListFinancials200Response
import org.openapitools.client.models.ListIPOs200Response
import org.openapitools.client.models.ListMarketStatuses200Response
import org.openapitools.client.models.ListNews200Response
import org.openapitools.client.models.ListNewsPublishedUtcParameter
import org.openapitools.client.models.ListOptionsContracts200Response
import org.openapitools.client.models.ListProducts200Response
import org.openapitools.client.models.ListStockSplits200Response
import org.openapitools.client.models.ListTickerTypes200Response
import org.openapitools.client.models.ListTickers200Response
import org.openapitools.client.models.ProductDetails200Response
import org.openapitools.client.models.ProductSchedules200Response

import com.squareup.moshi.Json

import org.openapitools.client.infrastructure.ApiClient
import org.openapitools.client.infrastructure.ApiResponse
import org.openapitools.client.infrastructure.ClientException
import org.openapitools.client.infrastructure.ClientError
import org.openapitools.client.infrastructure.ServerException
import org.openapitools.client.infrastructure.ServerError
import org.openapitools.client.infrastructure.MultiValueMap
import org.openapitools.client.infrastructure.PartConfig
import org.openapitools.client.infrastructure.RequestConfig
import org.openapitools.client.infrastructure.RequestMethod
import org.openapitools.client.infrastructure.ResponseType
import org.openapitools.client.infrastructure.Success
import org.openapitools.client.infrastructure.toMultiValue

class DefaultApi(basePath: kotlin.String = defaultBasePath, client: Call.Factory = ApiClient.defaultClient) : ApiClient(basePath, client) {
    companion object {
        @JvmStatic
        val defaultBasePath: String by lazy {
            System.getProperties().getProperty(ApiClient.baseUrlKey, "https://api.massive.com")
        }
    }

    /**
     * GET /futures/vX/contracts/{ticker}
     * Contract Details
     * The Contract Details endpoint returns the details for a single contract at a specific point in time.
     * @param ticker The ticker symbol of the contract to retrieve.
     * @param asOf The point-in-time of the data to be retrieved. Note that the contract data returned for a given date represents the state of that contract on that day. A date in the format YYYY-MM-DD (default&#x3D;today). (optional)
     * @return ContractDetails200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun contractDetails(ticker: kotlin.String, asOf: java.time.LocalDate? = null) : ContractDetails200Response {
        val localVarResponse = contractDetailsWithHttpInfo(ticker = ticker, asOf = asOf)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ContractDetails200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/contracts/{ticker}
     * Contract Details
     * The Contract Details endpoint returns the details for a single contract at a specific point in time.
     * @param ticker The ticker symbol of the contract to retrieve.
     * @param asOf The point-in-time of the data to be retrieved. Note that the contract data returned for a given date represents the state of that contract on that day. A date in the format YYYY-MM-DD (default&#x3D;today). (optional)
     * @return ApiResponse<ContractDetails200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun contractDetailsWithHttpInfo(ticker: kotlin.String, asOf: java.time.LocalDate?) : ApiResponse<ContractDetails200Response?> {
        val localVariableConfig = contractDetailsRequestConfig(ticker = ticker, asOf = asOf)

        return request<Unit, ContractDetails200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation contractDetails
     *
     * @param ticker The ticker symbol of the contract to retrieve.
     * @param asOf The point-in-time of the data to be retrieved. Note that the contract data returned for a given date represents the state of that contract on that day. A date in the format YYYY-MM-DD (default&#x3D;today). (optional)
     * @return RequestConfig
     */
    fun contractDetailsRequestConfig(ticker: kotlin.String, asOf: java.time.LocalDate?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (asOf != null) {
                    put("as_of", listOf(parseDateToQueryString(asOf)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/contracts/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sort
     */
     enum class SortDailySchedules(val value: kotlin.String) {
         @Json(name = "trading_venue.asc") tradingVenuePeriodAsc("trading_venue.asc"),
         @Json(name = "trading_venue.desc") tradingVenuePeriodDesc("trading_venue.desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /futures/vX/schedules
     * Daily Schedules
     * The Trading-Date Based Futures Schedules API provides detailed trading schedules for all products on a specific day. This API allows you to retrieve detailed information about trading sessions, including market events like preopen, open, and closed, along with their precise timestamps.
     * @param sessionEndDate The session end date for the schedules (also known as the trading date). This is the day in CT for which the user wants to retrieve data. If left blank, this value defaults to &#39;today&#39; in Central Time. e.g. If a request is made from Pacific Time on &#39;2025-01-01&#39; at 11:00 pm with no &#39;session_end_date&#39; a default value of &#x60;2025-01-02&#x60; will be used. (optional)
     * @param tradingVenue The trading venue (MIC) of the exchange for the schedules. (optional)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to trading_venue.asc)
     * @return DailySchedules200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun dailySchedules(sessionEndDate: java.time.LocalDate? = null, tradingVenue: kotlin.String? = null, limit: kotlin.Int? = 100, sort: SortDailySchedules? = SortDailySchedules.tradingVenuePeriodAsc) : DailySchedules200Response {
        val localVarResponse = dailySchedulesWithHttpInfo(sessionEndDate = sessionEndDate, tradingVenue = tradingVenue, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DailySchedules200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/schedules
     * Daily Schedules
     * The Trading-Date Based Futures Schedules API provides detailed trading schedules for all products on a specific day. This API allows you to retrieve detailed information about trading sessions, including market events like preopen, open, and closed, along with their precise timestamps.
     * @param sessionEndDate The session end date for the schedules (also known as the trading date). This is the day in CT for which the user wants to retrieve data. If left blank, this value defaults to &#39;today&#39; in Central Time. e.g. If a request is made from Pacific Time on &#39;2025-01-01&#39; at 11:00 pm with no &#39;session_end_date&#39; a default value of &#x60;2025-01-02&#x60; will be used. (optional)
     * @param tradingVenue The trading venue (MIC) of the exchange for the schedules. (optional)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to trading_venue.asc)
     * @return ApiResponse<DailySchedules200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun dailySchedulesWithHttpInfo(sessionEndDate: java.time.LocalDate?, tradingVenue: kotlin.String?, limit: kotlin.Int?, sort: SortDailySchedules?) : ApiResponse<DailySchedules200Response?> {
        val localVariableConfig = dailySchedulesRequestConfig(sessionEndDate = sessionEndDate, tradingVenue = tradingVenue, limit = limit, sort = sort)

        return request<Unit, DailySchedules200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation dailySchedules
     *
     * @param sessionEndDate The session end date for the schedules (also known as the trading date). This is the day in CT for which the user wants to retrieve data. If left blank, this value defaults to &#39;today&#39; in Central Time. e.g. If a request is made from Pacific Time on &#39;2025-01-01&#39; at 11:00 pm with no &#39;session_end_date&#39; a default value of &#x60;2025-01-02&#x60; will be used. (optional)
     * @param tradingVenue The trading venue (MIC) of the exchange for the schedules. (optional)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to trading_venue.asc)
     * @return RequestConfig
     */
    fun dailySchedulesRequestConfig(sessionEndDate: java.time.LocalDate?, tradingVenue: kotlin.String?, limit: kotlin.Int?, sort: SortDailySchedules?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (sessionEndDate != null) {
                    put("session_end_date", listOf(parseDateToQueryString(sessionEndDate)))
                }
                if (tradingVenue != null) {
                    put("trading_venue", listOf(tradingVenue.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/schedules",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers/{ticker}/book
     * Ticker Full Book (L2)
     * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker The cryptocurrency ticker.
     * @return DeprecatedGetCryptoSnapshotTickerBook200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deprecatedGetCryptoSnapshotTickerBook(ticker: kotlin.String) : DeprecatedGetCryptoSnapshotTickerBook200Response {
        val localVarResponse = deprecatedGetCryptoSnapshotTickerBookWithHttpInfo(ticker = ticker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeprecatedGetCryptoSnapshotTickerBook200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers/{ticker}/book
     * Ticker Full Book (L2)
     * Get the current level 2 book of a single ticker. This is the combined book from all of the exchanges. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker The cryptocurrency ticker.
     * @return ApiResponse<DeprecatedGetCryptoSnapshotTickerBook200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deprecatedGetCryptoSnapshotTickerBookWithHttpInfo(ticker: kotlin.String) : ApiResponse<DeprecatedGetCryptoSnapshotTickerBook200Response?> {
        val localVariableConfig = deprecatedGetCryptoSnapshotTickerBookRequestConfig(ticker = ticker)

        return request<Unit, DeprecatedGetCryptoSnapshotTickerBook200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deprecatedGetCryptoSnapshotTickerBook
     *
     * @param ticker The cryptocurrency ticker.
     * @return RequestConfig
     */
    fun deprecatedGetCryptoSnapshotTickerBookRequestConfig(ticker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}/book".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/historic/crypto/{from}/{to}/{date}
     * Historic Crypto Trades
     * Get historic trade ticks for a cryptocurrency pair. 
     * @param from The \&quot;from\&quot; symbol of the crypto pair.
     * @param to The \&quot;to\&quot; symbol of the crypto pair.
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return DeprecatedGetHistoricCryptoTrades200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deprecatedGetHistoricCryptoTrades(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int? = null, limit: kotlin.Int? = null) : DeprecatedGetHistoricCryptoTrades200Response {
        val localVarResponse = deprecatedGetHistoricCryptoTradesWithHttpInfo(from = from, to = to, date = date, offset = offset, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeprecatedGetHistoricCryptoTrades200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/historic/crypto/{from}/{to}/{date}
     * Historic Crypto Trades
     * Get historic trade ticks for a cryptocurrency pair. 
     * @param from The \&quot;from\&quot; symbol of the crypto pair.
     * @param to The \&quot;to\&quot; symbol of the crypto pair.
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return ApiResponse<DeprecatedGetHistoricCryptoTrades200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deprecatedGetHistoricCryptoTradesWithHttpInfo(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<DeprecatedGetHistoricCryptoTrades200Response?> {
        val localVariableConfig = deprecatedGetHistoricCryptoTradesRequestConfig(from = from, to = to, date = date, offset = offset, limit = limit)

        return request<Unit, DeprecatedGetHistoricCryptoTrades200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deprecatedGetHistoricCryptoTrades
     *
     * @param from The \&quot;from\&quot; symbol of the crypto pair.
     * @param to The \&quot;to\&quot; symbol of the crypto pair.
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return RequestConfig
     */
    fun deprecatedGetHistoricCryptoTradesRequestConfig(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/historic/crypto/{from}/{to}/{date}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/historic/forex/{from}/{to}/{date}
     * Historic Forex Ticks
     * Get historic ticks for a forex currency pair. 
     * @param from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
     * @param to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return DeprecatedGetHistoricForexQuotes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deprecatedGetHistoricForexQuotes(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int? = null, limit: kotlin.Int? = null) : DeprecatedGetHistoricForexQuotes200Response {
        val localVarResponse = deprecatedGetHistoricForexQuotesWithHttpInfo(from = from, to = to, date = date, offset = offset, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeprecatedGetHistoricForexQuotes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/historic/forex/{from}/{to}/{date}
     * Historic Forex Ticks
     * Get historic ticks for a forex currency pair. 
     * @param from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
     * @param to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return ApiResponse<DeprecatedGetHistoricForexQuotes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deprecatedGetHistoricForexQuotesWithHttpInfo(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int?, limit: kotlin.Int?) : ApiResponse<DeprecatedGetHistoricForexQuotes200Response?> {
        val localVariableConfig = deprecatedGetHistoricForexQuotesRequestConfig(from = from, to = to, date = date, offset = offset, limit = limit)

        return request<Unit, DeprecatedGetHistoricForexQuotes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deprecatedGetHistoricForexQuotes
     *
     * @param from The \&quot;from\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;from&#x60; would be **USD**. 
     * @param to The \&quot;to\&quot; symbol of the currency pair.  Example: For **USD/JPY** the &#x60;to&#x60; would be **JPY**. 
     * @param date The date/day of the historic ticks to retrieve.
     * @param offset The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param limit Limit the size of the response, max 10000. (optional)
     * @return RequestConfig
     */
    fun deprecatedGetHistoricForexQuotesRequestConfig(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, offset: kotlin.Int?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (offset != null) {
                    put("offset", listOf(offset.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/historic/forex/{from}/{to}/{date}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/ticks/stocks/nbbo/{ticker}/{date}
     * Quotes (NBBO)
     * Get NBBO quotes for a given ticker symbol on a specified date. 
     * @param ticker The ticker symbol we want quotes for.
     * @param date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return DeprecatedGetHistoricStocksQuotes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deprecatedGetHistoricStocksQuotes(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int? = null, timestampLimit: kotlin.Int? = null, reverse: kotlin.Boolean? = null, limit: kotlin.Int? = null) : DeprecatedGetHistoricStocksQuotes200Response {
        val localVarResponse = deprecatedGetHistoricStocksQuotesWithHttpInfo(ticker = ticker, date = date, timestamp = timestamp, timestampLimit = timestampLimit, reverse = reverse, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeprecatedGetHistoricStocksQuotes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/ticks/stocks/nbbo/{ticker}/{date}
     * Quotes (NBBO)
     * Get NBBO quotes for a given ticker symbol on a specified date. 
     * @param ticker The ticker symbol we want quotes for.
     * @param date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return ApiResponse<DeprecatedGetHistoricStocksQuotes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deprecatedGetHistoricStocksQuotesWithHttpInfo(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int?, timestampLimit: kotlin.Int?, reverse: kotlin.Boolean?, limit: kotlin.Int?) : ApiResponse<DeprecatedGetHistoricStocksQuotes200Response?> {
        val localVariableConfig = deprecatedGetHistoricStocksQuotesRequestConfig(ticker = ticker, date = date, timestamp = timestamp, timestampLimit = timestampLimit, reverse = reverse, limit = limit)

        return request<Unit, DeprecatedGetHistoricStocksQuotes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deprecatedGetHistoricStocksQuotes
     *
     * @param ticker The ticker symbol we want quotes for.
     * @param date The date/day of the quotes to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return RequestConfig
     */
    fun deprecatedGetHistoricStocksQuotesRequestConfig(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int?, timestampLimit: kotlin.Int?, reverse: kotlin.Boolean?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampLimit != null) {
                    put("timestampLimit", listOf(timestampLimit.toString()))
                }
                if (reverse != null) {
                    put("reverse", listOf(reverse.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/ticks/stocks/nbbo/{ticker}/{date}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/ticks/stocks/trades/{ticker}/{date}
     * Trades
     * Get trades for a given ticker symbol on a specified date. 
     * @param ticker The ticker symbol we want trades for.
     * @param date The date/day of the trades to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return DeprecatedGetHistoricStocksTrades200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun deprecatedGetHistoricStocksTrades(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int? = null, timestampLimit: kotlin.Int? = null, reverse: kotlin.Boolean? = null, limit: kotlin.Int? = null) : DeprecatedGetHistoricStocksTrades200Response {
        val localVarResponse = deprecatedGetHistoricStocksTradesWithHttpInfo(ticker = ticker, date = date, timestamp = timestamp, timestampLimit = timestampLimit, reverse = reverse, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as DeprecatedGetHistoricStocksTrades200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/ticks/stocks/trades/{ticker}/{date}
     * Trades
     * Get trades for a given ticker symbol on a specified date. 
     * @param ticker The ticker symbol we want trades for.
     * @param date The date/day of the trades to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return ApiResponse<DeprecatedGetHistoricStocksTrades200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun deprecatedGetHistoricStocksTradesWithHttpInfo(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int?, timestampLimit: kotlin.Int?, reverse: kotlin.Boolean?, limit: kotlin.Int?) : ApiResponse<DeprecatedGetHistoricStocksTrades200Response?> {
        val localVariableConfig = deprecatedGetHistoricStocksTradesRequestConfig(ticker = ticker, date = date, timestamp = timestamp, timestampLimit = timestampLimit, reverse = reverse, limit = limit)

        return request<Unit, DeprecatedGetHistoricStocksTrades200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation deprecatedGetHistoricStocksTrades
     *
     * @param ticker The ticker symbol we want trades for.
     * @param date The date/day of the trades to retrieve in the format YYYY-MM-DD.
     * @param timestamp The timestamp offset, used for pagination. This is the offset at which to start the results. Using the &#x60;timestamp&#x60; of the last result as the offset will give you the next page of results.  (optional)
     * @param timestampLimit The maximum timestamp allowed in the results.  (optional)
     * @param reverse Reverse the order of the results.  (optional)
     * @param limit Limit the size of the response, max 50000 and default 5000. (optional)
     * @return RequestConfig
     */
    fun deprecatedGetHistoricStocksTradesRequestConfig(ticker: kotlin.String, date: java.time.LocalDate, timestamp: kotlin.Int?, timestampLimit: kotlin.Int?, reverse: kotlin.Boolean?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampLimit != null) {
                    put("timestampLimit", listOf(timestampLimit.toString()))
                }
                if (reverse != null) {
                    put("reverse", listOf(reverse.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/ticks/stocks/trades/{ticker}/{date}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/analyst-insights
     * 
     * A comprehensive database of financial analyst insights and ratings for various publicly traded companies, capturing detailed information about analyst recommendations and price targets.
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firm The name of the research firm or investment bank issuing the rating. (optional)
     * @param firmAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmGt Filter greater than the value. (optional)
     * @param firmGte Filter greater than or equal to the value. (optional)
     * @param firmLt Filter less than the value. (optional)
     * @param firmLte Filter less than or equal to the value. (optional)
     * @param ratingAction The description of the change in rating from the firm&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved. (optional)
     * @param ratingActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param ratingActionGt Filter greater than the value. (optional)
     * @param ratingActionGte Filter greater than or equal to the value. (optional)
     * @param ratingActionLt Filter less than the value. (optional)
     * @param ratingActionLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The identifer used by Benzinga for the firm record. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param benzingaRatingId The identifier used by Benzinga for the rating record. (optional)
     * @param benzingaRatingIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaRatingIdGt Filter greater than the value. (optional)
     * @param benzingaRatingIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaRatingIdLt Filter less than the value. (optional)
     * @param benzingaRatingIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;last_updated&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "last_updated.desc")
     * @return GetBenzingaV1AnalystInsights200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1AnalystInsights(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, lastUpdated: kotlin.String? = null, lastUpdatedGt: kotlin.String? = null, lastUpdatedGte: kotlin.String? = null, lastUpdatedLt: kotlin.String? = null, lastUpdatedLte: kotlin.String? = null, firm: kotlin.String? = null, firmAnyOf: kotlin.String? = null, firmGt: kotlin.String? = null, firmGte: kotlin.String? = null, firmLt: kotlin.String? = null, firmLte: kotlin.String? = null, ratingAction: kotlin.String? = null, ratingActionAnyOf: kotlin.String? = null, ratingActionGt: kotlin.String? = null, ratingActionGte: kotlin.String? = null, ratingActionLt: kotlin.String? = null, ratingActionLte: kotlin.String? = null, benzingaFirmId: kotlin.String? = null, benzingaFirmIdAnyOf: kotlin.String? = null, benzingaFirmIdGt: kotlin.String? = null, benzingaFirmIdGte: kotlin.String? = null, benzingaFirmIdLt: kotlin.String? = null, benzingaFirmIdLte: kotlin.String? = null, benzingaRatingId: kotlin.String? = null, benzingaRatingIdAnyOf: kotlin.String? = null, benzingaRatingIdGt: kotlin.String? = null, benzingaRatingIdGte: kotlin.String? = null, benzingaRatingIdLt: kotlin.String? = null, benzingaRatingIdLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "last_updated.desc") : GetBenzingaV1AnalystInsights200Response {
        val localVarResponse = getBenzingaV1AnalystInsightsWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, lastUpdated = lastUpdated, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, firm = firm, firmAnyOf = firmAnyOf, firmGt = firmGt, firmGte = firmGte, firmLt = firmLt, firmLte = firmLte, ratingAction = ratingAction, ratingActionAnyOf = ratingActionAnyOf, ratingActionGt = ratingActionGt, ratingActionGte = ratingActionGte, ratingActionLt = ratingActionLt, ratingActionLte = ratingActionLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, benzingaRatingId = benzingaRatingId, benzingaRatingIdAnyOf = benzingaRatingIdAnyOf, benzingaRatingIdGt = benzingaRatingIdGt, benzingaRatingIdGte = benzingaRatingIdGte, benzingaRatingIdLt = benzingaRatingIdLt, benzingaRatingIdLte = benzingaRatingIdLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1AnalystInsights200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/analyst-insights
     * 
     * A comprehensive database of financial analyst insights and ratings for various publicly traded companies, capturing detailed information about analyst recommendations and price targets.
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firm The name of the research firm or investment bank issuing the rating. (optional)
     * @param firmAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmGt Filter greater than the value. (optional)
     * @param firmGte Filter greater than or equal to the value. (optional)
     * @param firmLt Filter less than the value. (optional)
     * @param firmLte Filter less than or equal to the value. (optional)
     * @param ratingAction The description of the change in rating from the firm&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved. (optional)
     * @param ratingActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param ratingActionGt Filter greater than the value. (optional)
     * @param ratingActionGte Filter greater than or equal to the value. (optional)
     * @param ratingActionLt Filter less than the value. (optional)
     * @param ratingActionLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The identifer used by Benzinga for the firm record. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param benzingaRatingId The identifier used by Benzinga for the rating record. (optional)
     * @param benzingaRatingIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaRatingIdGt Filter greater than the value. (optional)
     * @param benzingaRatingIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaRatingIdLt Filter less than the value. (optional)
     * @param benzingaRatingIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;last_updated&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "last_updated.desc")
     * @return ApiResponse<GetBenzingaV1AnalystInsights200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1AnalystInsightsWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, lastUpdated: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, firm: kotlin.String?, firmAnyOf: kotlin.String?, firmGt: kotlin.String?, firmGte: kotlin.String?, firmLt: kotlin.String?, firmLte: kotlin.String?, ratingAction: kotlin.String?, ratingActionAnyOf: kotlin.String?, ratingActionGt: kotlin.String?, ratingActionGte: kotlin.String?, ratingActionLt: kotlin.String?, ratingActionLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, benzingaRatingId: kotlin.String?, benzingaRatingIdAnyOf: kotlin.String?, benzingaRatingIdGt: kotlin.String?, benzingaRatingIdGte: kotlin.String?, benzingaRatingIdLt: kotlin.String?, benzingaRatingIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1AnalystInsights200Response?> {
        val localVariableConfig = getBenzingaV1AnalystInsightsRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, lastUpdated = lastUpdated, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, firm = firm, firmAnyOf = firmAnyOf, firmGt = firmGt, firmGte = firmGte, firmLt = firmLt, firmLte = firmLte, ratingAction = ratingAction, ratingActionAnyOf = ratingActionAnyOf, ratingActionGt = ratingActionGt, ratingActionGte = ratingActionGte, ratingActionLt = ratingActionLt, ratingActionLte = ratingActionLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, benzingaRatingId = benzingaRatingId, benzingaRatingIdAnyOf = benzingaRatingIdAnyOf, benzingaRatingIdGt = benzingaRatingIdGt, benzingaRatingIdGte = benzingaRatingIdGte, benzingaRatingIdLt = benzingaRatingIdLt, benzingaRatingIdLte = benzingaRatingIdLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1AnalystInsights200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1AnalystInsights
     *
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firm The name of the research firm or investment bank issuing the rating. (optional)
     * @param firmAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmGt Filter greater than the value. (optional)
     * @param firmGte Filter greater than or equal to the value. (optional)
     * @param firmLt Filter less than the value. (optional)
     * @param firmLte Filter less than or equal to the value. (optional)
     * @param ratingAction The description of the change in rating from the firm&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved. (optional)
     * @param ratingActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param ratingActionGt Filter greater than the value. (optional)
     * @param ratingActionGte Filter greater than or equal to the value. (optional)
     * @param ratingActionLt Filter less than the value. (optional)
     * @param ratingActionLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The identifer used by Benzinga for the firm record. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param benzingaRatingId The identifier used by Benzinga for the rating record. (optional)
     * @param benzingaRatingIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaRatingIdGt Filter greater than the value. (optional)
     * @param benzingaRatingIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaRatingIdLt Filter less than the value. (optional)
     * @param benzingaRatingIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;last_updated&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "last_updated.desc")
     * @return RequestConfig
     */
    fun getBenzingaV1AnalystInsightsRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, lastUpdated: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, firm: kotlin.String?, firmAnyOf: kotlin.String?, firmGt: kotlin.String?, firmGte: kotlin.String?, firmLt: kotlin.String?, firmLte: kotlin.String?, ratingAction: kotlin.String?, ratingActionAnyOf: kotlin.String?, ratingActionGt: kotlin.String?, ratingActionGte: kotlin.String?, ratingActionLt: kotlin.String?, ratingActionLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, benzingaRatingId: kotlin.String?, benzingaRatingIdAnyOf: kotlin.String?, benzingaRatingIdGt: kotlin.String?, benzingaRatingIdGte: kotlin.String?, benzingaRatingIdLt: kotlin.String?, benzingaRatingIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(lastUpdated.toString()))
                }
                if (lastUpdatedGt != null) {
                    put("last_updated.gt", listOf(lastUpdatedGt.toString()))
                }
                if (lastUpdatedGte != null) {
                    put("last_updated.gte", listOf(lastUpdatedGte.toString()))
                }
                if (lastUpdatedLt != null) {
                    put("last_updated.lt", listOf(lastUpdatedLt.toString()))
                }
                if (lastUpdatedLte != null) {
                    put("last_updated.lte", listOf(lastUpdatedLte.toString()))
                }
                if (firm != null) {
                    put("firm", listOf(firm.toString()))
                }
                if (firmAnyOf != null) {
                    put("firm.any_of", listOf(firmAnyOf.toString()))
                }
                if (firmGt != null) {
                    put("firm.gt", listOf(firmGt.toString()))
                }
                if (firmGte != null) {
                    put("firm.gte", listOf(firmGte.toString()))
                }
                if (firmLt != null) {
                    put("firm.lt", listOf(firmLt.toString()))
                }
                if (firmLte != null) {
                    put("firm.lte", listOf(firmLte.toString()))
                }
                if (ratingAction != null) {
                    put("rating_action", listOf(ratingAction.toString()))
                }
                if (ratingActionAnyOf != null) {
                    put("rating_action.any_of", listOf(ratingActionAnyOf.toString()))
                }
                if (ratingActionGt != null) {
                    put("rating_action.gt", listOf(ratingActionGt.toString()))
                }
                if (ratingActionGte != null) {
                    put("rating_action.gte", listOf(ratingActionGte.toString()))
                }
                if (ratingActionLt != null) {
                    put("rating_action.lt", listOf(ratingActionLt.toString()))
                }
                if (ratingActionLte != null) {
                    put("rating_action.lte", listOf(ratingActionLte.toString()))
                }
                if (benzingaFirmId != null) {
                    put("benzinga_firm_id", listOf(benzingaFirmId.toString()))
                }
                if (benzingaFirmIdAnyOf != null) {
                    put("benzinga_firm_id.any_of", listOf(benzingaFirmIdAnyOf.toString()))
                }
                if (benzingaFirmIdGt != null) {
                    put("benzinga_firm_id.gt", listOf(benzingaFirmIdGt.toString()))
                }
                if (benzingaFirmIdGte != null) {
                    put("benzinga_firm_id.gte", listOf(benzingaFirmIdGte.toString()))
                }
                if (benzingaFirmIdLt != null) {
                    put("benzinga_firm_id.lt", listOf(benzingaFirmIdLt.toString()))
                }
                if (benzingaFirmIdLte != null) {
                    put("benzinga_firm_id.lte", listOf(benzingaFirmIdLte.toString()))
                }
                if (benzingaRatingId != null) {
                    put("benzinga_rating_id", listOf(benzingaRatingId.toString()))
                }
                if (benzingaRatingIdAnyOf != null) {
                    put("benzinga_rating_id.any_of", listOf(benzingaRatingIdAnyOf.toString()))
                }
                if (benzingaRatingIdGt != null) {
                    put("benzinga_rating_id.gt", listOf(benzingaRatingIdGt.toString()))
                }
                if (benzingaRatingIdGte != null) {
                    put("benzinga_rating_id.gte", listOf(benzingaRatingIdGte.toString()))
                }
                if (benzingaRatingIdLt != null) {
                    put("benzinga_rating_id.lt", listOf(benzingaRatingIdLt.toString()))
                }
                if (benzingaRatingIdLte != null) {
                    put("benzinga_rating_id.lte", listOf(benzingaRatingIdLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/analyst-insights",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/analysts
     * 
     * A comprehensive database of financial analysts, containing detailed performance metrics and identification information for individual analysts across various financial firms.
     * @param benzingaId The identifier used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The unique identifier assigned by Benzinga to the research firm or investment bank. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param firmName The name of the research firm or investment bank issuing the ratings. (optional)
     * @param firmNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmNameGt Filter greater than the value. (optional)
     * @param firmNameGte Filter greater than or equal to the value. (optional)
     * @param firmNameLt Filter less than the value. (optional)
     * @param firmNameLte Filter less than or equal to the value. (optional)
     * @param fullName The full name of the analyst associated with the ratings. (optional)
     * @param fullNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fullNameGt Filter greater than the value. (optional)
     * @param fullNameGte Filter greater than or equal to the value. (optional)
     * @param fullNameLt Filter less than the value. (optional)
     * @param fullNameLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;full_name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "full_name.asc")
     * @return GetBenzingaV1Analysts200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1Analysts(benzingaId: kotlin.String? = null, benzingaIdAnyOf: kotlin.String? = null, benzingaIdGt: kotlin.String? = null, benzingaIdGte: kotlin.String? = null, benzingaIdLt: kotlin.String? = null, benzingaIdLte: kotlin.String? = null, benzingaFirmId: kotlin.String? = null, benzingaFirmIdAnyOf: kotlin.String? = null, benzingaFirmIdGt: kotlin.String? = null, benzingaFirmIdGte: kotlin.String? = null, benzingaFirmIdLt: kotlin.String? = null, benzingaFirmIdLte: kotlin.String? = null, firmName: kotlin.String? = null, firmNameAnyOf: kotlin.String? = null, firmNameGt: kotlin.String? = null, firmNameGte: kotlin.String? = null, firmNameLt: kotlin.String? = null, firmNameLte: kotlin.String? = null, fullName: kotlin.String? = null, fullNameAnyOf: kotlin.String? = null, fullNameGt: kotlin.String? = null, fullNameGte: kotlin.String? = null, fullNameLt: kotlin.String? = null, fullNameLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "full_name.asc") : GetBenzingaV1Analysts200Response {
        val localVarResponse = getBenzingaV1AnalystsWithHttpInfo(benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, firmName = firmName, firmNameAnyOf = firmNameAnyOf, firmNameGt = firmNameGt, firmNameGte = firmNameGte, firmNameLt = firmNameLt, firmNameLte = firmNameLte, fullName = fullName, fullNameAnyOf = fullNameAnyOf, fullNameGt = fullNameGt, fullNameGte = fullNameGte, fullNameLt = fullNameLt, fullNameLte = fullNameLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1Analysts200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/analysts
     * 
     * A comprehensive database of financial analysts, containing detailed performance metrics and identification information for individual analysts across various financial firms.
     * @param benzingaId The identifier used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The unique identifier assigned by Benzinga to the research firm or investment bank. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param firmName The name of the research firm or investment bank issuing the ratings. (optional)
     * @param firmNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmNameGt Filter greater than the value. (optional)
     * @param firmNameGte Filter greater than or equal to the value. (optional)
     * @param firmNameLt Filter less than the value. (optional)
     * @param firmNameLte Filter less than or equal to the value. (optional)
     * @param fullName The full name of the analyst associated with the ratings. (optional)
     * @param fullNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fullNameGt Filter greater than the value. (optional)
     * @param fullNameGte Filter greater than or equal to the value. (optional)
     * @param fullNameLt Filter less than the value. (optional)
     * @param fullNameLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;full_name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "full_name.asc")
     * @return ApiResponse<GetBenzingaV1Analysts200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1AnalystsWithHttpInfo(benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, firmName: kotlin.String?, firmNameAnyOf: kotlin.String?, firmNameGt: kotlin.String?, firmNameGte: kotlin.String?, firmNameLt: kotlin.String?, firmNameLte: kotlin.String?, fullName: kotlin.String?, fullNameAnyOf: kotlin.String?, fullNameGt: kotlin.String?, fullNameGte: kotlin.String?, fullNameLt: kotlin.String?, fullNameLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1Analysts200Response?> {
        val localVariableConfig = getBenzingaV1AnalystsRequestConfig(benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, firmName = firmName, firmNameAnyOf = firmNameAnyOf, firmNameGt = firmNameGt, firmNameGte = firmNameGte, firmNameLt = firmNameLt, firmNameLte = firmNameLte, fullName = fullName, fullNameAnyOf = fullNameAnyOf, fullNameGt = fullNameGt, fullNameGte = fullNameGte, fullNameLt = fullNameLt, fullNameLte = fullNameLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1Analysts200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1Analysts
     *
     * @param benzingaId The identifier used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The unique identifier assigned by Benzinga to the research firm or investment bank. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param firmName The name of the research firm or investment bank issuing the ratings. (optional)
     * @param firmNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param firmNameGt Filter greater than the value. (optional)
     * @param firmNameGte Filter greater than or equal to the value. (optional)
     * @param firmNameLt Filter less than the value. (optional)
     * @param firmNameLte Filter less than or equal to the value. (optional)
     * @param fullName The full name of the analyst associated with the ratings. (optional)
     * @param fullNameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fullNameGt Filter greater than the value. (optional)
     * @param fullNameGte Filter greater than or equal to the value. (optional)
     * @param fullNameLt Filter less than the value. (optional)
     * @param fullNameLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;full_name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "full_name.asc")
     * @return RequestConfig
     */
    fun getBenzingaV1AnalystsRequestConfig(benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, firmName: kotlin.String?, firmNameAnyOf: kotlin.String?, firmNameGt: kotlin.String?, firmNameGte: kotlin.String?, firmNameLt: kotlin.String?, firmNameLte: kotlin.String?, fullName: kotlin.String?, fullNameAnyOf: kotlin.String?, fullNameGt: kotlin.String?, fullNameGte: kotlin.String?, fullNameLt: kotlin.String?, fullNameLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (benzingaId != null) {
                    put("benzinga_id", listOf(benzingaId.toString()))
                }
                if (benzingaIdAnyOf != null) {
                    put("benzinga_id.any_of", listOf(benzingaIdAnyOf.toString()))
                }
                if (benzingaIdGt != null) {
                    put("benzinga_id.gt", listOf(benzingaIdGt.toString()))
                }
                if (benzingaIdGte != null) {
                    put("benzinga_id.gte", listOf(benzingaIdGte.toString()))
                }
                if (benzingaIdLt != null) {
                    put("benzinga_id.lt", listOf(benzingaIdLt.toString()))
                }
                if (benzingaIdLte != null) {
                    put("benzinga_id.lte", listOf(benzingaIdLte.toString()))
                }
                if (benzingaFirmId != null) {
                    put("benzinga_firm_id", listOf(benzingaFirmId.toString()))
                }
                if (benzingaFirmIdAnyOf != null) {
                    put("benzinga_firm_id.any_of", listOf(benzingaFirmIdAnyOf.toString()))
                }
                if (benzingaFirmIdGt != null) {
                    put("benzinga_firm_id.gt", listOf(benzingaFirmIdGt.toString()))
                }
                if (benzingaFirmIdGte != null) {
                    put("benzinga_firm_id.gte", listOf(benzingaFirmIdGte.toString()))
                }
                if (benzingaFirmIdLt != null) {
                    put("benzinga_firm_id.lt", listOf(benzingaFirmIdLt.toString()))
                }
                if (benzingaFirmIdLte != null) {
                    put("benzinga_firm_id.lte", listOf(benzingaFirmIdLte.toString()))
                }
                if (firmName != null) {
                    put("firm_name", listOf(firmName.toString()))
                }
                if (firmNameAnyOf != null) {
                    put("firm_name.any_of", listOf(firmNameAnyOf.toString()))
                }
                if (firmNameGt != null) {
                    put("firm_name.gt", listOf(firmNameGt.toString()))
                }
                if (firmNameGte != null) {
                    put("firm_name.gte", listOf(firmNameGte.toString()))
                }
                if (firmNameLt != null) {
                    put("firm_name.lt", listOf(firmNameLt.toString()))
                }
                if (firmNameLte != null) {
                    put("firm_name.lte", listOf(firmNameLte.toString()))
                }
                if (fullName != null) {
                    put("full_name", listOf(fullName.toString()))
                }
                if (fullNameAnyOf != null) {
                    put("full_name.any_of", listOf(fullNameAnyOf.toString()))
                }
                if (fullNameGt != null) {
                    put("full_name.gt", listOf(fullNameGt.toString()))
                }
                if (fullNameGte != null) {
                    put("full_name.gte", listOf(fullNameGte.toString()))
                }
                if (fullNameLt != null) {
                    put("full_name.lt", listOf(fullNameLt.toString()))
                }
                if (fullNameLte != null) {
                    put("full_name.lte", listOf(fullNameLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/analysts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/consensus-ratings/{ticker}
     * 
     * A comprehensive financial consensus ratings table that aggregates analyst recommendations and price targets for individual stock tickers, capturing detailed rating breakdowns and statistical insights.
     * @param ticker The requested ticker.
     * @param date The date range to aggregate analyst ratings over. For example, date.gte&#x3D;2024-10-01 and date.lt&#x3D;2025-01-01 for ratings published in Q4 2024. By default, all ratings are aggregated regardless of date. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @return GetBenzingaV1ConsensusRatings200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1ConsensusRatings(ticker: kotlin.String, date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, limit: kotlin.Int? = 100) : GetBenzingaV1ConsensusRatings200Response {
        val localVarResponse = getBenzingaV1ConsensusRatingsWithHttpInfo(ticker = ticker, date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1ConsensusRatings200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/consensus-ratings/{ticker}
     * 
     * A comprehensive financial consensus ratings table that aggregates analyst recommendations and price targets for individual stock tickers, capturing detailed rating breakdowns and statistical insights.
     * @param ticker The requested ticker.
     * @param date The date range to aggregate analyst ratings over. For example, date.gte&#x3D;2024-10-01 and date.lt&#x3D;2025-01-01 for ratings published in Q4 2024. By default, all ratings are aggregated regardless of date. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @return ApiResponse<GetBenzingaV1ConsensusRatings200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1ConsensusRatingsWithHttpInfo(ticker: kotlin.String, date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?) : ApiResponse<GetBenzingaV1ConsensusRatings200Response?> {
        val localVariableConfig = getBenzingaV1ConsensusRatingsRequestConfig(ticker = ticker, date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit)

        return request<Unit, GetBenzingaV1ConsensusRatings200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1ConsensusRatings
     *
     * @param ticker The requested ticker.
     * @param date The date range to aggregate analyst ratings over. For example, date.gte&#x3D;2024-10-01 and date.lt&#x3D;2025-01-01 for ratings published in Q4 2024. By default, all ratings are aggregated regardless of date. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @return RequestConfig
     */
    fun getBenzingaV1ConsensusRatingsRequestConfig(ticker: kotlin.String, date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/consensus-ratings/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/earnings
     * 
     * This table contains earnings data from Benzinga, tracking both actual and estimated financial metrics for publicly traded companies. It includes EPS and revenue figures with surprise calculations, along with metadata like fiscal periods, company identifiers, and reporting timestamps.
     * @param date The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company reporting earnings. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateStatus Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed. (optional)
     * @param dateStatusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateStatusGt Filter greater than the value. (optional)
     * @param dateStatusGte Filter greater than or equal to the value. (optional)
     * @param dateStatusLt Filter less than the value. (optional)
     * @param dateStatusLte Filter less than or equal to the value. (optional)
     * @param epsSurprisePercent The percentage difference between the actual and estimated EPS. Value must be a floating point number. (optional)
     * @param epsSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercent The percentage difference between the actual and estimated revenue. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYear The fiscal year in which the earnings period falls. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;last_updated&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "last_updated.desc")
     * @return GetBenzingaV1Earnings200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1Earnings(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, importance: kotlin.Long? = null, importanceAnyOf: kotlin.String? = null, importanceGt: kotlin.Long? = null, importanceGte: kotlin.Long? = null, importanceLt: kotlin.Long? = null, importanceLte: kotlin.Long? = null, lastUpdated: kotlin.String? = null, lastUpdatedAnyOf: kotlin.String? = null, lastUpdatedGt: kotlin.String? = null, lastUpdatedGte: kotlin.String? = null, lastUpdatedLt: kotlin.String? = null, lastUpdatedLte: kotlin.String? = null, dateStatus: kotlin.String? = null, dateStatusAnyOf: kotlin.String? = null, dateStatusGt: kotlin.String? = null, dateStatusGte: kotlin.String? = null, dateStatusLt: kotlin.String? = null, dateStatusLte: kotlin.String? = null, epsSurprisePercent: kotlin.Double? = null, epsSurprisePercentAnyOf: kotlin.String? = null, epsSurprisePercentGt: kotlin.Double? = null, epsSurprisePercentGte: kotlin.Double? = null, epsSurprisePercentLt: kotlin.Double? = null, epsSurprisePercentLte: kotlin.Double? = null, revenueSurprisePercent: kotlin.Double? = null, revenueSurprisePercentAnyOf: kotlin.String? = null, revenueSurprisePercentGt: kotlin.Double? = null, revenueSurprisePercentGte: kotlin.Double? = null, revenueSurprisePercentLt: kotlin.Double? = null, revenueSurprisePercentLte: kotlin.Double? = null, fiscalYear: kotlin.Long? = null, fiscalYearAnyOf: kotlin.String? = null, fiscalYearGt: kotlin.Long? = null, fiscalYearGte: kotlin.Long? = null, fiscalYearLt: kotlin.Long? = null, fiscalYearLte: kotlin.Long? = null, fiscalPeriod: kotlin.String? = null, fiscalPeriodAnyOf: kotlin.String? = null, fiscalPeriodGt: kotlin.String? = null, fiscalPeriodGte: kotlin.String? = null, fiscalPeriodLt: kotlin.String? = null, fiscalPeriodLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "last_updated.desc") : GetBenzingaV1Earnings200Response {
        val localVarResponse = getBenzingaV1EarningsWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, importance = importance, importanceAnyOf = importanceAnyOf, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, dateStatus = dateStatus, dateStatusAnyOf = dateStatusAnyOf, dateStatusGt = dateStatusGt, dateStatusGte = dateStatusGte, dateStatusLt = dateStatusLt, dateStatusLte = dateStatusLte, epsSurprisePercent = epsSurprisePercent, epsSurprisePercentAnyOf = epsSurprisePercentAnyOf, epsSurprisePercentGt = epsSurprisePercentGt, epsSurprisePercentGte = epsSurprisePercentGte, epsSurprisePercentLt = epsSurprisePercentLt, epsSurprisePercentLte = epsSurprisePercentLte, revenueSurprisePercent = revenueSurprisePercent, revenueSurprisePercentAnyOf = revenueSurprisePercentAnyOf, revenueSurprisePercentGt = revenueSurprisePercentGt, revenueSurprisePercentGte = revenueSurprisePercentGte, revenueSurprisePercentLt = revenueSurprisePercentLt, revenueSurprisePercentLte = revenueSurprisePercentLte, fiscalYear = fiscalYear, fiscalYearAnyOf = fiscalYearAnyOf, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalPeriod = fiscalPeriod, fiscalPeriodAnyOf = fiscalPeriodAnyOf, fiscalPeriodGt = fiscalPeriodGt, fiscalPeriodGte = fiscalPeriodGte, fiscalPeriodLt = fiscalPeriodLt, fiscalPeriodLte = fiscalPeriodLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1Earnings200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/earnings
     * 
     * This table contains earnings data from Benzinga, tracking both actual and estimated financial metrics for publicly traded companies. It includes EPS and revenue figures with surprise calculations, along with metadata like fiscal periods, company identifiers, and reporting timestamps.
     * @param date The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company reporting earnings. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateStatus Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed. (optional)
     * @param dateStatusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateStatusGt Filter greater than the value. (optional)
     * @param dateStatusGte Filter greater than or equal to the value. (optional)
     * @param dateStatusLt Filter less than the value. (optional)
     * @param dateStatusLte Filter less than or equal to the value. (optional)
     * @param epsSurprisePercent The percentage difference between the actual and estimated EPS. Value must be a floating point number. (optional)
     * @param epsSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercent The percentage difference between the actual and estimated revenue. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYear The fiscal year in which the earnings period falls. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;last_updated&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "last_updated.desc")
     * @return ApiResponse<GetBenzingaV1Earnings200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1EarningsWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, importance: kotlin.Long?, importanceAnyOf: kotlin.String?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, dateStatus: kotlin.String?, dateStatusAnyOf: kotlin.String?, dateStatusGt: kotlin.String?, dateStatusGte: kotlin.String?, dateStatusLt: kotlin.String?, dateStatusLte: kotlin.String?, epsSurprisePercent: kotlin.Double?, epsSurprisePercentAnyOf: kotlin.String?, epsSurprisePercentGt: kotlin.Double?, epsSurprisePercentGte: kotlin.Double?, epsSurprisePercentLt: kotlin.Double?, epsSurprisePercentLte: kotlin.Double?, revenueSurprisePercent: kotlin.Double?, revenueSurprisePercentAnyOf: kotlin.String?, revenueSurprisePercentGt: kotlin.Double?, revenueSurprisePercentGte: kotlin.Double?, revenueSurprisePercentLt: kotlin.Double?, revenueSurprisePercentLte: kotlin.Double?, fiscalYear: kotlin.Long?, fiscalYearAnyOf: kotlin.String?, fiscalYearGt: kotlin.Long?, fiscalYearGte: kotlin.Long?, fiscalYearLt: kotlin.Long?, fiscalYearLte: kotlin.Long?, fiscalPeriod: kotlin.String?, fiscalPeriodAnyOf: kotlin.String?, fiscalPeriodGt: kotlin.String?, fiscalPeriodGte: kotlin.String?, fiscalPeriodLt: kotlin.String?, fiscalPeriodLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1Earnings200Response?> {
        val localVariableConfig = getBenzingaV1EarningsRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, importance = importance, importanceAnyOf = importanceAnyOf, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, dateStatus = dateStatus, dateStatusAnyOf = dateStatusAnyOf, dateStatusGt = dateStatusGt, dateStatusGte = dateStatusGte, dateStatusLt = dateStatusLt, dateStatusLte = dateStatusLte, epsSurprisePercent = epsSurprisePercent, epsSurprisePercentAnyOf = epsSurprisePercentAnyOf, epsSurprisePercentGt = epsSurprisePercentGt, epsSurprisePercentGte = epsSurprisePercentGte, epsSurprisePercentLt = epsSurprisePercentLt, epsSurprisePercentLte = epsSurprisePercentLte, revenueSurprisePercent = revenueSurprisePercent, revenueSurprisePercentAnyOf = revenueSurprisePercentAnyOf, revenueSurprisePercentGt = revenueSurprisePercentGt, revenueSurprisePercentGte = revenueSurprisePercentGte, revenueSurprisePercentLt = revenueSurprisePercentLt, revenueSurprisePercentLte = revenueSurprisePercentLte, fiscalYear = fiscalYear, fiscalYearAnyOf = fiscalYearAnyOf, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalPeriod = fiscalPeriod, fiscalPeriodAnyOf = fiscalPeriodAnyOf, fiscalPeriodGt = fiscalPeriodGt, fiscalPeriodGte = fiscalPeriodGte, fiscalPeriodLt = fiscalPeriodLt, fiscalPeriodLte = fiscalPeriodLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1Earnings200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1Earnings
     *
     * @param date The calendar date (formatted as YYYY-MM-DD) when the earnings are scheduled or were reported. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company reporting earnings. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateStatus Indicates whether the date of the earnings report has been confirmed. Possible values include: projected, confirmed. (optional)
     * @param dateStatusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateStatusGt Filter greater than the value. (optional)
     * @param dateStatusGte Filter greater than or equal to the value. (optional)
     * @param dateStatusLt Filter less than the value. (optional)
     * @param dateStatusLte Filter less than or equal to the value. (optional)
     * @param epsSurprisePercent The percentage difference between the actual and estimated EPS. Value must be a floating point number. (optional)
     * @param epsSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param epsSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercent The percentage difference between the actual and estimated revenue. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param revenueSurprisePercentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYear The fiscal year in which the earnings period falls. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal period for which the earnings are reported. Examples include: Q1, Q2, H1, FY. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;last_updated&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "last_updated.desc")
     * @return RequestConfig
     */
    fun getBenzingaV1EarningsRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, importance: kotlin.Long?, importanceAnyOf: kotlin.String?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, dateStatus: kotlin.String?, dateStatusAnyOf: kotlin.String?, dateStatusGt: kotlin.String?, dateStatusGte: kotlin.String?, dateStatusLt: kotlin.String?, dateStatusLte: kotlin.String?, epsSurprisePercent: kotlin.Double?, epsSurprisePercentAnyOf: kotlin.String?, epsSurprisePercentGt: kotlin.Double?, epsSurprisePercentGte: kotlin.Double?, epsSurprisePercentLt: kotlin.Double?, epsSurprisePercentLte: kotlin.Double?, revenueSurprisePercent: kotlin.Double?, revenueSurprisePercentAnyOf: kotlin.String?, revenueSurprisePercentGt: kotlin.Double?, revenueSurprisePercentGte: kotlin.Double?, revenueSurprisePercentLt: kotlin.Double?, revenueSurprisePercentLte: kotlin.Double?, fiscalYear: kotlin.Long?, fiscalYearAnyOf: kotlin.String?, fiscalYearGt: kotlin.Long?, fiscalYearGte: kotlin.Long?, fiscalYearLt: kotlin.Long?, fiscalYearLte: kotlin.Long?, fiscalPeriod: kotlin.String?, fiscalPeriodAnyOf: kotlin.String?, fiscalPeriodGt: kotlin.String?, fiscalPeriodGte: kotlin.String?, fiscalPeriodLt: kotlin.String?, fiscalPeriodLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (importance != null) {
                    put("importance", listOf(importance.toString()))
                }
                if (importanceAnyOf != null) {
                    put("importance.any_of", listOf(importanceAnyOf.toString()))
                }
                if (importanceGt != null) {
                    put("importance.gt", listOf(importanceGt.toString()))
                }
                if (importanceGte != null) {
                    put("importance.gte", listOf(importanceGte.toString()))
                }
                if (importanceLt != null) {
                    put("importance.lt", listOf(importanceLt.toString()))
                }
                if (importanceLte != null) {
                    put("importance.lte", listOf(importanceLte.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(lastUpdated.toString()))
                }
                if (lastUpdatedAnyOf != null) {
                    put("last_updated.any_of", listOf(lastUpdatedAnyOf.toString()))
                }
                if (lastUpdatedGt != null) {
                    put("last_updated.gt", listOf(lastUpdatedGt.toString()))
                }
                if (lastUpdatedGte != null) {
                    put("last_updated.gte", listOf(lastUpdatedGte.toString()))
                }
                if (lastUpdatedLt != null) {
                    put("last_updated.lt", listOf(lastUpdatedLt.toString()))
                }
                if (lastUpdatedLte != null) {
                    put("last_updated.lte", listOf(lastUpdatedLte.toString()))
                }
                if (dateStatus != null) {
                    put("date_status", listOf(dateStatus.toString()))
                }
                if (dateStatusAnyOf != null) {
                    put("date_status.any_of", listOf(dateStatusAnyOf.toString()))
                }
                if (dateStatusGt != null) {
                    put("date_status.gt", listOf(dateStatusGt.toString()))
                }
                if (dateStatusGte != null) {
                    put("date_status.gte", listOf(dateStatusGte.toString()))
                }
                if (dateStatusLt != null) {
                    put("date_status.lt", listOf(dateStatusLt.toString()))
                }
                if (dateStatusLte != null) {
                    put("date_status.lte", listOf(dateStatusLte.toString()))
                }
                if (epsSurprisePercent != null) {
                    put("eps_surprise_percent", listOf(epsSurprisePercent.toString()))
                }
                if (epsSurprisePercentAnyOf != null) {
                    put("eps_surprise_percent.any_of", listOf(epsSurprisePercentAnyOf.toString()))
                }
                if (epsSurprisePercentGt != null) {
                    put("eps_surprise_percent.gt", listOf(epsSurprisePercentGt.toString()))
                }
                if (epsSurprisePercentGte != null) {
                    put("eps_surprise_percent.gte", listOf(epsSurprisePercentGte.toString()))
                }
                if (epsSurprisePercentLt != null) {
                    put("eps_surprise_percent.lt", listOf(epsSurprisePercentLt.toString()))
                }
                if (epsSurprisePercentLte != null) {
                    put("eps_surprise_percent.lte", listOf(epsSurprisePercentLte.toString()))
                }
                if (revenueSurprisePercent != null) {
                    put("revenue_surprise_percent", listOf(revenueSurprisePercent.toString()))
                }
                if (revenueSurprisePercentAnyOf != null) {
                    put("revenue_surprise_percent.any_of", listOf(revenueSurprisePercentAnyOf.toString()))
                }
                if (revenueSurprisePercentGt != null) {
                    put("revenue_surprise_percent.gt", listOf(revenueSurprisePercentGt.toString()))
                }
                if (revenueSurprisePercentGte != null) {
                    put("revenue_surprise_percent.gte", listOf(revenueSurprisePercentGte.toString()))
                }
                if (revenueSurprisePercentLt != null) {
                    put("revenue_surprise_percent.lt", listOf(revenueSurprisePercentLt.toString()))
                }
                if (revenueSurprisePercentLte != null) {
                    put("revenue_surprise_percent.lte", listOf(revenueSurprisePercentLte.toString()))
                }
                if (fiscalYear != null) {
                    put("fiscal_year", listOf(fiscalYear.toString()))
                }
                if (fiscalYearAnyOf != null) {
                    put("fiscal_year.any_of", listOf(fiscalYearAnyOf.toString()))
                }
                if (fiscalYearGt != null) {
                    put("fiscal_year.gt", listOf(fiscalYearGt.toString()))
                }
                if (fiscalYearGte != null) {
                    put("fiscal_year.gte", listOf(fiscalYearGte.toString()))
                }
                if (fiscalYearLt != null) {
                    put("fiscal_year.lt", listOf(fiscalYearLt.toString()))
                }
                if (fiscalYearLte != null) {
                    put("fiscal_year.lte", listOf(fiscalYearLte.toString()))
                }
                if (fiscalPeriod != null) {
                    put("fiscal_period", listOf(fiscalPeriod.toString()))
                }
                if (fiscalPeriodAnyOf != null) {
                    put("fiscal_period.any_of", listOf(fiscalPeriodAnyOf.toString()))
                }
                if (fiscalPeriodGt != null) {
                    put("fiscal_period.gt", listOf(fiscalPeriodGt.toString()))
                }
                if (fiscalPeriodGte != null) {
                    put("fiscal_period.gte", listOf(fiscalPeriodGte.toString()))
                }
                if (fiscalPeriodLt != null) {
                    put("fiscal_period.lt", listOf(fiscalPeriodLt.toString()))
                }
                if (fiscalPeriodLte != null) {
                    put("fiscal_period.lte", listOf(fiscalPeriodLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/earnings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/firms
     * 
     * A comprehensive database of financial firms, tracking unique identifiers, names, and basic metadata for various financial institutions and research firms.
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "name.asc")
     * @return GetBenzingaV1Firms200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1Firms(benzingaId: kotlin.String? = null, benzingaIdAnyOf: kotlin.String? = null, benzingaIdGt: kotlin.String? = null, benzingaIdGte: kotlin.String? = null, benzingaIdLt: kotlin.String? = null, benzingaIdLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "name.asc") : GetBenzingaV1Firms200Response {
        val localVarResponse = getBenzingaV1FirmsWithHttpInfo(benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1Firms200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/firms
     * 
     * A comprehensive database of financial firms, tracking unique identifiers, names, and basic metadata for various financial institutions and research firms.
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "name.asc")
     * @return ApiResponse<GetBenzingaV1Firms200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1FirmsWithHttpInfo(benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1Firms200Response?> {
        val localVariableConfig = getBenzingaV1FirmsRequestConfig(benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1Firms200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1Firms
     *
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;name&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "name.asc")
     * @return RequestConfig
     */
    fun getBenzingaV1FirmsRequestConfig(benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (benzingaId != null) {
                    put("benzinga_id", listOf(benzingaId.toString()))
                }
                if (benzingaIdAnyOf != null) {
                    put("benzinga_id.any_of", listOf(benzingaIdAnyOf.toString()))
                }
                if (benzingaIdGt != null) {
                    put("benzinga_id.gt", listOf(benzingaIdGt.toString()))
                }
                if (benzingaIdGte != null) {
                    put("benzinga_id.gte", listOf(benzingaIdGte.toString()))
                }
                if (benzingaIdLt != null) {
                    put("benzinga_id.lt", listOf(benzingaIdLt.toString()))
                }
                if (benzingaIdLte != null) {
                    put("benzinga_id.lte", listOf(benzingaIdLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/firms",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/guidance
     * 
     * A comprehensive database of financial guidance and earnings estimates for various companies, capturing key metrics related to earnings per share (EPS) and revenue projections across different fiscal periods.
     * @param date The calendar date (formatted as YYYY-MM-DD) when the guidance was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company issuing guidance. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param positioning Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are &#39;primary&#39; (the emphasized figure) and &#39;secondary&#39; (a supporting or alternate figure) (optional)
     * @param positioningAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param positioningGt Filter greater than the value. (optional)
     * @param positioningGte Filter greater than or equal to the value. (optional)
     * @param positioningLt Filter less than the value. (optional)
     * @param positioningLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param fiscalYear The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return GetBenzingaV1Guidance200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1Guidance(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, positioning: kotlin.String? = null, positioningAnyOf: kotlin.String? = null, positioningGt: kotlin.String? = null, positioningGte: kotlin.String? = null, positioningLt: kotlin.String? = null, positioningLte: kotlin.String? = null, importance: kotlin.Long? = null, importanceAnyOf: kotlin.String? = null, importanceGt: kotlin.Long? = null, importanceGte: kotlin.Long? = null, importanceLt: kotlin.Long? = null, importanceLte: kotlin.Long? = null, lastUpdated: kotlin.String? = null, lastUpdatedAnyOf: kotlin.String? = null, lastUpdatedGt: kotlin.String? = null, lastUpdatedGte: kotlin.String? = null, lastUpdatedLt: kotlin.String? = null, lastUpdatedLte: kotlin.String? = null, fiscalYear: kotlin.Long? = null, fiscalYearAnyOf: kotlin.String? = null, fiscalYearGt: kotlin.Long? = null, fiscalYearGte: kotlin.Long? = null, fiscalYearLt: kotlin.Long? = null, fiscalYearLte: kotlin.Long? = null, fiscalPeriod: kotlin.String? = null, fiscalPeriodAnyOf: kotlin.String? = null, fiscalPeriodGt: kotlin.String? = null, fiscalPeriodGte: kotlin.String? = null, fiscalPeriodLt: kotlin.String? = null, fiscalPeriodLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.desc") : GetBenzingaV1Guidance200Response {
        val localVarResponse = getBenzingaV1GuidanceWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, positioning = positioning, positioningAnyOf = positioningAnyOf, positioningGt = positioningGt, positioningGte = positioningGte, positioningLt = positioningLt, positioningLte = positioningLte, importance = importance, importanceAnyOf = importanceAnyOf, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, fiscalYear = fiscalYear, fiscalYearAnyOf = fiscalYearAnyOf, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalPeriod = fiscalPeriod, fiscalPeriodAnyOf = fiscalPeriodAnyOf, fiscalPeriodGt = fiscalPeriodGt, fiscalPeriodGte = fiscalPeriodGte, fiscalPeriodLt = fiscalPeriodLt, fiscalPeriodLte = fiscalPeriodLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1Guidance200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/guidance
     * 
     * A comprehensive database of financial guidance and earnings estimates for various companies, capturing key metrics related to earnings per share (EPS) and revenue projections across different fiscal periods.
     * @param date The calendar date (formatted as YYYY-MM-DD) when the guidance was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company issuing guidance. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param positioning Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are &#39;primary&#39; (the emphasized figure) and &#39;secondary&#39; (a supporting or alternate figure) (optional)
     * @param positioningAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param positioningGt Filter greater than the value. (optional)
     * @param positioningGte Filter greater than or equal to the value. (optional)
     * @param positioningLt Filter less than the value. (optional)
     * @param positioningLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param fiscalYear The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return ApiResponse<GetBenzingaV1Guidance200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1GuidanceWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, positioning: kotlin.String?, positioningAnyOf: kotlin.String?, positioningGt: kotlin.String?, positioningGte: kotlin.String?, positioningLt: kotlin.String?, positioningLte: kotlin.String?, importance: kotlin.Long?, importanceAnyOf: kotlin.String?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, fiscalYear: kotlin.Long?, fiscalYearAnyOf: kotlin.String?, fiscalYearGt: kotlin.Long?, fiscalYearGte: kotlin.Long?, fiscalYearLt: kotlin.Long?, fiscalYearLte: kotlin.Long?, fiscalPeriod: kotlin.String?, fiscalPeriodAnyOf: kotlin.String?, fiscalPeriodGt: kotlin.String?, fiscalPeriodGte: kotlin.String?, fiscalPeriodLt: kotlin.String?, fiscalPeriodLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1Guidance200Response?> {
        val localVariableConfig = getBenzingaV1GuidanceRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, positioning = positioning, positioningAnyOf = positioningAnyOf, positioningGt = positioningGt, positioningGte = positioningGte, positioningLt = positioningLt, positioningLte = positioningLte, importance = importance, importanceAnyOf = importanceAnyOf, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedAnyOf = lastUpdatedAnyOf, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, fiscalYear = fiscalYear, fiscalYearAnyOf = fiscalYearAnyOf, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalPeriod = fiscalPeriod, fiscalPeriodAnyOf = fiscalPeriodAnyOf, fiscalPeriodGt = fiscalPeriodGt, fiscalPeriodGte = fiscalPeriodGte, fiscalPeriodLt = fiscalPeriodLt, fiscalPeriodLte = fiscalPeriodLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1Guidance200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1Guidance
     *
     * @param date The calendar date (formatted as YYYY-MM-DD) when the guidance was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company issuing guidance. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param positioning Indicates how a particular guidance value is presented relative to other figures disclosed by the company. Possible values are &#39;primary&#39; (the emphasized figure) and &#39;secondary&#39; (a supporting or alternate figure) (optional)
     * @param positioningAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param positioningGt Filter greater than the value. (optional)
     * @param positioningGte Filter greater than or equal to the value. (optional)
     * @param positioningLt Filter less than the value. (optional)
     * @param positioningLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the record was last updated in the system. (optional)
     * @param lastUpdatedAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param lastUpdatedGt Filter greater than the value. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. (optional)
     * @param lastUpdatedLt Filter less than the value. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. (optional)
     * @param fiscalYear The fiscal year corresponding to the period for which the guidance is issued. Value must be an integer. (optional)
     * @param fiscalYearAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be an integer. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be an integer. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param fiscalPeriod The fiscal quarter to which the guidance applies, such as Q1, Q2, Q3, or Q4. (optional)
     * @param fiscalPeriodAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalPeriodGt Filter greater than the value. (optional)
     * @param fiscalPeriodGte Filter greater than or equal to the value. (optional)
     * @param fiscalPeriodLt Filter less than the value. (optional)
     * @param fiscalPeriodLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return RequestConfig
     */
    fun getBenzingaV1GuidanceRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, positioning: kotlin.String?, positioningAnyOf: kotlin.String?, positioningGt: kotlin.String?, positioningGte: kotlin.String?, positioningLt: kotlin.String?, positioningLte: kotlin.String?, importance: kotlin.Long?, importanceAnyOf: kotlin.String?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedAnyOf: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, fiscalYear: kotlin.Long?, fiscalYearAnyOf: kotlin.String?, fiscalYearGt: kotlin.Long?, fiscalYearGte: kotlin.Long?, fiscalYearLt: kotlin.Long?, fiscalYearLte: kotlin.Long?, fiscalPeriod: kotlin.String?, fiscalPeriodAnyOf: kotlin.String?, fiscalPeriodGt: kotlin.String?, fiscalPeriodGte: kotlin.String?, fiscalPeriodLt: kotlin.String?, fiscalPeriodLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (positioning != null) {
                    put("positioning", listOf(positioning.toString()))
                }
                if (positioningAnyOf != null) {
                    put("positioning.any_of", listOf(positioningAnyOf.toString()))
                }
                if (positioningGt != null) {
                    put("positioning.gt", listOf(positioningGt.toString()))
                }
                if (positioningGte != null) {
                    put("positioning.gte", listOf(positioningGte.toString()))
                }
                if (positioningLt != null) {
                    put("positioning.lt", listOf(positioningLt.toString()))
                }
                if (positioningLte != null) {
                    put("positioning.lte", listOf(positioningLte.toString()))
                }
                if (importance != null) {
                    put("importance", listOf(importance.toString()))
                }
                if (importanceAnyOf != null) {
                    put("importance.any_of", listOf(importanceAnyOf.toString()))
                }
                if (importanceGt != null) {
                    put("importance.gt", listOf(importanceGt.toString()))
                }
                if (importanceGte != null) {
                    put("importance.gte", listOf(importanceGte.toString()))
                }
                if (importanceLt != null) {
                    put("importance.lt", listOf(importanceLt.toString()))
                }
                if (importanceLte != null) {
                    put("importance.lte", listOf(importanceLte.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(lastUpdated.toString()))
                }
                if (lastUpdatedAnyOf != null) {
                    put("last_updated.any_of", listOf(lastUpdatedAnyOf.toString()))
                }
                if (lastUpdatedGt != null) {
                    put("last_updated.gt", listOf(lastUpdatedGt.toString()))
                }
                if (lastUpdatedGte != null) {
                    put("last_updated.gte", listOf(lastUpdatedGte.toString()))
                }
                if (lastUpdatedLt != null) {
                    put("last_updated.lt", listOf(lastUpdatedLt.toString()))
                }
                if (lastUpdatedLte != null) {
                    put("last_updated.lte", listOf(lastUpdatedLte.toString()))
                }
                if (fiscalYear != null) {
                    put("fiscal_year", listOf(fiscalYear.toString()))
                }
                if (fiscalYearAnyOf != null) {
                    put("fiscal_year.any_of", listOf(fiscalYearAnyOf.toString()))
                }
                if (fiscalYearGt != null) {
                    put("fiscal_year.gt", listOf(fiscalYearGt.toString()))
                }
                if (fiscalYearGte != null) {
                    put("fiscal_year.gte", listOf(fiscalYearGte.toString()))
                }
                if (fiscalYearLt != null) {
                    put("fiscal_year.lt", listOf(fiscalYearLt.toString()))
                }
                if (fiscalYearLte != null) {
                    put("fiscal_year.lte", listOf(fiscalYearLte.toString()))
                }
                if (fiscalPeriod != null) {
                    put("fiscal_period", listOf(fiscalPeriod.toString()))
                }
                if (fiscalPeriodAnyOf != null) {
                    put("fiscal_period.any_of", listOf(fiscalPeriodAnyOf.toString()))
                }
                if (fiscalPeriodGt != null) {
                    put("fiscal_period.gt", listOf(fiscalPeriodGt.toString()))
                }
                if (fiscalPeriodGte != null) {
                    put("fiscal_period.gte", listOf(fiscalPeriodGte.toString()))
                }
                if (fiscalPeriodLt != null) {
                    put("fiscal_period.lt", listOf(fiscalPeriodLt.toString()))
                }
                if (fiscalPeriodLte != null) {
                    put("fiscal_period.lte", listOf(fiscalPeriodLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/guidance",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v1/ratings
     * 
     * This table contains analyst ratings and price target data from investment firms, tracking rating changes (upgrades, downgrades, initiates coverage, etc.) and price target adjustments for publicly traded companies. Each record includes the analyst details, company information, current and previous ratings/targets, and metadata like timestamps and Benzinga identifiers.
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param ratingAction The description of the change in rating from the firm&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved. (optional)
     * @param ratingActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param ratingActionGt Filter greater than the value. (optional)
     * @param ratingActionGte Filter greater than or equal to the value. (optional)
     * @param ratingActionLt Filter less than the value. (optional)
     * @param ratingActionLte Filter less than or equal to the value. (optional)
     * @param priceTargetAction The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets. (optional)
     * @param priceTargetActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param priceTargetActionGt Filter greater than the value. (optional)
     * @param priceTargetActionGte Filter greater than or equal to the value. (optional)
     * @param priceTargetActionLt Filter less than the value. (optional)
     * @param priceTargetActionLte Filter less than or equal to the value. (optional)
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaAnalystId The identifer used by Benzinga for this analyst. (optional)
     * @param benzingaAnalystIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaAnalystIdGt Filter greater than the value. (optional)
     * @param benzingaAnalystIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaAnalystIdLt Filter less than the value. (optional)
     * @param benzingaAnalystIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The identifer used by Benzinga for this firm. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;last_updated&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "last_updated.desc")
     * @return GetBenzingaV1Ratings200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV1Ratings(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, importance: kotlin.Long? = null, importanceGt: kotlin.Long? = null, importanceGte: kotlin.Long? = null, importanceLt: kotlin.Long? = null, importanceLte: kotlin.Long? = null, lastUpdated: kotlin.String? = null, lastUpdatedGt: kotlin.String? = null, lastUpdatedGte: kotlin.String? = null, lastUpdatedLt: kotlin.String? = null, lastUpdatedLte: kotlin.String? = null, ratingAction: kotlin.String? = null, ratingActionAnyOf: kotlin.String? = null, ratingActionGt: kotlin.String? = null, ratingActionGte: kotlin.String? = null, ratingActionLt: kotlin.String? = null, ratingActionLte: kotlin.String? = null, priceTargetAction: kotlin.String? = null, priceTargetActionAnyOf: kotlin.String? = null, priceTargetActionGt: kotlin.String? = null, priceTargetActionGte: kotlin.String? = null, priceTargetActionLt: kotlin.String? = null, priceTargetActionLte: kotlin.String? = null, benzingaId: kotlin.String? = null, benzingaIdAnyOf: kotlin.String? = null, benzingaIdGt: kotlin.String? = null, benzingaIdGte: kotlin.String? = null, benzingaIdLt: kotlin.String? = null, benzingaIdLte: kotlin.String? = null, benzingaAnalystId: kotlin.String? = null, benzingaAnalystIdAnyOf: kotlin.String? = null, benzingaAnalystIdGt: kotlin.String? = null, benzingaAnalystIdGte: kotlin.String? = null, benzingaAnalystIdLt: kotlin.String? = null, benzingaAnalystIdLte: kotlin.String? = null, benzingaFirmId: kotlin.String? = null, benzingaFirmIdAnyOf: kotlin.String? = null, benzingaFirmIdGt: kotlin.String? = null, benzingaFirmIdGte: kotlin.String? = null, benzingaFirmIdLt: kotlin.String? = null, benzingaFirmIdLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "last_updated.desc") : GetBenzingaV1Ratings200Response {
        val localVarResponse = getBenzingaV1RatingsWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, importance = importance, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, ratingAction = ratingAction, ratingActionAnyOf = ratingActionAnyOf, ratingActionGt = ratingActionGt, ratingActionGte = ratingActionGte, ratingActionLt = ratingActionLt, ratingActionLte = ratingActionLte, priceTargetAction = priceTargetAction, priceTargetActionAnyOf = priceTargetActionAnyOf, priceTargetActionGt = priceTargetActionGt, priceTargetActionGte = priceTargetActionGte, priceTargetActionLt = priceTargetActionLt, priceTargetActionLte = priceTargetActionLte, benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, benzingaAnalystId = benzingaAnalystId, benzingaAnalystIdAnyOf = benzingaAnalystIdAnyOf, benzingaAnalystIdGt = benzingaAnalystIdGt, benzingaAnalystIdGte = benzingaAnalystIdGte, benzingaAnalystIdLt = benzingaAnalystIdLt, benzingaAnalystIdLte = benzingaAnalystIdLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV1Ratings200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v1/ratings
     * 
     * This table contains analyst ratings and price target data from investment firms, tracking rating changes (upgrades, downgrades, initiates coverage, etc.) and price target adjustments for publicly traded companies. Each record includes the analyst details, company information, current and previous ratings/targets, and metadata like timestamps and Benzinga identifiers.
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param ratingAction The description of the change in rating from the firm&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved. (optional)
     * @param ratingActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param ratingActionGt Filter greater than the value. (optional)
     * @param ratingActionGte Filter greater than or equal to the value. (optional)
     * @param ratingActionLt Filter less than the value. (optional)
     * @param ratingActionLte Filter less than or equal to the value. (optional)
     * @param priceTargetAction The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets. (optional)
     * @param priceTargetActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param priceTargetActionGt Filter greater than the value. (optional)
     * @param priceTargetActionGte Filter greater than or equal to the value. (optional)
     * @param priceTargetActionLt Filter less than the value. (optional)
     * @param priceTargetActionLte Filter less than or equal to the value. (optional)
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaAnalystId The identifer used by Benzinga for this analyst. (optional)
     * @param benzingaAnalystIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaAnalystIdGt Filter greater than the value. (optional)
     * @param benzingaAnalystIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaAnalystIdLt Filter less than the value. (optional)
     * @param benzingaAnalystIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The identifer used by Benzinga for this firm. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;last_updated&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "last_updated.desc")
     * @return ApiResponse<GetBenzingaV1Ratings200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV1RatingsWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, importance: kotlin.Long?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, ratingAction: kotlin.String?, ratingActionAnyOf: kotlin.String?, ratingActionGt: kotlin.String?, ratingActionGte: kotlin.String?, ratingActionLt: kotlin.String?, ratingActionLte: kotlin.String?, priceTargetAction: kotlin.String?, priceTargetActionAnyOf: kotlin.String?, priceTargetActionGt: kotlin.String?, priceTargetActionGte: kotlin.String?, priceTargetActionLt: kotlin.String?, priceTargetActionLte: kotlin.String?, benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, benzingaAnalystId: kotlin.String?, benzingaAnalystIdAnyOf: kotlin.String?, benzingaAnalystIdGt: kotlin.String?, benzingaAnalystIdGte: kotlin.String?, benzingaAnalystIdLt: kotlin.String?, benzingaAnalystIdLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV1Ratings200Response?> {
        val localVariableConfig = getBenzingaV1RatingsRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, importance = importance, importanceGt = importanceGt, importanceGte = importanceGte, importanceLt = importanceLt, importanceLte = importanceLte, lastUpdated = lastUpdated, lastUpdatedGt = lastUpdatedGt, lastUpdatedGte = lastUpdatedGte, lastUpdatedLt = lastUpdatedLt, lastUpdatedLte = lastUpdatedLte, ratingAction = ratingAction, ratingActionAnyOf = ratingActionAnyOf, ratingActionGt = ratingActionGt, ratingActionGte = ratingActionGte, ratingActionLt = ratingActionLt, ratingActionLte = ratingActionLte, priceTargetAction = priceTargetAction, priceTargetActionAnyOf = priceTargetActionAnyOf, priceTargetActionGt = priceTargetActionGt, priceTargetActionGte = priceTargetActionGte, priceTargetActionLt = priceTargetActionLt, priceTargetActionLte = priceTargetActionLte, benzingaId = benzingaId, benzingaIdAnyOf = benzingaIdAnyOf, benzingaIdGt = benzingaIdGt, benzingaIdGte = benzingaIdGte, benzingaIdLt = benzingaIdLt, benzingaIdLte = benzingaIdLte, benzingaAnalystId = benzingaAnalystId, benzingaAnalystIdAnyOf = benzingaAnalystIdAnyOf, benzingaAnalystIdGt = benzingaAnalystIdGt, benzingaAnalystIdGte = benzingaAnalystIdGte, benzingaAnalystIdLt = benzingaAnalystIdLt, benzingaAnalystIdLte = benzingaAnalystIdLte, benzingaFirmId = benzingaFirmId, benzingaFirmIdAnyOf = benzingaFirmIdAnyOf, benzingaFirmIdGt = benzingaFirmIdGt, benzingaFirmIdGte = benzingaFirmIdGte, benzingaFirmIdLt = benzingaFirmIdLt, benzingaFirmIdLte = benzingaFirmIdLte, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV1Ratings200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV1Ratings
     *
     * @param date The calendar date (formatted as YYYY-MM-DD) when the rating was issued. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param ticker The stock symbol of the company being rated. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param importance A subjective indicator of the importance of the earnings event, on a scale from 0 (lowest) to 5 (highest). Value must be an integer. (optional)
     * @param importanceGt Filter greater than the value. Value must be an integer. (optional)
     * @param importanceGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param importanceLt Filter less than the value. Value must be an integer. (optional)
     * @param importanceLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param lastUpdated The timestamp (formatted as an ISO 8601 timestamp) when the rating was last updated in the system. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastUpdatedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param ratingAction The description of the change in rating from the firm&#39;s last rating. Possible values include: downgrades, maintains, reinstates, reiterates, upgrades, assumes, initiates_coverage_on, terminates_coverage_on, removes, suspends, firm_dissolved. (optional)
     * @param ratingActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param ratingActionGt Filter greater than the value. (optional)
     * @param ratingActionGte Filter greater than or equal to the value. (optional)
     * @param ratingActionLt Filter less than the value. (optional)
     * @param ratingActionLte Filter less than or equal to the value. (optional)
     * @param priceTargetAction The description of the directional change in price target. Possible values include: raises, lowers, maintains, announces, sets. (optional)
     * @param priceTargetActionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param priceTargetActionGt Filter greater than the value. (optional)
     * @param priceTargetActionGte Filter greater than or equal to the value. (optional)
     * @param priceTargetActionLt Filter less than the value. (optional)
     * @param priceTargetActionLte Filter less than or equal to the value. (optional)
     * @param benzingaId The identifer used by Benzinga for this record. (optional)
     * @param benzingaIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaIdGt Filter greater than the value. (optional)
     * @param benzingaIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaIdLt Filter less than the value. (optional)
     * @param benzingaIdLte Filter less than or equal to the value. (optional)
     * @param benzingaAnalystId The identifer used by Benzinga for this analyst. (optional)
     * @param benzingaAnalystIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaAnalystIdGt Filter greater than the value. (optional)
     * @param benzingaAnalystIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaAnalystIdLt Filter less than the value. (optional)
     * @param benzingaAnalystIdLte Filter less than or equal to the value. (optional)
     * @param benzingaFirmId The identifer used by Benzinga for this firm. (optional)
     * @param benzingaFirmIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param benzingaFirmIdGt Filter greater than the value. (optional)
     * @param benzingaFirmIdGte Filter greater than or equal to the value. (optional)
     * @param benzingaFirmIdLt Filter less than the value. (optional)
     * @param benzingaFirmIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;last_updated&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "last_updated.desc")
     * @return RequestConfig
     */
    fun getBenzingaV1RatingsRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, importance: kotlin.Long?, importanceGt: kotlin.Long?, importanceGte: kotlin.Long?, importanceLt: kotlin.Long?, importanceLte: kotlin.Long?, lastUpdated: kotlin.String?, lastUpdatedGt: kotlin.String?, lastUpdatedGte: kotlin.String?, lastUpdatedLt: kotlin.String?, lastUpdatedLte: kotlin.String?, ratingAction: kotlin.String?, ratingActionAnyOf: kotlin.String?, ratingActionGt: kotlin.String?, ratingActionGte: kotlin.String?, ratingActionLt: kotlin.String?, ratingActionLte: kotlin.String?, priceTargetAction: kotlin.String?, priceTargetActionAnyOf: kotlin.String?, priceTargetActionGt: kotlin.String?, priceTargetActionGte: kotlin.String?, priceTargetActionLt: kotlin.String?, priceTargetActionLte: kotlin.String?, benzingaId: kotlin.String?, benzingaIdAnyOf: kotlin.String?, benzingaIdGt: kotlin.String?, benzingaIdGte: kotlin.String?, benzingaIdLt: kotlin.String?, benzingaIdLte: kotlin.String?, benzingaAnalystId: kotlin.String?, benzingaAnalystIdAnyOf: kotlin.String?, benzingaAnalystIdGt: kotlin.String?, benzingaAnalystIdGte: kotlin.String?, benzingaAnalystIdLt: kotlin.String?, benzingaAnalystIdLte: kotlin.String?, benzingaFirmId: kotlin.String?, benzingaFirmIdAnyOf: kotlin.String?, benzingaFirmIdGt: kotlin.String?, benzingaFirmIdGte: kotlin.String?, benzingaFirmIdLt: kotlin.String?, benzingaFirmIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (importance != null) {
                    put("importance", listOf(importance.toString()))
                }
                if (importanceGt != null) {
                    put("importance.gt", listOf(importanceGt.toString()))
                }
                if (importanceGte != null) {
                    put("importance.gte", listOf(importanceGte.toString()))
                }
                if (importanceLt != null) {
                    put("importance.lt", listOf(importanceLt.toString()))
                }
                if (importanceLte != null) {
                    put("importance.lte", listOf(importanceLte.toString()))
                }
                if (lastUpdated != null) {
                    put("last_updated", listOf(lastUpdated.toString()))
                }
                if (lastUpdatedGt != null) {
                    put("last_updated.gt", listOf(lastUpdatedGt.toString()))
                }
                if (lastUpdatedGte != null) {
                    put("last_updated.gte", listOf(lastUpdatedGte.toString()))
                }
                if (lastUpdatedLt != null) {
                    put("last_updated.lt", listOf(lastUpdatedLt.toString()))
                }
                if (lastUpdatedLte != null) {
                    put("last_updated.lte", listOf(lastUpdatedLte.toString()))
                }
                if (ratingAction != null) {
                    put("rating_action", listOf(ratingAction.toString()))
                }
                if (ratingActionAnyOf != null) {
                    put("rating_action.any_of", listOf(ratingActionAnyOf.toString()))
                }
                if (ratingActionGt != null) {
                    put("rating_action.gt", listOf(ratingActionGt.toString()))
                }
                if (ratingActionGte != null) {
                    put("rating_action.gte", listOf(ratingActionGte.toString()))
                }
                if (ratingActionLt != null) {
                    put("rating_action.lt", listOf(ratingActionLt.toString()))
                }
                if (ratingActionLte != null) {
                    put("rating_action.lte", listOf(ratingActionLte.toString()))
                }
                if (priceTargetAction != null) {
                    put("price_target_action", listOf(priceTargetAction.toString()))
                }
                if (priceTargetActionAnyOf != null) {
                    put("price_target_action.any_of", listOf(priceTargetActionAnyOf.toString()))
                }
                if (priceTargetActionGt != null) {
                    put("price_target_action.gt", listOf(priceTargetActionGt.toString()))
                }
                if (priceTargetActionGte != null) {
                    put("price_target_action.gte", listOf(priceTargetActionGte.toString()))
                }
                if (priceTargetActionLt != null) {
                    put("price_target_action.lt", listOf(priceTargetActionLt.toString()))
                }
                if (priceTargetActionLte != null) {
                    put("price_target_action.lte", listOf(priceTargetActionLte.toString()))
                }
                if (benzingaId != null) {
                    put("benzinga_id", listOf(benzingaId.toString()))
                }
                if (benzingaIdAnyOf != null) {
                    put("benzinga_id.any_of", listOf(benzingaIdAnyOf.toString()))
                }
                if (benzingaIdGt != null) {
                    put("benzinga_id.gt", listOf(benzingaIdGt.toString()))
                }
                if (benzingaIdGte != null) {
                    put("benzinga_id.gte", listOf(benzingaIdGte.toString()))
                }
                if (benzingaIdLt != null) {
                    put("benzinga_id.lt", listOf(benzingaIdLt.toString()))
                }
                if (benzingaIdLte != null) {
                    put("benzinga_id.lte", listOf(benzingaIdLte.toString()))
                }
                if (benzingaAnalystId != null) {
                    put("benzinga_analyst_id", listOf(benzingaAnalystId.toString()))
                }
                if (benzingaAnalystIdAnyOf != null) {
                    put("benzinga_analyst_id.any_of", listOf(benzingaAnalystIdAnyOf.toString()))
                }
                if (benzingaAnalystIdGt != null) {
                    put("benzinga_analyst_id.gt", listOf(benzingaAnalystIdGt.toString()))
                }
                if (benzingaAnalystIdGte != null) {
                    put("benzinga_analyst_id.gte", listOf(benzingaAnalystIdGte.toString()))
                }
                if (benzingaAnalystIdLt != null) {
                    put("benzinga_analyst_id.lt", listOf(benzingaAnalystIdLt.toString()))
                }
                if (benzingaAnalystIdLte != null) {
                    put("benzinga_analyst_id.lte", listOf(benzingaAnalystIdLte.toString()))
                }
                if (benzingaFirmId != null) {
                    put("benzinga_firm_id", listOf(benzingaFirmId.toString()))
                }
                if (benzingaFirmIdAnyOf != null) {
                    put("benzinga_firm_id.any_of", listOf(benzingaFirmIdAnyOf.toString()))
                }
                if (benzingaFirmIdGt != null) {
                    put("benzinga_firm_id.gt", listOf(benzingaFirmIdGt.toString()))
                }
                if (benzingaFirmIdGte != null) {
                    put("benzinga_firm_id.gte", listOf(benzingaFirmIdGte.toString()))
                }
                if (benzingaFirmIdLt != null) {
                    put("benzinga_firm_id.lt", listOf(benzingaFirmIdLt.toString()))
                }
                if (benzingaFirmIdLte != null) {
                    put("benzinga_firm_id.lte", listOf(benzingaFirmIdLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v1/ratings",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /benzinga/v2/news
     * 
     * A comprehensive news article database from Benzinga, containing detailed information about financial news articles including metadata, content, and associated financial information.
     * @param published The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param channels Filter for arrays that contain the value. (optional)
     * @param channelsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param channelsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tags Filter for arrays that contain the value. (optional)
     * @param tagsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tagsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param author The name of the journalist or entity that authored the news article. (optional)
     * @param authorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param authorGt Filter greater than the value. (optional)
     * @param authorGte Filter greater than or equal to the value. (optional)
     * @param authorLt Filter less than the value. (optional)
     * @param authorLte Filter less than or equal to the value. (optional)
     * @param stocks Filter for arrays that contain the value. (optional)
     * @param stocksAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param stocksAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;published&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "published.desc")
     * @return GetBenzingaV2News200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getBenzingaV2News(published: kotlin.String? = null, publishedGt: kotlin.String? = null, publishedGte: kotlin.String? = null, publishedLt: kotlin.String? = null, publishedLte: kotlin.String? = null, channels: kotlin.String? = null, channelsAllOf: kotlin.String? = null, channelsAnyOf: kotlin.String? = null, tags: kotlin.String? = null, tagsAllOf: kotlin.String? = null, tagsAnyOf: kotlin.String? = null, author: kotlin.String? = null, authorAnyOf: kotlin.String? = null, authorGt: kotlin.String? = null, authorGte: kotlin.String? = null, authorLt: kotlin.String? = null, authorLte: kotlin.String? = null, stocks: kotlin.String? = null, stocksAllOf: kotlin.String? = null, stocksAnyOf: kotlin.String? = null, tickers: kotlin.String? = null, tickersAllOf: kotlin.String? = null, tickersAnyOf: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "published.desc") : GetBenzingaV2News200Response {
        val localVarResponse = getBenzingaV2NewsWithHttpInfo(published = published, publishedGt = publishedGt, publishedGte = publishedGte, publishedLt = publishedLt, publishedLte = publishedLte, channels = channels, channelsAllOf = channelsAllOf, channelsAnyOf = channelsAnyOf, tags = tags, tagsAllOf = tagsAllOf, tagsAnyOf = tagsAnyOf, author = author, authorAnyOf = authorAnyOf, authorGt = authorGt, authorGte = authorGte, authorLt = authorLt, authorLte = authorLte, stocks = stocks, stocksAllOf = stocksAllOf, stocksAnyOf = stocksAnyOf, tickers = tickers, tickersAllOf = tickersAllOf, tickersAnyOf = tickersAnyOf, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetBenzingaV2News200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /benzinga/v2/news
     * 
     * A comprehensive news article database from Benzinga, containing detailed information about financial news articles including metadata, content, and associated financial information.
     * @param published The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param channels Filter for arrays that contain the value. (optional)
     * @param channelsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param channelsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tags Filter for arrays that contain the value. (optional)
     * @param tagsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tagsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param author The name of the journalist or entity that authored the news article. (optional)
     * @param authorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param authorGt Filter greater than the value. (optional)
     * @param authorGte Filter greater than or equal to the value. (optional)
     * @param authorLt Filter less than the value. (optional)
     * @param authorLte Filter less than or equal to the value. (optional)
     * @param stocks Filter for arrays that contain the value. (optional)
     * @param stocksAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param stocksAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;published&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "published.desc")
     * @return ApiResponse<GetBenzingaV2News200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getBenzingaV2NewsWithHttpInfo(published: kotlin.String?, publishedGt: kotlin.String?, publishedGte: kotlin.String?, publishedLt: kotlin.String?, publishedLte: kotlin.String?, channels: kotlin.String?, channelsAllOf: kotlin.String?, channelsAnyOf: kotlin.String?, tags: kotlin.String?, tagsAllOf: kotlin.String?, tagsAnyOf: kotlin.String?, author: kotlin.String?, authorAnyOf: kotlin.String?, authorGt: kotlin.String?, authorGte: kotlin.String?, authorLt: kotlin.String?, authorLte: kotlin.String?, stocks: kotlin.String?, stocksAllOf: kotlin.String?, stocksAnyOf: kotlin.String?, tickers: kotlin.String?, tickersAllOf: kotlin.String?, tickersAnyOf: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetBenzingaV2News200Response?> {
        val localVariableConfig = getBenzingaV2NewsRequestConfig(published = published, publishedGt = publishedGt, publishedGte = publishedGte, publishedLt = publishedLt, publishedLte = publishedLte, channels = channels, channelsAllOf = channelsAllOf, channelsAnyOf = channelsAnyOf, tags = tags, tagsAllOf = tagsAllOf, tagsAnyOf = tagsAnyOf, author = author, authorAnyOf = authorAnyOf, authorGt = authorGt, authorGte = authorGte, authorLt = authorLt, authorLte = authorLte, stocks = stocks, stocksAllOf = stocksAllOf, stocksAnyOf = stocksAnyOf, tickers = tickers, tickersAllOf = tickersAllOf, tickersAnyOf = tickersAnyOf, limit = limit, sort = sort)

        return request<Unit, GetBenzingaV2News200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getBenzingaV2News
     *
     * @param published The timestamp (formatted as an ISO 8601 timestamp) when the news article was originally published. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedGt Filter greater than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedGte Filter greater than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedLt Filter less than the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param publishedLte Filter less than or equal to the value. Value must be an integer timestamp in seconds or formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param channels Filter for arrays that contain the value. (optional)
     * @param channelsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param channelsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tags Filter for arrays that contain the value. (optional)
     * @param tagsAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tagsAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param author The name of the journalist or entity that authored the news article. (optional)
     * @param authorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param authorGt Filter greater than the value. (optional)
     * @param authorGte Filter greater than or equal to the value. (optional)
     * @param authorLt Filter less than the value. (optional)
     * @param authorLte Filter less than or equal to the value. (optional)
     * @param stocks Filter for arrays that contain the value. (optional)
     * @param stocksAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param stocksAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;published&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "published.desc")
     * @return RequestConfig
     */
    fun getBenzingaV2NewsRequestConfig(published: kotlin.String?, publishedGt: kotlin.String?, publishedGte: kotlin.String?, publishedLt: kotlin.String?, publishedLte: kotlin.String?, channels: kotlin.String?, channelsAllOf: kotlin.String?, channelsAnyOf: kotlin.String?, tags: kotlin.String?, tagsAllOf: kotlin.String?, tagsAnyOf: kotlin.String?, author: kotlin.String?, authorAnyOf: kotlin.String?, authorGt: kotlin.String?, authorGte: kotlin.String?, authorLt: kotlin.String?, authorLte: kotlin.String?, stocks: kotlin.String?, stocksAllOf: kotlin.String?, stocksAnyOf: kotlin.String?, tickers: kotlin.String?, tickersAllOf: kotlin.String?, tickersAnyOf: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (published != null) {
                    put("published", listOf(published.toString()))
                }
                if (publishedGt != null) {
                    put("published.gt", listOf(publishedGt.toString()))
                }
                if (publishedGte != null) {
                    put("published.gte", listOf(publishedGte.toString()))
                }
                if (publishedLt != null) {
                    put("published.lt", listOf(publishedLt.toString()))
                }
                if (publishedLte != null) {
                    put("published.lte", listOf(publishedLte.toString()))
                }
                if (channels != null) {
                    put("channels", listOf(channels.toString()))
                }
                if (channelsAllOf != null) {
                    put("channels.all_of", listOf(channelsAllOf.toString()))
                }
                if (channelsAnyOf != null) {
                    put("channels.any_of", listOf(channelsAnyOf.toString()))
                }
                if (tags != null) {
                    put("tags", listOf(tags.toString()))
                }
                if (tagsAllOf != null) {
                    put("tags.all_of", listOf(tagsAllOf.toString()))
                }
                if (tagsAnyOf != null) {
                    put("tags.any_of", listOf(tagsAnyOf.toString()))
                }
                if (author != null) {
                    put("author", listOf(author.toString()))
                }
                if (authorAnyOf != null) {
                    put("author.any_of", listOf(authorAnyOf.toString()))
                }
                if (authorGt != null) {
                    put("author.gt", listOf(authorGt.toString()))
                }
                if (authorGte != null) {
                    put("author.gte", listOf(authorGte.toString()))
                }
                if (authorLt != null) {
                    put("author.lt", listOf(authorLt.toString()))
                }
                if (authorLte != null) {
                    put("author.lte", listOf(authorLte.toString()))
                }
                if (stocks != null) {
                    put("stocks", listOf(stocks.toString()))
                }
                if (stocksAllOf != null) {
                    put("stocks.all_of", listOf(stocksAllOf.toString()))
                }
                if (stocksAnyOf != null) {
                    put("stocks.any_of", listOf(stocksAnyOf.toString()))
                }
                if (tickers != null) {
                    put("tickers", listOf(tickers.toString()))
                }
                if (tickersAllOf != null) {
                    put("tickers.all_of", listOf(tickersAllOf.toString()))
                }
                if (tickersAnyOf != null) {
                    put("tickers.any_of", listOf(tickersAnyOf.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/benzinga/v2/news",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetCryptoAggregates(val value: kotlin.String) {
         @Json(name = "second") second("second"),
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetCryptoAggregates(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/aggs/ticker/{cryptoTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; minute and multiplier &#x3D; 5 then 5-minute bars will be returned. 
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return GetCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoAggregates(cryptoTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetCryptoAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean? = null, sort: SortGetCryptoAggregates? = null, limit: kotlin.Int? = null) : GetCryptoAggregates200Response {
        val localVarResponse = getCryptoAggregatesWithHttpInfo(cryptoTicker = cryptoTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{cryptoTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a cryptocurrency pair over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; minute and multiplier &#x3D; 5 then 5-minute bars will be returned. 
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return ApiResponse<GetCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoAggregatesWithHttpInfo(cryptoTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetCryptoAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetCryptoAggregates?, limit: kotlin.Int?) : ApiResponse<GetCryptoAggregates200Response?> {
        val localVariableConfig = getCryptoAggregatesRequestConfig(cryptoTicker = cryptoTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return request<Unit, GetCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoAggregates
     *
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return RequestConfig
     */
    fun getCryptoAggregatesRequestConfig(cryptoTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetCryptoAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetCryptoAggregates?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{cryptoTicker}/range/{multiplier}/{timespan}/{from}/{to}".replace("{"+"cryptoTicker"+"}", encodeURIComponent(cryptoTicker.toString())).replace("{"+"multiplier"+"}", encodeURIComponent(multiplier.toString())).replace("{"+"timespan"+"}", encodeURIComponent(timespan.value.toString())).replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/open-close/crypto/{from}/{to}/{date}
     * Daily Open/Close
     * Get the open, close prices of a cryptocurrency symbol on a certain day. 
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetCryptoOpenClose200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoOpenClose(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean? = null) : GetCryptoOpenClose200Response {
        val localVarResponse = getCryptoOpenCloseWithHttpInfo(from = from, to = to, date = date, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoOpenClose200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/open-close/crypto/{from}/{to}/{date}
     * Daily Open/Close
     * Get the open, close prices of a cryptocurrency symbol on a certain day. 
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetCryptoOpenClose200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoOpenCloseWithHttpInfo(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : ApiResponse<GetCryptoOpenClose200Response?> {
        val localVariableConfig = getCryptoOpenCloseRequestConfig(from = from, to = to, date = date, adjusted = adjusted)

        return request<Unit, GetCryptoOpenClose200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoOpenClose
     *
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getCryptoOpenCloseRequestConfig(from: kotlin.String, to: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/open-close/crypto/{from}/{to}/{date}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter direction
     */
     enum class DirectionGetCryptoSnapshotDirection(val value: kotlin.String) {
         @Json(name = "gainers") gainers("gainers"),
         @Json(name = "losers") losers("losers");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/{direction}
     * Gainers/Losers
     * Get the current top 20 gainers or losers of the day in cryptocurrency markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @return GetCryptoSnapshotDirection200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoSnapshotDirection(direction: DirectionGetCryptoSnapshotDirection) : GetCryptoSnapshotDirection200Response {
        val localVarResponse = getCryptoSnapshotDirectionWithHttpInfo(direction = direction)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoSnapshotDirection200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/{direction}
     * Gainers/Losers
     * Get the current top 20 gainers or losers of the day in cryptocurrency markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @return ApiResponse<GetCryptoSnapshotDirection200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoSnapshotDirectionWithHttpInfo(direction: DirectionGetCryptoSnapshotDirection) : ApiResponse<GetCryptoSnapshotDirection200Response?> {
        val localVariableConfig = getCryptoSnapshotDirectionRequestConfig(direction = direction)

        return request<Unit, GetCryptoSnapshotDirection200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoSnapshotDirection
     *
     * @param direction The direction of the snapshot results to return. 
     * @return RequestConfig
     */
    fun getCryptoSnapshotDirectionRequestConfig(direction: DirectionGetCryptoSnapshotDirection) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/crypto/{direction}".replace("{"+"direction"+"}", encodeURIComponent(direction.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers/{ticker}
     * Ticker
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker Ticker of the snapshot
     * @return GetCryptoSnapshotTicker200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoSnapshotTicker(ticker: kotlin.String) : GetCryptoSnapshotTicker200Response {
        val localVarResponse = getCryptoSnapshotTickerWithHttpInfo(ticker = ticker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoSnapshotTicker200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers/{ticker}
     * Ticker
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded cryptocurrency symbol. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker Ticker of the snapshot
     * @return ApiResponse<GetCryptoSnapshotTicker200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoSnapshotTickerWithHttpInfo(ticker: kotlin.String) : ApiResponse<GetCryptoSnapshotTicker200Response?> {
        val localVariableConfig = getCryptoSnapshotTickerRequestConfig(ticker = ticker)

        return request<Unit, GetCryptoSnapshotTicker200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoSnapshotTicker
     *
     * @param ticker Ticker of the snapshot
     * @return RequestConfig
     */
    fun getCryptoSnapshotTickerRequestConfig(ticker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/crypto/tickers/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers
     * All Tickers
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers. (optional)
     * @return GetCryptoSnapshotTickers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoSnapshotTickers(tickers: kotlin.collections.List<kotlin.String>? = null) : GetCryptoSnapshotTickers200Response {
        val localVarResponse = getCryptoSnapshotTickersWithHttpInfo(tickers = tickers)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoSnapshotTickers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/crypto/tickers
     * All Tickers
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded cryptocurrency symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers. (optional)
     * @return ApiResponse<GetCryptoSnapshotTickers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoSnapshotTickersWithHttpInfo(tickers: kotlin.collections.List<kotlin.String>?) : ApiResponse<GetCryptoSnapshotTickers200Response?> {
        val localVariableConfig = getCryptoSnapshotTickersRequestConfig(tickers = tickers)

        return request<Unit, GetCryptoSnapshotTickers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoSnapshotTickers
     *
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, X:BTCUSD, X:ETHBTC, and X:BOBAUSD. Empty string defaults to querying all tickers. (optional)
     * @return RequestConfig
     */
    fun getCryptoSnapshotTickersRequestConfig(tickers: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tickers != null) {
                    put("tickers", toMultiValue(tickers.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/crypto/tickers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /crypto/v1/exchanges
     * 
     * Global cryptocurrency exchanges and digital asset trading platforms, including major centralized exchanges (Coinbase, Binance, Bitfinex, etc.) that facilitate trading of cryptocurrencies and digital tokens worldwide.
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return GetCryptoV1Exchanges200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCryptoV1Exchanges(limit: kotlin.Int? = 100) : GetCryptoV1Exchanges200Response {
        val localVarResponse = getCryptoV1ExchangesWithHttpInfo(limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoV1Exchanges200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /crypto/v1/exchanges
     * 
     * Global cryptocurrency exchanges and digital asset trading platforms, including major centralized exchanges (Coinbase, Binance, Bitfinex, etc.) that facilitate trading of cryptocurrencies and digital tokens worldwide.
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return ApiResponse<GetCryptoV1Exchanges200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCryptoV1ExchangesWithHttpInfo(limit: kotlin.Int?) : ApiResponse<GetCryptoV1Exchanges200Response?> {
        val localVariableConfig = getCryptoV1ExchangesRequestConfig(limit = limit)

        return request<Unit, GetCryptoV1Exchanges200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCryptoV1Exchanges
     *
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return RequestConfig
     */
    fun getCryptoV1ExchangesRequestConfig(limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/crypto/v1/exchanges",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter precision
     */
     enum class PrecisionGetCurrencyConversion(val value: kotlin.Int) {
         @Json(name = "0") _0(0),
         @Json(name = "1") _1(1),
         @Json(name = "2") _2(2),
         @Json(name = "3") _3(3),
         @Json(name = "4") _4(4);

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/conversion/{from}/{to}
     * Real-time Currency Conversion
     * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param amount The amount to convert, with a decimal. (optional, default to 1)
     * @param precision The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy. (optional, default to 2)
     * @return GetCurrencyConversion200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getCurrencyConversion(from: kotlin.String, to: kotlin.String, amount: java.math.BigDecimal? = java.math.BigDecimal("1"), precision: PrecisionGetCurrencyConversion? = PrecisionGetCurrencyConversion._2) : GetCurrencyConversion200Response {
        val localVarResponse = getCurrencyConversionWithHttpInfo(from = from, to = to, amount = amount, precision = precision)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCurrencyConversion200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/conversion/{from}/{to}
     * Real-time Currency Conversion
     * Get currency conversions using the latest market conversion rates. Note than you can convert in both directions. For example USD to CAD or CAD to USD.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param amount The amount to convert, with a decimal. (optional, default to 1)
     * @param precision The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy. (optional, default to 2)
     * @return ApiResponse<GetCurrencyConversion200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getCurrencyConversionWithHttpInfo(from: kotlin.String, to: kotlin.String, amount: java.math.BigDecimal?, precision: PrecisionGetCurrencyConversion?) : ApiResponse<GetCurrencyConversion200Response?> {
        val localVariableConfig = getCurrencyConversionRequestConfig(from = from, to = to, amount = amount, precision = precision)

        return request<Unit, GetCurrencyConversion200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getCurrencyConversion
     *
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @param amount The amount to convert, with a decimal. (optional, default to 1)
     * @param precision The decimal precision of the conversion. Defaults to 2 which is 2 decimal places accuracy. (optional, default to 2)
     * @return RequestConfig
     */
    fun getCurrencyConversionRequestConfig(from: kotlin.String, to: kotlin.String, amount: java.math.BigDecimal?, precision: PrecisionGetCurrencyConversion?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (amount != null) {
                    put("amount", listOf(amount.toString()))
                }
                if (precision != null) {
                    put("precision", listOf(precision.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/conversion/{from}/{to}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /etf-global/v1/analytics
     * 
     * ETF Global analytics data containing risk scores, reward metrics, and quantitative analysis for ETF composite tickers.
     * @param compositeTicker The stock ticker symbol used to identify this ETF product on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param riskTotalScore ETF Global&#39;s proprietary Red Diamond overall risk assessment score for the ETF. Value must be a floating point number. (optional)
     * @param riskTotalScoreGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param riskTotalScoreGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param riskTotalScoreLt Filter less than the value. Value must be a floating point number. (optional)
     * @param riskTotalScoreLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param rewardScore ETF Global&#39;s proprietary Green Diamond score measuring the potential reward and return prospects of the ETF. Value must be a floating point number. (optional)
     * @param rewardScoreGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param rewardScoreGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param rewardScoreLt Filter less than the value. Value must be a floating point number. (optional)
     * @param rewardScoreLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantTotalScore ETF Global&#39;s comprehensive quantitative analysis score combining all quantitative factors. Value must be a floating point number. (optional)
     * @param quantTotalScoreGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantTotalScoreGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantTotalScoreLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantTotalScoreLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantGrade Letter grade summarizing the ETF&#39;s overall quantitative assessment, where A &#x3D; 71-100, B &#x3D; 56-70, etc. (optional)
     * @param quantGradeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param quantGradeGt Filter greater than the value. (optional)
     * @param quantGradeGte Filter greater than or equal to the value. (optional)
     * @param quantGradeLt Filter less than the value. (optional)
     * @param quantGradeLte Filter less than or equal to the value. (optional)
     * @param quantCompositeTechnical Combined technical analysis score aggregating short, intermediate, and long-term technical factors. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentiment Overall market sentiment score combining put/call ratios, short interest, and implied volatility. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioral Behavioral analysis score measuring investor psychology and market behavior patterns. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamental Overall fundamental analysis score combining P/E, P/CF, P/B, and dividend yield metrics. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobal Overall global theme score combining sector and country analysis for macro investment views. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeQuality Overall quality assessment score combining liquidity, diversification, and issuing firm factors. Value must be a floating point number. (optional)
     * @param quantCompositeQualityGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeQualityGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeQualityLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeQualityLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return GetEtfGlobalV1Analytics200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEtfGlobalV1Analytics(compositeTicker: kotlin.String? = null, compositeTickerAnyOf: kotlin.String? = null, compositeTickerGt: kotlin.String? = null, compositeTickerGte: kotlin.String? = null, compositeTickerLt: kotlin.String? = null, compositeTickerLte: kotlin.String? = null, processedDate: kotlin.String? = null, processedDateGt: kotlin.String? = null, processedDateGte: kotlin.String? = null, processedDateLt: kotlin.String? = null, processedDateLte: kotlin.String? = null, effectiveDate: kotlin.String? = null, effectiveDateGt: kotlin.String? = null, effectiveDateGte: kotlin.String? = null, effectiveDateLt: kotlin.String? = null, effectiveDateLte: kotlin.String? = null, riskTotalScore: kotlin.Double? = null, riskTotalScoreGt: kotlin.Double? = null, riskTotalScoreGte: kotlin.Double? = null, riskTotalScoreLt: kotlin.Double? = null, riskTotalScoreLte: kotlin.Double? = null, rewardScore: kotlin.Double? = null, rewardScoreGt: kotlin.Double? = null, rewardScoreGte: kotlin.Double? = null, rewardScoreLt: kotlin.Double? = null, rewardScoreLte: kotlin.Double? = null, quantTotalScore: kotlin.Double? = null, quantTotalScoreGt: kotlin.Double? = null, quantTotalScoreGte: kotlin.Double? = null, quantTotalScoreLt: kotlin.Double? = null, quantTotalScoreLte: kotlin.Double? = null, quantGrade: kotlin.String? = null, quantGradeAnyOf: kotlin.String? = null, quantGradeGt: kotlin.String? = null, quantGradeGte: kotlin.String? = null, quantGradeLt: kotlin.String? = null, quantGradeLte: kotlin.String? = null, quantCompositeTechnical: kotlin.Double? = null, quantCompositeTechnicalGt: kotlin.Double? = null, quantCompositeTechnicalGte: kotlin.Double? = null, quantCompositeTechnicalLt: kotlin.Double? = null, quantCompositeTechnicalLte: kotlin.Double? = null, quantCompositeSentiment: kotlin.Double? = null, quantCompositeSentimentGt: kotlin.Double? = null, quantCompositeSentimentGte: kotlin.Double? = null, quantCompositeSentimentLt: kotlin.Double? = null, quantCompositeSentimentLte: kotlin.Double? = null, quantCompositeBehavioral: kotlin.Double? = null, quantCompositeBehavioralGt: kotlin.Double? = null, quantCompositeBehavioralGte: kotlin.Double? = null, quantCompositeBehavioralLt: kotlin.Double? = null, quantCompositeBehavioralLte: kotlin.Double? = null, quantCompositeFundamental: kotlin.Double? = null, quantCompositeFundamentalGt: kotlin.Double? = null, quantCompositeFundamentalGte: kotlin.Double? = null, quantCompositeFundamentalLt: kotlin.Double? = null, quantCompositeFundamentalLte: kotlin.Double? = null, quantCompositeGlobal: kotlin.Double? = null, quantCompositeGlobalGt: kotlin.Double? = null, quantCompositeGlobalGte: kotlin.Double? = null, quantCompositeGlobalLt: kotlin.Double? = null, quantCompositeGlobalLte: kotlin.Double? = null, quantCompositeQuality: kotlin.Double? = null, quantCompositeQualityGt: kotlin.Double? = null, quantCompositeQualityGte: kotlin.Double? = null, quantCompositeQualityLt: kotlin.Double? = null, quantCompositeQualityLte: kotlin.Double? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "composite_ticker.asc") : GetEtfGlobalV1Analytics200Response {
        val localVarResponse = getEtfGlobalV1AnalyticsWithHttpInfo(compositeTicker = compositeTicker, compositeTickerAnyOf = compositeTickerAnyOf, compositeTickerGt = compositeTickerGt, compositeTickerGte = compositeTickerGte, compositeTickerLt = compositeTickerLt, compositeTickerLte = compositeTickerLte, processedDate = processedDate, processedDateGt = processedDateGt, processedDateGte = processedDateGte, processedDateLt = processedDateLt, processedDateLte = processedDateLte, effectiveDate = effectiveDate, effectiveDateGt = effectiveDateGt, effectiveDateGte = effectiveDateGte, effectiveDateLt = effectiveDateLt, effectiveDateLte = effectiveDateLte, riskTotalScore = riskTotalScore, riskTotalScoreGt = riskTotalScoreGt, riskTotalScoreGte = riskTotalScoreGte, riskTotalScoreLt = riskTotalScoreLt, riskTotalScoreLte = riskTotalScoreLte, rewardScore = rewardScore, rewardScoreGt = rewardScoreGt, rewardScoreGte = rewardScoreGte, rewardScoreLt = rewardScoreLt, rewardScoreLte = rewardScoreLte, quantTotalScore = quantTotalScore, quantTotalScoreGt = quantTotalScoreGt, quantTotalScoreGte = quantTotalScoreGte, quantTotalScoreLt = quantTotalScoreLt, quantTotalScoreLte = quantTotalScoreLte, quantGrade = quantGrade, quantGradeAnyOf = quantGradeAnyOf, quantGradeGt = quantGradeGt, quantGradeGte = quantGradeGte, quantGradeLt = quantGradeLt, quantGradeLte = quantGradeLte, quantCompositeTechnical = quantCompositeTechnical, quantCompositeTechnicalGt = quantCompositeTechnicalGt, quantCompositeTechnicalGte = quantCompositeTechnicalGte, quantCompositeTechnicalLt = quantCompositeTechnicalLt, quantCompositeTechnicalLte = quantCompositeTechnicalLte, quantCompositeSentiment = quantCompositeSentiment, quantCompositeSentimentGt = quantCompositeSentimentGt, quantCompositeSentimentGte = quantCompositeSentimentGte, quantCompositeSentimentLt = quantCompositeSentimentLt, quantCompositeSentimentLte = quantCompositeSentimentLte, quantCompositeBehavioral = quantCompositeBehavioral, quantCompositeBehavioralGt = quantCompositeBehavioralGt, quantCompositeBehavioralGte = quantCompositeBehavioralGte, quantCompositeBehavioralLt = quantCompositeBehavioralLt, quantCompositeBehavioralLte = quantCompositeBehavioralLte, quantCompositeFundamental = quantCompositeFundamental, quantCompositeFundamentalGt = quantCompositeFundamentalGt, quantCompositeFundamentalGte = quantCompositeFundamentalGte, quantCompositeFundamentalLt = quantCompositeFundamentalLt, quantCompositeFundamentalLte = quantCompositeFundamentalLte, quantCompositeGlobal = quantCompositeGlobal, quantCompositeGlobalGt = quantCompositeGlobalGt, quantCompositeGlobalGte = quantCompositeGlobalGte, quantCompositeGlobalLt = quantCompositeGlobalLt, quantCompositeGlobalLte = quantCompositeGlobalLte, quantCompositeQuality = quantCompositeQuality, quantCompositeQualityGt = quantCompositeQualityGt, quantCompositeQualityGte = quantCompositeQualityGte, quantCompositeQualityLt = quantCompositeQualityLt, quantCompositeQualityLte = quantCompositeQualityLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetEtfGlobalV1Analytics200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /etf-global/v1/analytics
     * 
     * ETF Global analytics data containing risk scores, reward metrics, and quantitative analysis for ETF composite tickers.
     * @param compositeTicker The stock ticker symbol used to identify this ETF product on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param riskTotalScore ETF Global&#39;s proprietary Red Diamond overall risk assessment score for the ETF. Value must be a floating point number. (optional)
     * @param riskTotalScoreGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param riskTotalScoreGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param riskTotalScoreLt Filter less than the value. Value must be a floating point number. (optional)
     * @param riskTotalScoreLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param rewardScore ETF Global&#39;s proprietary Green Diamond score measuring the potential reward and return prospects of the ETF. Value must be a floating point number. (optional)
     * @param rewardScoreGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param rewardScoreGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param rewardScoreLt Filter less than the value. Value must be a floating point number. (optional)
     * @param rewardScoreLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantTotalScore ETF Global&#39;s comprehensive quantitative analysis score combining all quantitative factors. Value must be a floating point number. (optional)
     * @param quantTotalScoreGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantTotalScoreGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantTotalScoreLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantTotalScoreLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantGrade Letter grade summarizing the ETF&#39;s overall quantitative assessment, where A &#x3D; 71-100, B &#x3D; 56-70, etc. (optional)
     * @param quantGradeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param quantGradeGt Filter greater than the value. (optional)
     * @param quantGradeGte Filter greater than or equal to the value. (optional)
     * @param quantGradeLt Filter less than the value. (optional)
     * @param quantGradeLte Filter less than or equal to the value. (optional)
     * @param quantCompositeTechnical Combined technical analysis score aggregating short, intermediate, and long-term technical factors. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentiment Overall market sentiment score combining put/call ratios, short interest, and implied volatility. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioral Behavioral analysis score measuring investor psychology and market behavior patterns. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamental Overall fundamental analysis score combining P/E, P/CF, P/B, and dividend yield metrics. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobal Overall global theme score combining sector and country analysis for macro investment views. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeQuality Overall quality assessment score combining liquidity, diversification, and issuing firm factors. Value must be a floating point number. (optional)
     * @param quantCompositeQualityGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeQualityGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeQualityLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeQualityLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return ApiResponse<GetEtfGlobalV1Analytics200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEtfGlobalV1AnalyticsWithHttpInfo(compositeTicker: kotlin.String?, compositeTickerAnyOf: kotlin.String?, compositeTickerGt: kotlin.String?, compositeTickerGte: kotlin.String?, compositeTickerLt: kotlin.String?, compositeTickerLte: kotlin.String?, processedDate: kotlin.String?, processedDateGt: kotlin.String?, processedDateGte: kotlin.String?, processedDateLt: kotlin.String?, processedDateLte: kotlin.String?, effectiveDate: kotlin.String?, effectiveDateGt: kotlin.String?, effectiveDateGte: kotlin.String?, effectiveDateLt: kotlin.String?, effectiveDateLte: kotlin.String?, riskTotalScore: kotlin.Double?, riskTotalScoreGt: kotlin.Double?, riskTotalScoreGte: kotlin.Double?, riskTotalScoreLt: kotlin.Double?, riskTotalScoreLte: kotlin.Double?, rewardScore: kotlin.Double?, rewardScoreGt: kotlin.Double?, rewardScoreGte: kotlin.Double?, rewardScoreLt: kotlin.Double?, rewardScoreLte: kotlin.Double?, quantTotalScore: kotlin.Double?, quantTotalScoreGt: kotlin.Double?, quantTotalScoreGte: kotlin.Double?, quantTotalScoreLt: kotlin.Double?, quantTotalScoreLte: kotlin.Double?, quantGrade: kotlin.String?, quantGradeAnyOf: kotlin.String?, quantGradeGt: kotlin.String?, quantGradeGte: kotlin.String?, quantGradeLt: kotlin.String?, quantGradeLte: kotlin.String?, quantCompositeTechnical: kotlin.Double?, quantCompositeTechnicalGt: kotlin.Double?, quantCompositeTechnicalGte: kotlin.Double?, quantCompositeTechnicalLt: kotlin.Double?, quantCompositeTechnicalLte: kotlin.Double?, quantCompositeSentiment: kotlin.Double?, quantCompositeSentimentGt: kotlin.Double?, quantCompositeSentimentGte: kotlin.Double?, quantCompositeSentimentLt: kotlin.Double?, quantCompositeSentimentLte: kotlin.Double?, quantCompositeBehavioral: kotlin.Double?, quantCompositeBehavioralGt: kotlin.Double?, quantCompositeBehavioralGte: kotlin.Double?, quantCompositeBehavioralLt: kotlin.Double?, quantCompositeBehavioralLte: kotlin.Double?, quantCompositeFundamental: kotlin.Double?, quantCompositeFundamentalGt: kotlin.Double?, quantCompositeFundamentalGte: kotlin.Double?, quantCompositeFundamentalLt: kotlin.Double?, quantCompositeFundamentalLte: kotlin.Double?, quantCompositeGlobal: kotlin.Double?, quantCompositeGlobalGt: kotlin.Double?, quantCompositeGlobalGte: kotlin.Double?, quantCompositeGlobalLt: kotlin.Double?, quantCompositeGlobalLte: kotlin.Double?, quantCompositeQuality: kotlin.Double?, quantCompositeQualityGt: kotlin.Double?, quantCompositeQualityGte: kotlin.Double?, quantCompositeQualityLt: kotlin.Double?, quantCompositeQualityLte: kotlin.Double?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetEtfGlobalV1Analytics200Response?> {
        val localVariableConfig = getEtfGlobalV1AnalyticsRequestConfig(compositeTicker = compositeTicker, compositeTickerAnyOf = compositeTickerAnyOf, compositeTickerGt = compositeTickerGt, compositeTickerGte = compositeTickerGte, compositeTickerLt = compositeTickerLt, compositeTickerLte = compositeTickerLte, processedDate = processedDate, processedDateGt = processedDateGt, processedDateGte = processedDateGte, processedDateLt = processedDateLt, processedDateLte = processedDateLte, effectiveDate = effectiveDate, effectiveDateGt = effectiveDateGt, effectiveDateGte = effectiveDateGte, effectiveDateLt = effectiveDateLt, effectiveDateLte = effectiveDateLte, riskTotalScore = riskTotalScore, riskTotalScoreGt = riskTotalScoreGt, riskTotalScoreGte = riskTotalScoreGte, riskTotalScoreLt = riskTotalScoreLt, riskTotalScoreLte = riskTotalScoreLte, rewardScore = rewardScore, rewardScoreGt = rewardScoreGt, rewardScoreGte = rewardScoreGte, rewardScoreLt = rewardScoreLt, rewardScoreLte = rewardScoreLte, quantTotalScore = quantTotalScore, quantTotalScoreGt = quantTotalScoreGt, quantTotalScoreGte = quantTotalScoreGte, quantTotalScoreLt = quantTotalScoreLt, quantTotalScoreLte = quantTotalScoreLte, quantGrade = quantGrade, quantGradeAnyOf = quantGradeAnyOf, quantGradeGt = quantGradeGt, quantGradeGte = quantGradeGte, quantGradeLt = quantGradeLt, quantGradeLte = quantGradeLte, quantCompositeTechnical = quantCompositeTechnical, quantCompositeTechnicalGt = quantCompositeTechnicalGt, quantCompositeTechnicalGte = quantCompositeTechnicalGte, quantCompositeTechnicalLt = quantCompositeTechnicalLt, quantCompositeTechnicalLte = quantCompositeTechnicalLte, quantCompositeSentiment = quantCompositeSentiment, quantCompositeSentimentGt = quantCompositeSentimentGt, quantCompositeSentimentGte = quantCompositeSentimentGte, quantCompositeSentimentLt = quantCompositeSentimentLt, quantCompositeSentimentLte = quantCompositeSentimentLte, quantCompositeBehavioral = quantCompositeBehavioral, quantCompositeBehavioralGt = quantCompositeBehavioralGt, quantCompositeBehavioralGte = quantCompositeBehavioralGte, quantCompositeBehavioralLt = quantCompositeBehavioralLt, quantCompositeBehavioralLte = quantCompositeBehavioralLte, quantCompositeFundamental = quantCompositeFundamental, quantCompositeFundamentalGt = quantCompositeFundamentalGt, quantCompositeFundamentalGte = quantCompositeFundamentalGte, quantCompositeFundamentalLt = quantCompositeFundamentalLt, quantCompositeFundamentalLte = quantCompositeFundamentalLte, quantCompositeGlobal = quantCompositeGlobal, quantCompositeGlobalGt = quantCompositeGlobalGt, quantCompositeGlobalGte = quantCompositeGlobalGte, quantCompositeGlobalLt = quantCompositeGlobalLt, quantCompositeGlobalLte = quantCompositeGlobalLte, quantCompositeQuality = quantCompositeQuality, quantCompositeQualityGt = quantCompositeQualityGt, quantCompositeQualityGte = quantCompositeQualityGte, quantCompositeQualityLt = quantCompositeQualityLt, quantCompositeQualityLte = quantCompositeQualityLte, limit = limit, sort = sort)

        return request<Unit, GetEtfGlobalV1Analytics200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEtfGlobalV1Analytics
     *
     * @param compositeTicker The stock ticker symbol used to identify this ETF product on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param riskTotalScore ETF Global&#39;s proprietary Red Diamond overall risk assessment score for the ETF. Value must be a floating point number. (optional)
     * @param riskTotalScoreGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param riskTotalScoreGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param riskTotalScoreLt Filter less than the value. Value must be a floating point number. (optional)
     * @param riskTotalScoreLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param rewardScore ETF Global&#39;s proprietary Green Diamond score measuring the potential reward and return prospects of the ETF. Value must be a floating point number. (optional)
     * @param rewardScoreGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param rewardScoreGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param rewardScoreLt Filter less than the value. Value must be a floating point number. (optional)
     * @param rewardScoreLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantTotalScore ETF Global&#39;s comprehensive quantitative analysis score combining all quantitative factors. Value must be a floating point number. (optional)
     * @param quantTotalScoreGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantTotalScoreGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantTotalScoreLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantTotalScoreLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantGrade Letter grade summarizing the ETF&#39;s overall quantitative assessment, where A &#x3D; 71-100, B &#x3D; 56-70, etc. (optional)
     * @param quantGradeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param quantGradeGt Filter greater than the value. (optional)
     * @param quantGradeGte Filter greater than or equal to the value. (optional)
     * @param quantGradeLt Filter less than the value. (optional)
     * @param quantGradeLte Filter less than or equal to the value. (optional)
     * @param quantCompositeTechnical Combined technical analysis score aggregating short, intermediate, and long-term technical factors. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeTechnicalLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentiment Overall market sentiment score combining put/call ratios, short interest, and implied volatility. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeSentimentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioral Behavioral analysis score measuring investor psychology and market behavior patterns. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeBehavioralLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamental Overall fundamental analysis score combining P/E, P/CF, P/B, and dividend yield metrics. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeFundamentalLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobal Overall global theme score combining sector and country analysis for macro investment views. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeGlobalLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeQuality Overall quality assessment score combining liquidity, diversification, and issuing firm factors. Value must be a floating point number. (optional)
     * @param quantCompositeQualityGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quantCompositeQualityGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quantCompositeQualityLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quantCompositeQualityLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return RequestConfig
     */
    fun getEtfGlobalV1AnalyticsRequestConfig(compositeTicker: kotlin.String?, compositeTickerAnyOf: kotlin.String?, compositeTickerGt: kotlin.String?, compositeTickerGte: kotlin.String?, compositeTickerLt: kotlin.String?, compositeTickerLte: kotlin.String?, processedDate: kotlin.String?, processedDateGt: kotlin.String?, processedDateGte: kotlin.String?, processedDateLt: kotlin.String?, processedDateLte: kotlin.String?, effectiveDate: kotlin.String?, effectiveDateGt: kotlin.String?, effectiveDateGte: kotlin.String?, effectiveDateLt: kotlin.String?, effectiveDateLte: kotlin.String?, riskTotalScore: kotlin.Double?, riskTotalScoreGt: kotlin.Double?, riskTotalScoreGte: kotlin.Double?, riskTotalScoreLt: kotlin.Double?, riskTotalScoreLte: kotlin.Double?, rewardScore: kotlin.Double?, rewardScoreGt: kotlin.Double?, rewardScoreGte: kotlin.Double?, rewardScoreLt: kotlin.Double?, rewardScoreLte: kotlin.Double?, quantTotalScore: kotlin.Double?, quantTotalScoreGt: kotlin.Double?, quantTotalScoreGte: kotlin.Double?, quantTotalScoreLt: kotlin.Double?, quantTotalScoreLte: kotlin.Double?, quantGrade: kotlin.String?, quantGradeAnyOf: kotlin.String?, quantGradeGt: kotlin.String?, quantGradeGte: kotlin.String?, quantGradeLt: kotlin.String?, quantGradeLte: kotlin.String?, quantCompositeTechnical: kotlin.Double?, quantCompositeTechnicalGt: kotlin.Double?, quantCompositeTechnicalGte: kotlin.Double?, quantCompositeTechnicalLt: kotlin.Double?, quantCompositeTechnicalLte: kotlin.Double?, quantCompositeSentiment: kotlin.Double?, quantCompositeSentimentGt: kotlin.Double?, quantCompositeSentimentGte: kotlin.Double?, quantCompositeSentimentLt: kotlin.Double?, quantCompositeSentimentLte: kotlin.Double?, quantCompositeBehavioral: kotlin.Double?, quantCompositeBehavioralGt: kotlin.Double?, quantCompositeBehavioralGte: kotlin.Double?, quantCompositeBehavioralLt: kotlin.Double?, quantCompositeBehavioralLte: kotlin.Double?, quantCompositeFundamental: kotlin.Double?, quantCompositeFundamentalGt: kotlin.Double?, quantCompositeFundamentalGte: kotlin.Double?, quantCompositeFundamentalLt: kotlin.Double?, quantCompositeFundamentalLte: kotlin.Double?, quantCompositeGlobal: kotlin.Double?, quantCompositeGlobalGt: kotlin.Double?, quantCompositeGlobalGte: kotlin.Double?, quantCompositeGlobalLt: kotlin.Double?, quantCompositeGlobalLte: kotlin.Double?, quantCompositeQuality: kotlin.Double?, quantCompositeQualityGt: kotlin.Double?, quantCompositeQualityGte: kotlin.Double?, quantCompositeQualityLt: kotlin.Double?, quantCompositeQualityLte: kotlin.Double?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (compositeTicker != null) {
                    put("composite_ticker", listOf(compositeTicker.toString()))
                }
                if (compositeTickerAnyOf != null) {
                    put("composite_ticker.any_of", listOf(compositeTickerAnyOf.toString()))
                }
                if (compositeTickerGt != null) {
                    put("composite_ticker.gt", listOf(compositeTickerGt.toString()))
                }
                if (compositeTickerGte != null) {
                    put("composite_ticker.gte", listOf(compositeTickerGte.toString()))
                }
                if (compositeTickerLt != null) {
                    put("composite_ticker.lt", listOf(compositeTickerLt.toString()))
                }
                if (compositeTickerLte != null) {
                    put("composite_ticker.lte", listOf(compositeTickerLte.toString()))
                }
                if (processedDate != null) {
                    put("processed_date", listOf(processedDate.toString()))
                }
                if (processedDateGt != null) {
                    put("processed_date.gt", listOf(processedDateGt.toString()))
                }
                if (processedDateGte != null) {
                    put("processed_date.gte", listOf(processedDateGte.toString()))
                }
                if (processedDateLt != null) {
                    put("processed_date.lt", listOf(processedDateLt.toString()))
                }
                if (processedDateLte != null) {
                    put("processed_date.lte", listOf(processedDateLte.toString()))
                }
                if (effectiveDate != null) {
                    put("effective_date", listOf(effectiveDate.toString()))
                }
                if (effectiveDateGt != null) {
                    put("effective_date.gt", listOf(effectiveDateGt.toString()))
                }
                if (effectiveDateGte != null) {
                    put("effective_date.gte", listOf(effectiveDateGte.toString()))
                }
                if (effectiveDateLt != null) {
                    put("effective_date.lt", listOf(effectiveDateLt.toString()))
                }
                if (effectiveDateLte != null) {
                    put("effective_date.lte", listOf(effectiveDateLte.toString()))
                }
                if (riskTotalScore != null) {
                    put("risk_total_score", listOf(riskTotalScore.toString()))
                }
                if (riskTotalScoreGt != null) {
                    put("risk_total_score.gt", listOf(riskTotalScoreGt.toString()))
                }
                if (riskTotalScoreGte != null) {
                    put("risk_total_score.gte", listOf(riskTotalScoreGte.toString()))
                }
                if (riskTotalScoreLt != null) {
                    put("risk_total_score.lt", listOf(riskTotalScoreLt.toString()))
                }
                if (riskTotalScoreLte != null) {
                    put("risk_total_score.lte", listOf(riskTotalScoreLte.toString()))
                }
                if (rewardScore != null) {
                    put("reward_score", listOf(rewardScore.toString()))
                }
                if (rewardScoreGt != null) {
                    put("reward_score.gt", listOf(rewardScoreGt.toString()))
                }
                if (rewardScoreGte != null) {
                    put("reward_score.gte", listOf(rewardScoreGte.toString()))
                }
                if (rewardScoreLt != null) {
                    put("reward_score.lt", listOf(rewardScoreLt.toString()))
                }
                if (rewardScoreLte != null) {
                    put("reward_score.lte", listOf(rewardScoreLte.toString()))
                }
                if (quantTotalScore != null) {
                    put("quant_total_score", listOf(quantTotalScore.toString()))
                }
                if (quantTotalScoreGt != null) {
                    put("quant_total_score.gt", listOf(quantTotalScoreGt.toString()))
                }
                if (quantTotalScoreGte != null) {
                    put("quant_total_score.gte", listOf(quantTotalScoreGte.toString()))
                }
                if (quantTotalScoreLt != null) {
                    put("quant_total_score.lt", listOf(quantTotalScoreLt.toString()))
                }
                if (quantTotalScoreLte != null) {
                    put("quant_total_score.lte", listOf(quantTotalScoreLte.toString()))
                }
                if (quantGrade != null) {
                    put("quant_grade", listOf(quantGrade.toString()))
                }
                if (quantGradeAnyOf != null) {
                    put("quant_grade.any_of", listOf(quantGradeAnyOf.toString()))
                }
                if (quantGradeGt != null) {
                    put("quant_grade.gt", listOf(quantGradeGt.toString()))
                }
                if (quantGradeGte != null) {
                    put("quant_grade.gte", listOf(quantGradeGte.toString()))
                }
                if (quantGradeLt != null) {
                    put("quant_grade.lt", listOf(quantGradeLt.toString()))
                }
                if (quantGradeLte != null) {
                    put("quant_grade.lte", listOf(quantGradeLte.toString()))
                }
                if (quantCompositeTechnical != null) {
                    put("quant_composite_technical", listOf(quantCompositeTechnical.toString()))
                }
                if (quantCompositeTechnicalGt != null) {
                    put("quant_composite_technical.gt", listOf(quantCompositeTechnicalGt.toString()))
                }
                if (quantCompositeTechnicalGte != null) {
                    put("quant_composite_technical.gte", listOf(quantCompositeTechnicalGte.toString()))
                }
                if (quantCompositeTechnicalLt != null) {
                    put("quant_composite_technical.lt", listOf(quantCompositeTechnicalLt.toString()))
                }
                if (quantCompositeTechnicalLte != null) {
                    put("quant_composite_technical.lte", listOf(quantCompositeTechnicalLte.toString()))
                }
                if (quantCompositeSentiment != null) {
                    put("quant_composite_sentiment", listOf(quantCompositeSentiment.toString()))
                }
                if (quantCompositeSentimentGt != null) {
                    put("quant_composite_sentiment.gt", listOf(quantCompositeSentimentGt.toString()))
                }
                if (quantCompositeSentimentGte != null) {
                    put("quant_composite_sentiment.gte", listOf(quantCompositeSentimentGte.toString()))
                }
                if (quantCompositeSentimentLt != null) {
                    put("quant_composite_sentiment.lt", listOf(quantCompositeSentimentLt.toString()))
                }
                if (quantCompositeSentimentLte != null) {
                    put("quant_composite_sentiment.lte", listOf(quantCompositeSentimentLte.toString()))
                }
                if (quantCompositeBehavioral != null) {
                    put("quant_composite_behavioral", listOf(quantCompositeBehavioral.toString()))
                }
                if (quantCompositeBehavioralGt != null) {
                    put("quant_composite_behavioral.gt", listOf(quantCompositeBehavioralGt.toString()))
                }
                if (quantCompositeBehavioralGte != null) {
                    put("quant_composite_behavioral.gte", listOf(quantCompositeBehavioralGte.toString()))
                }
                if (quantCompositeBehavioralLt != null) {
                    put("quant_composite_behavioral.lt", listOf(quantCompositeBehavioralLt.toString()))
                }
                if (quantCompositeBehavioralLte != null) {
                    put("quant_composite_behavioral.lte", listOf(quantCompositeBehavioralLte.toString()))
                }
                if (quantCompositeFundamental != null) {
                    put("quant_composite_fundamental", listOf(quantCompositeFundamental.toString()))
                }
                if (quantCompositeFundamentalGt != null) {
                    put("quant_composite_fundamental.gt", listOf(quantCompositeFundamentalGt.toString()))
                }
                if (quantCompositeFundamentalGte != null) {
                    put("quant_composite_fundamental.gte", listOf(quantCompositeFundamentalGte.toString()))
                }
                if (quantCompositeFundamentalLt != null) {
                    put("quant_composite_fundamental.lt", listOf(quantCompositeFundamentalLt.toString()))
                }
                if (quantCompositeFundamentalLte != null) {
                    put("quant_composite_fundamental.lte", listOf(quantCompositeFundamentalLte.toString()))
                }
                if (quantCompositeGlobal != null) {
                    put("quant_composite_global", listOf(quantCompositeGlobal.toString()))
                }
                if (quantCompositeGlobalGt != null) {
                    put("quant_composite_global.gt", listOf(quantCompositeGlobalGt.toString()))
                }
                if (quantCompositeGlobalGte != null) {
                    put("quant_composite_global.gte", listOf(quantCompositeGlobalGte.toString()))
                }
                if (quantCompositeGlobalLt != null) {
                    put("quant_composite_global.lt", listOf(quantCompositeGlobalLt.toString()))
                }
                if (quantCompositeGlobalLte != null) {
                    put("quant_composite_global.lte", listOf(quantCompositeGlobalLte.toString()))
                }
                if (quantCompositeQuality != null) {
                    put("quant_composite_quality", listOf(quantCompositeQuality.toString()))
                }
                if (quantCompositeQualityGt != null) {
                    put("quant_composite_quality.gt", listOf(quantCompositeQualityGt.toString()))
                }
                if (quantCompositeQualityGte != null) {
                    put("quant_composite_quality.gte", listOf(quantCompositeQualityGte.toString()))
                }
                if (quantCompositeQualityLt != null) {
                    put("quant_composite_quality.lt", listOf(quantCompositeQualityLt.toString()))
                }
                if (quantCompositeQualityLte != null) {
                    put("quant_composite_quality.lte", listOf(quantCompositeQualityLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/etf-global/v1/analytics",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /etf-global/v1/constituents
     * 
     * ETF Global constituents data containing detailed information about the securities held within ETFs, including weights, market values, and security identifiers.
     * @param compositeTicker The stock ticker symbol of the ETF that holds these constituent securities. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param constituentTicker The stock ticker symbol of the individual security held within the ETF. (optional)
     * @param constituentTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param constituentTickerGt Filter greater than the value. (optional)
     * @param constituentTickerGte Filter greater than or equal to the value. (optional)
     * @param constituentTickerLt Filter less than the value. (optional)
     * @param constituentTickerLte Filter less than or equal to the value. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param usCode A unique identifier code for the constituent security in US markets. (optional)
     * @param usCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param usCodeGt Filter greater than the value. (optional)
     * @param usCodeGte Filter greater than or equal to the value. (optional)
     * @param usCodeLt Filter less than the value. (optional)
     * @param usCodeLte Filter less than or equal to the value. (optional)
     * @param isin The International Securities Identification Number, a global standard for identifying securities. (optional)
     * @param isinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param isinGt Filter greater than the value. (optional)
     * @param isinGte Filter greater than or equal to the value. (optional)
     * @param isinLt Filter less than the value. (optional)
     * @param isinLte Filter less than or equal to the value. (optional)
     * @param figi The Financial Instrument Global Identifier, an open standard for uniquely identifying financial instruments. (optional)
     * @param figiAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param figiGt Filter greater than the value. (optional)
     * @param figiGte Filter greater than or equal to the value. (optional)
     * @param figiLt Filter less than the value. (optional)
     * @param figiLte Filter less than or equal to the value. (optional)
     * @param sedol The Stock Exchange Daily Official List code, primarily used for securities trading in the UK. (optional)
     * @param sedolAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param sedolGt Filter greater than the value. (optional)
     * @param sedolGte Filter greater than or equal to the value. (optional)
     * @param sedolLt Filter less than the value. (optional)
     * @param sedolLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return GetEtfGlobalV1Constituents200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEtfGlobalV1Constituents(compositeTicker: kotlin.String? = null, compositeTickerAnyOf: kotlin.String? = null, compositeTickerGt: kotlin.String? = null, compositeTickerGte: kotlin.String? = null, compositeTickerLt: kotlin.String? = null, compositeTickerLte: kotlin.String? = null, constituentTicker: kotlin.String? = null, constituentTickerAnyOf: kotlin.String? = null, constituentTickerGt: kotlin.String? = null, constituentTickerGte: kotlin.String? = null, constituentTickerLt: kotlin.String? = null, constituentTickerLte: kotlin.String? = null, effectiveDate: kotlin.String? = null, effectiveDateGt: kotlin.String? = null, effectiveDateGte: kotlin.String? = null, effectiveDateLt: kotlin.String? = null, effectiveDateLte: kotlin.String? = null, processedDate: kotlin.String? = null, processedDateGt: kotlin.String? = null, processedDateGte: kotlin.String? = null, processedDateLt: kotlin.String? = null, processedDateLte: kotlin.String? = null, usCode: kotlin.String? = null, usCodeAnyOf: kotlin.String? = null, usCodeGt: kotlin.String? = null, usCodeGte: kotlin.String? = null, usCodeLt: kotlin.String? = null, usCodeLte: kotlin.String? = null, isin: kotlin.String? = null, isinAnyOf: kotlin.String? = null, isinGt: kotlin.String? = null, isinGte: kotlin.String? = null, isinLt: kotlin.String? = null, isinLte: kotlin.String? = null, figi: kotlin.String? = null, figiAnyOf: kotlin.String? = null, figiGt: kotlin.String? = null, figiGte: kotlin.String? = null, figiLt: kotlin.String? = null, figiLte: kotlin.String? = null, sedol: kotlin.String? = null, sedolAnyOf: kotlin.String? = null, sedolGt: kotlin.String? = null, sedolGte: kotlin.String? = null, sedolLt: kotlin.String? = null, sedolLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "composite_ticker.asc") : GetEtfGlobalV1Constituents200Response {
        val localVarResponse = getEtfGlobalV1ConstituentsWithHttpInfo(compositeTicker = compositeTicker, compositeTickerAnyOf = compositeTickerAnyOf, compositeTickerGt = compositeTickerGt, compositeTickerGte = compositeTickerGte, compositeTickerLt = compositeTickerLt, compositeTickerLte = compositeTickerLte, constituentTicker = constituentTicker, constituentTickerAnyOf = constituentTickerAnyOf, constituentTickerGt = constituentTickerGt, constituentTickerGte = constituentTickerGte, constituentTickerLt = constituentTickerLt, constituentTickerLte = constituentTickerLte, effectiveDate = effectiveDate, effectiveDateGt = effectiveDateGt, effectiveDateGte = effectiveDateGte, effectiveDateLt = effectiveDateLt, effectiveDateLte = effectiveDateLte, processedDate = processedDate, processedDateGt = processedDateGt, processedDateGte = processedDateGte, processedDateLt = processedDateLt, processedDateLte = processedDateLte, usCode = usCode, usCodeAnyOf = usCodeAnyOf, usCodeGt = usCodeGt, usCodeGte = usCodeGte, usCodeLt = usCodeLt, usCodeLte = usCodeLte, isin = isin, isinAnyOf = isinAnyOf, isinGt = isinGt, isinGte = isinGte, isinLt = isinLt, isinLte = isinLte, figi = figi, figiAnyOf = figiAnyOf, figiGt = figiGt, figiGte = figiGte, figiLt = figiLt, figiLte = figiLte, sedol = sedol, sedolAnyOf = sedolAnyOf, sedolGt = sedolGt, sedolGte = sedolGte, sedolLt = sedolLt, sedolLte = sedolLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetEtfGlobalV1Constituents200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /etf-global/v1/constituents
     * 
     * ETF Global constituents data containing detailed information about the securities held within ETFs, including weights, market values, and security identifiers.
     * @param compositeTicker The stock ticker symbol of the ETF that holds these constituent securities. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param constituentTicker The stock ticker symbol of the individual security held within the ETF. (optional)
     * @param constituentTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param constituentTickerGt Filter greater than the value. (optional)
     * @param constituentTickerGte Filter greater than or equal to the value. (optional)
     * @param constituentTickerLt Filter less than the value. (optional)
     * @param constituentTickerLte Filter less than or equal to the value. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param usCode A unique identifier code for the constituent security in US markets. (optional)
     * @param usCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param usCodeGt Filter greater than the value. (optional)
     * @param usCodeGte Filter greater than or equal to the value. (optional)
     * @param usCodeLt Filter less than the value. (optional)
     * @param usCodeLte Filter less than or equal to the value. (optional)
     * @param isin The International Securities Identification Number, a global standard for identifying securities. (optional)
     * @param isinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param isinGt Filter greater than the value. (optional)
     * @param isinGte Filter greater than or equal to the value. (optional)
     * @param isinLt Filter less than the value. (optional)
     * @param isinLte Filter less than or equal to the value. (optional)
     * @param figi The Financial Instrument Global Identifier, an open standard for uniquely identifying financial instruments. (optional)
     * @param figiAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param figiGt Filter greater than the value. (optional)
     * @param figiGte Filter greater than or equal to the value. (optional)
     * @param figiLt Filter less than the value. (optional)
     * @param figiLte Filter less than or equal to the value. (optional)
     * @param sedol The Stock Exchange Daily Official List code, primarily used for securities trading in the UK. (optional)
     * @param sedolAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param sedolGt Filter greater than the value. (optional)
     * @param sedolGte Filter greater than or equal to the value. (optional)
     * @param sedolLt Filter less than the value. (optional)
     * @param sedolLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return ApiResponse<GetEtfGlobalV1Constituents200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEtfGlobalV1ConstituentsWithHttpInfo(compositeTicker: kotlin.String?, compositeTickerAnyOf: kotlin.String?, compositeTickerGt: kotlin.String?, compositeTickerGte: kotlin.String?, compositeTickerLt: kotlin.String?, compositeTickerLte: kotlin.String?, constituentTicker: kotlin.String?, constituentTickerAnyOf: kotlin.String?, constituentTickerGt: kotlin.String?, constituentTickerGte: kotlin.String?, constituentTickerLt: kotlin.String?, constituentTickerLte: kotlin.String?, effectiveDate: kotlin.String?, effectiveDateGt: kotlin.String?, effectiveDateGte: kotlin.String?, effectiveDateLt: kotlin.String?, effectiveDateLte: kotlin.String?, processedDate: kotlin.String?, processedDateGt: kotlin.String?, processedDateGte: kotlin.String?, processedDateLt: kotlin.String?, processedDateLte: kotlin.String?, usCode: kotlin.String?, usCodeAnyOf: kotlin.String?, usCodeGt: kotlin.String?, usCodeGte: kotlin.String?, usCodeLt: kotlin.String?, usCodeLte: kotlin.String?, isin: kotlin.String?, isinAnyOf: kotlin.String?, isinGt: kotlin.String?, isinGte: kotlin.String?, isinLt: kotlin.String?, isinLte: kotlin.String?, figi: kotlin.String?, figiAnyOf: kotlin.String?, figiGt: kotlin.String?, figiGte: kotlin.String?, figiLt: kotlin.String?, figiLte: kotlin.String?, sedol: kotlin.String?, sedolAnyOf: kotlin.String?, sedolGt: kotlin.String?, sedolGte: kotlin.String?, sedolLt: kotlin.String?, sedolLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetEtfGlobalV1Constituents200Response?> {
        val localVariableConfig = getEtfGlobalV1ConstituentsRequestConfig(compositeTicker = compositeTicker, compositeTickerAnyOf = compositeTickerAnyOf, compositeTickerGt = compositeTickerGt, compositeTickerGte = compositeTickerGte, compositeTickerLt = compositeTickerLt, compositeTickerLte = compositeTickerLte, constituentTicker = constituentTicker, constituentTickerAnyOf = constituentTickerAnyOf, constituentTickerGt = constituentTickerGt, constituentTickerGte = constituentTickerGte, constituentTickerLt = constituentTickerLt, constituentTickerLte = constituentTickerLte, effectiveDate = effectiveDate, effectiveDateGt = effectiveDateGt, effectiveDateGte = effectiveDateGte, effectiveDateLt = effectiveDateLt, effectiveDateLte = effectiveDateLte, processedDate = processedDate, processedDateGt = processedDateGt, processedDateGte = processedDateGte, processedDateLt = processedDateLt, processedDateLte = processedDateLte, usCode = usCode, usCodeAnyOf = usCodeAnyOf, usCodeGt = usCodeGt, usCodeGte = usCodeGte, usCodeLt = usCodeLt, usCodeLte = usCodeLte, isin = isin, isinAnyOf = isinAnyOf, isinGt = isinGt, isinGte = isinGte, isinLt = isinLt, isinLte = isinLte, figi = figi, figiAnyOf = figiAnyOf, figiGt = figiGt, figiGte = figiGte, figiLt = figiLt, figiLte = figiLte, sedol = sedol, sedolAnyOf = sedolAnyOf, sedolGt = sedolGt, sedolGte = sedolGte, sedolLt = sedolLt, sedolLte = sedolLte, limit = limit, sort = sort)

        return request<Unit, GetEtfGlobalV1Constituents200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEtfGlobalV1Constituents
     *
     * @param compositeTicker The stock ticker symbol of the ETF that holds these constituent securities. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param constituentTicker The stock ticker symbol of the individual security held within the ETF. (optional)
     * @param constituentTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param constituentTickerGt Filter greater than the value. (optional)
     * @param constituentTickerGte Filter greater than or equal to the value. (optional)
     * @param constituentTickerLt Filter less than the value. (optional)
     * @param constituentTickerLte Filter less than or equal to the value. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param usCode A unique identifier code for the constituent security in US markets. (optional)
     * @param usCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param usCodeGt Filter greater than the value. (optional)
     * @param usCodeGte Filter greater than or equal to the value. (optional)
     * @param usCodeLt Filter less than the value. (optional)
     * @param usCodeLte Filter less than or equal to the value. (optional)
     * @param isin The International Securities Identification Number, a global standard for identifying securities. (optional)
     * @param isinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param isinGt Filter greater than the value. (optional)
     * @param isinGte Filter greater than or equal to the value. (optional)
     * @param isinLt Filter less than the value. (optional)
     * @param isinLte Filter less than or equal to the value. (optional)
     * @param figi The Financial Instrument Global Identifier, an open standard for uniquely identifying financial instruments. (optional)
     * @param figiAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param figiGt Filter greater than the value. (optional)
     * @param figiGte Filter greater than or equal to the value. (optional)
     * @param figiLt Filter less than the value. (optional)
     * @param figiLte Filter less than or equal to the value. (optional)
     * @param sedol The Stock Exchange Daily Official List code, primarily used for securities trading in the UK. (optional)
     * @param sedolAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param sedolGt Filter greater than the value. (optional)
     * @param sedolGte Filter greater than or equal to the value. (optional)
     * @param sedolLt Filter less than the value. (optional)
     * @param sedolLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return RequestConfig
     */
    fun getEtfGlobalV1ConstituentsRequestConfig(compositeTicker: kotlin.String?, compositeTickerAnyOf: kotlin.String?, compositeTickerGt: kotlin.String?, compositeTickerGte: kotlin.String?, compositeTickerLt: kotlin.String?, compositeTickerLte: kotlin.String?, constituentTicker: kotlin.String?, constituentTickerAnyOf: kotlin.String?, constituentTickerGt: kotlin.String?, constituentTickerGte: kotlin.String?, constituentTickerLt: kotlin.String?, constituentTickerLte: kotlin.String?, effectiveDate: kotlin.String?, effectiveDateGt: kotlin.String?, effectiveDateGte: kotlin.String?, effectiveDateLt: kotlin.String?, effectiveDateLte: kotlin.String?, processedDate: kotlin.String?, processedDateGt: kotlin.String?, processedDateGte: kotlin.String?, processedDateLt: kotlin.String?, processedDateLte: kotlin.String?, usCode: kotlin.String?, usCodeAnyOf: kotlin.String?, usCodeGt: kotlin.String?, usCodeGte: kotlin.String?, usCodeLt: kotlin.String?, usCodeLte: kotlin.String?, isin: kotlin.String?, isinAnyOf: kotlin.String?, isinGt: kotlin.String?, isinGte: kotlin.String?, isinLt: kotlin.String?, isinLte: kotlin.String?, figi: kotlin.String?, figiAnyOf: kotlin.String?, figiGt: kotlin.String?, figiGte: kotlin.String?, figiLt: kotlin.String?, figiLte: kotlin.String?, sedol: kotlin.String?, sedolAnyOf: kotlin.String?, sedolGt: kotlin.String?, sedolGte: kotlin.String?, sedolLt: kotlin.String?, sedolLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (compositeTicker != null) {
                    put("composite_ticker", listOf(compositeTicker.toString()))
                }
                if (compositeTickerAnyOf != null) {
                    put("composite_ticker.any_of", listOf(compositeTickerAnyOf.toString()))
                }
                if (compositeTickerGt != null) {
                    put("composite_ticker.gt", listOf(compositeTickerGt.toString()))
                }
                if (compositeTickerGte != null) {
                    put("composite_ticker.gte", listOf(compositeTickerGte.toString()))
                }
                if (compositeTickerLt != null) {
                    put("composite_ticker.lt", listOf(compositeTickerLt.toString()))
                }
                if (compositeTickerLte != null) {
                    put("composite_ticker.lte", listOf(compositeTickerLte.toString()))
                }
                if (constituentTicker != null) {
                    put("constituent_ticker", listOf(constituentTicker.toString()))
                }
                if (constituentTickerAnyOf != null) {
                    put("constituent_ticker.any_of", listOf(constituentTickerAnyOf.toString()))
                }
                if (constituentTickerGt != null) {
                    put("constituent_ticker.gt", listOf(constituentTickerGt.toString()))
                }
                if (constituentTickerGte != null) {
                    put("constituent_ticker.gte", listOf(constituentTickerGte.toString()))
                }
                if (constituentTickerLt != null) {
                    put("constituent_ticker.lt", listOf(constituentTickerLt.toString()))
                }
                if (constituentTickerLte != null) {
                    put("constituent_ticker.lte", listOf(constituentTickerLte.toString()))
                }
                if (effectiveDate != null) {
                    put("effective_date", listOf(effectiveDate.toString()))
                }
                if (effectiveDateGt != null) {
                    put("effective_date.gt", listOf(effectiveDateGt.toString()))
                }
                if (effectiveDateGte != null) {
                    put("effective_date.gte", listOf(effectiveDateGte.toString()))
                }
                if (effectiveDateLt != null) {
                    put("effective_date.lt", listOf(effectiveDateLt.toString()))
                }
                if (effectiveDateLte != null) {
                    put("effective_date.lte", listOf(effectiveDateLte.toString()))
                }
                if (processedDate != null) {
                    put("processed_date", listOf(processedDate.toString()))
                }
                if (processedDateGt != null) {
                    put("processed_date.gt", listOf(processedDateGt.toString()))
                }
                if (processedDateGte != null) {
                    put("processed_date.gte", listOf(processedDateGte.toString()))
                }
                if (processedDateLt != null) {
                    put("processed_date.lt", listOf(processedDateLt.toString()))
                }
                if (processedDateLte != null) {
                    put("processed_date.lte", listOf(processedDateLte.toString()))
                }
                if (usCode != null) {
                    put("us_code", listOf(usCode.toString()))
                }
                if (usCodeAnyOf != null) {
                    put("us_code.any_of", listOf(usCodeAnyOf.toString()))
                }
                if (usCodeGt != null) {
                    put("us_code.gt", listOf(usCodeGt.toString()))
                }
                if (usCodeGte != null) {
                    put("us_code.gte", listOf(usCodeGte.toString()))
                }
                if (usCodeLt != null) {
                    put("us_code.lt", listOf(usCodeLt.toString()))
                }
                if (usCodeLte != null) {
                    put("us_code.lte", listOf(usCodeLte.toString()))
                }
                if (isin != null) {
                    put("isin", listOf(isin.toString()))
                }
                if (isinAnyOf != null) {
                    put("isin.any_of", listOf(isinAnyOf.toString()))
                }
                if (isinGt != null) {
                    put("isin.gt", listOf(isinGt.toString()))
                }
                if (isinGte != null) {
                    put("isin.gte", listOf(isinGte.toString()))
                }
                if (isinLt != null) {
                    put("isin.lt", listOf(isinLt.toString()))
                }
                if (isinLte != null) {
                    put("isin.lte", listOf(isinLte.toString()))
                }
                if (figi != null) {
                    put("figi", listOf(figi.toString()))
                }
                if (figiAnyOf != null) {
                    put("figi.any_of", listOf(figiAnyOf.toString()))
                }
                if (figiGt != null) {
                    put("figi.gt", listOf(figiGt.toString()))
                }
                if (figiGte != null) {
                    put("figi.gte", listOf(figiGte.toString()))
                }
                if (figiLt != null) {
                    put("figi.lt", listOf(figiLt.toString()))
                }
                if (figiLte != null) {
                    put("figi.lte", listOf(figiLte.toString()))
                }
                if (sedol != null) {
                    put("sedol", listOf(sedol.toString()))
                }
                if (sedolAnyOf != null) {
                    put("sedol.any_of", listOf(sedolAnyOf.toString()))
                }
                if (sedolGt != null) {
                    put("sedol.gt", listOf(sedolGt.toString()))
                }
                if (sedolGte != null) {
                    put("sedol.gte", listOf(sedolGte.toString()))
                }
                if (sedolLt != null) {
                    put("sedol.lt", listOf(sedolLt.toString()))
                }
                if (sedolLte != null) {
                    put("sedol.lte", listOf(sedolLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/etf-global/v1/constituents",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /etf-global/v1/fund-flows
     * 
     * ETF Global fund flow data containing information about ETF share movements, net asset values, and fund flow metrics.
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param compositeTicker The stock ticker symbol used to identify this ETF on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return GetEtfGlobalV1FundFlows200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEtfGlobalV1FundFlows(processedDate: kotlin.String? = null, processedDateGt: kotlin.String? = null, processedDateGte: kotlin.String? = null, processedDateLt: kotlin.String? = null, processedDateLte: kotlin.String? = null, effectiveDate: kotlin.String? = null, effectiveDateGt: kotlin.String? = null, effectiveDateGte: kotlin.String? = null, effectiveDateLt: kotlin.String? = null, effectiveDateLte: kotlin.String? = null, compositeTicker: kotlin.String? = null, compositeTickerAnyOf: kotlin.String? = null, compositeTickerGt: kotlin.String? = null, compositeTickerGte: kotlin.String? = null, compositeTickerLt: kotlin.String? = null, compositeTickerLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "composite_ticker.asc") : GetEtfGlobalV1FundFlows200Response {
        val localVarResponse = getEtfGlobalV1FundFlowsWithHttpInfo(processedDate = processedDate, processedDateGt = processedDateGt, processedDateGte = processedDateGte, processedDateLt = processedDateLt, processedDateLte = processedDateLte, effectiveDate = effectiveDate, effectiveDateGt = effectiveDateGt, effectiveDateGte = effectiveDateGte, effectiveDateLt = effectiveDateLt, effectiveDateLte = effectiveDateLte, compositeTicker = compositeTicker, compositeTickerAnyOf = compositeTickerAnyOf, compositeTickerGt = compositeTickerGt, compositeTickerGte = compositeTickerGte, compositeTickerLt = compositeTickerLt, compositeTickerLte = compositeTickerLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetEtfGlobalV1FundFlows200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /etf-global/v1/fund-flows
     * 
     * ETF Global fund flow data containing information about ETF share movements, net asset values, and fund flow metrics.
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param compositeTicker The stock ticker symbol used to identify this ETF on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return ApiResponse<GetEtfGlobalV1FundFlows200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEtfGlobalV1FundFlowsWithHttpInfo(processedDate: kotlin.String?, processedDateGt: kotlin.String?, processedDateGte: kotlin.String?, processedDateLt: kotlin.String?, processedDateLte: kotlin.String?, effectiveDate: kotlin.String?, effectiveDateGt: kotlin.String?, effectiveDateGte: kotlin.String?, effectiveDateLt: kotlin.String?, effectiveDateLte: kotlin.String?, compositeTicker: kotlin.String?, compositeTickerAnyOf: kotlin.String?, compositeTickerGt: kotlin.String?, compositeTickerGte: kotlin.String?, compositeTickerLt: kotlin.String?, compositeTickerLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetEtfGlobalV1FundFlows200Response?> {
        val localVariableConfig = getEtfGlobalV1FundFlowsRequestConfig(processedDate = processedDate, processedDateGt = processedDateGt, processedDateGte = processedDateGte, processedDateLt = processedDateLt, processedDateLte = processedDateLte, effectiveDate = effectiveDate, effectiveDateGt = effectiveDateGt, effectiveDateGte = effectiveDateGte, effectiveDateLt = effectiveDateLt, effectiveDateLte = effectiveDateLte, compositeTicker = compositeTicker, compositeTickerAnyOf = compositeTickerAnyOf, compositeTickerGt = compositeTickerGt, compositeTickerGte = compositeTickerGte, compositeTickerLt = compositeTickerLt, compositeTickerLte = compositeTickerLte, limit = limit, sort = sort)

        return request<Unit, GetEtfGlobalV1FundFlows200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEtfGlobalV1FundFlows
     *
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param compositeTicker The stock ticker symbol used to identify this ETF on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return RequestConfig
     */
    fun getEtfGlobalV1FundFlowsRequestConfig(processedDate: kotlin.String?, processedDateGt: kotlin.String?, processedDateGte: kotlin.String?, processedDateLt: kotlin.String?, processedDateLte: kotlin.String?, effectiveDate: kotlin.String?, effectiveDateGt: kotlin.String?, effectiveDateGte: kotlin.String?, effectiveDateLt: kotlin.String?, effectiveDateLte: kotlin.String?, compositeTicker: kotlin.String?, compositeTickerAnyOf: kotlin.String?, compositeTickerGt: kotlin.String?, compositeTickerGte: kotlin.String?, compositeTickerLt: kotlin.String?, compositeTickerLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (processedDate != null) {
                    put("processed_date", listOf(processedDate.toString()))
                }
                if (processedDateGt != null) {
                    put("processed_date.gt", listOf(processedDateGt.toString()))
                }
                if (processedDateGte != null) {
                    put("processed_date.gte", listOf(processedDateGte.toString()))
                }
                if (processedDateLt != null) {
                    put("processed_date.lt", listOf(processedDateLt.toString()))
                }
                if (processedDateLte != null) {
                    put("processed_date.lte", listOf(processedDateLte.toString()))
                }
                if (effectiveDate != null) {
                    put("effective_date", listOf(effectiveDate.toString()))
                }
                if (effectiveDateGt != null) {
                    put("effective_date.gt", listOf(effectiveDateGt.toString()))
                }
                if (effectiveDateGte != null) {
                    put("effective_date.gte", listOf(effectiveDateGte.toString()))
                }
                if (effectiveDateLt != null) {
                    put("effective_date.lt", listOf(effectiveDateLt.toString()))
                }
                if (effectiveDateLte != null) {
                    put("effective_date.lte", listOf(effectiveDateLte.toString()))
                }
                if (compositeTicker != null) {
                    put("composite_ticker", listOf(compositeTicker.toString()))
                }
                if (compositeTickerAnyOf != null) {
                    put("composite_ticker.any_of", listOf(compositeTickerAnyOf.toString()))
                }
                if (compositeTickerGt != null) {
                    put("composite_ticker.gt", listOf(compositeTickerGt.toString()))
                }
                if (compositeTickerGte != null) {
                    put("composite_ticker.gte", listOf(compositeTickerGte.toString()))
                }
                if (compositeTickerLt != null) {
                    put("composite_ticker.lt", listOf(compositeTickerLt.toString()))
                }
                if (compositeTickerLte != null) {
                    put("composite_ticker.lte", listOf(compositeTickerLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/etf-global/v1/fund-flows",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /etf-global/v1/profiles
     * 
     * ETF Global industry profile data containing comprehensive ETF metadata including financial metrics, operational details, and exposure information.
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param compositeTicker The stock ticker symbol used to identify this ETF product on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return GetEtfGlobalV1Profiles200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEtfGlobalV1Profiles(processedDate: kotlin.String? = null, processedDateGt: kotlin.String? = null, processedDateGte: kotlin.String? = null, processedDateLt: kotlin.String? = null, processedDateLte: kotlin.String? = null, effectiveDate: kotlin.String? = null, effectiveDateGt: kotlin.String? = null, effectiveDateGte: kotlin.String? = null, effectiveDateLt: kotlin.String? = null, effectiveDateLte: kotlin.String? = null, compositeTicker: kotlin.String? = null, compositeTickerAnyOf: kotlin.String? = null, compositeTickerGt: kotlin.String? = null, compositeTickerGte: kotlin.String? = null, compositeTickerLt: kotlin.String? = null, compositeTickerLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "composite_ticker.asc") : GetEtfGlobalV1Profiles200Response {
        val localVarResponse = getEtfGlobalV1ProfilesWithHttpInfo(processedDate = processedDate, processedDateGt = processedDateGt, processedDateGte = processedDateGte, processedDateLt = processedDateLt, processedDateLte = processedDateLte, effectiveDate = effectiveDate, effectiveDateGt = effectiveDateGt, effectiveDateGte = effectiveDateGte, effectiveDateLt = effectiveDateLt, effectiveDateLte = effectiveDateLte, compositeTicker = compositeTicker, compositeTickerAnyOf = compositeTickerAnyOf, compositeTickerGt = compositeTickerGt, compositeTickerGte = compositeTickerGte, compositeTickerLt = compositeTickerLt, compositeTickerLte = compositeTickerLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetEtfGlobalV1Profiles200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /etf-global/v1/profiles
     * 
     * ETF Global industry profile data containing comprehensive ETF metadata including financial metrics, operational details, and exposure information.
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param compositeTicker The stock ticker symbol used to identify this ETF product on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return ApiResponse<GetEtfGlobalV1Profiles200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEtfGlobalV1ProfilesWithHttpInfo(processedDate: kotlin.String?, processedDateGt: kotlin.String?, processedDateGte: kotlin.String?, processedDateLt: kotlin.String?, processedDateLte: kotlin.String?, effectiveDate: kotlin.String?, effectiveDateGt: kotlin.String?, effectiveDateGte: kotlin.String?, effectiveDateLt: kotlin.String?, effectiveDateLte: kotlin.String?, compositeTicker: kotlin.String?, compositeTickerAnyOf: kotlin.String?, compositeTickerGt: kotlin.String?, compositeTickerGte: kotlin.String?, compositeTickerLt: kotlin.String?, compositeTickerLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetEtfGlobalV1Profiles200Response?> {
        val localVariableConfig = getEtfGlobalV1ProfilesRequestConfig(processedDate = processedDate, processedDateGt = processedDateGt, processedDateGte = processedDateGte, processedDateLt = processedDateLt, processedDateLte = processedDateLte, effectiveDate = effectiveDate, effectiveDateGt = effectiveDateGt, effectiveDateGte = effectiveDateGte, effectiveDateLt = effectiveDateLt, effectiveDateLte = effectiveDateLte, compositeTicker = compositeTicker, compositeTickerAnyOf = compositeTickerAnyOf, compositeTickerGt = compositeTickerGt, compositeTickerGte = compositeTickerGte, compositeTickerLt = compositeTickerLt, compositeTickerLte = compositeTickerLte, limit = limit, sort = sort)

        return request<Unit, GetEtfGlobalV1Profiles200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEtfGlobalV1Profiles
     *
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param compositeTicker The stock ticker symbol used to identify this ETF product on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return RequestConfig
     */
    fun getEtfGlobalV1ProfilesRequestConfig(processedDate: kotlin.String?, processedDateGt: kotlin.String?, processedDateGte: kotlin.String?, processedDateLt: kotlin.String?, processedDateLte: kotlin.String?, effectiveDate: kotlin.String?, effectiveDateGt: kotlin.String?, effectiveDateGte: kotlin.String?, effectiveDateLt: kotlin.String?, effectiveDateLte: kotlin.String?, compositeTicker: kotlin.String?, compositeTickerAnyOf: kotlin.String?, compositeTickerGt: kotlin.String?, compositeTickerGte: kotlin.String?, compositeTickerLt: kotlin.String?, compositeTickerLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (processedDate != null) {
                    put("processed_date", listOf(processedDate.toString()))
                }
                if (processedDateGt != null) {
                    put("processed_date.gt", listOf(processedDateGt.toString()))
                }
                if (processedDateGte != null) {
                    put("processed_date.gte", listOf(processedDateGte.toString()))
                }
                if (processedDateLt != null) {
                    put("processed_date.lt", listOf(processedDateLt.toString()))
                }
                if (processedDateLte != null) {
                    put("processed_date.lte", listOf(processedDateLte.toString()))
                }
                if (effectiveDate != null) {
                    put("effective_date", listOf(effectiveDate.toString()))
                }
                if (effectiveDateGt != null) {
                    put("effective_date.gt", listOf(effectiveDateGt.toString()))
                }
                if (effectiveDateGte != null) {
                    put("effective_date.gte", listOf(effectiveDateGte.toString()))
                }
                if (effectiveDateLt != null) {
                    put("effective_date.lt", listOf(effectiveDateLt.toString()))
                }
                if (effectiveDateLte != null) {
                    put("effective_date.lte", listOf(effectiveDateLte.toString()))
                }
                if (compositeTicker != null) {
                    put("composite_ticker", listOf(compositeTicker.toString()))
                }
                if (compositeTickerAnyOf != null) {
                    put("composite_ticker.any_of", listOf(compositeTickerAnyOf.toString()))
                }
                if (compositeTickerGt != null) {
                    put("composite_ticker.gt", listOf(compositeTickerGt.toString()))
                }
                if (compositeTickerGte != null) {
                    put("composite_ticker.gte", listOf(compositeTickerGte.toString()))
                }
                if (compositeTickerLt != null) {
                    put("composite_ticker.lt", listOf(compositeTickerLt.toString()))
                }
                if (compositeTickerLte != null) {
                    put("composite_ticker.lte", listOf(compositeTickerLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/etf-global/v1/profiles",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /etf-global/v1/taxonomies
     * 
     * ETF Global taxonomy data containing detailed classification and categorization information for ETFs including investment strategy, methodology, and structural characteristics.
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param compositeTicker The stock ticker symbol used to identify this ETF product on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return GetEtfGlobalV1Taxonomies200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEtfGlobalV1Taxonomies(processedDate: kotlin.String? = null, processedDateGt: kotlin.String? = null, processedDateGte: kotlin.String? = null, processedDateLt: kotlin.String? = null, processedDateLte: kotlin.String? = null, effectiveDate: kotlin.String? = null, effectiveDateGt: kotlin.String? = null, effectiveDateGte: kotlin.String? = null, effectiveDateLt: kotlin.String? = null, effectiveDateLte: kotlin.String? = null, compositeTicker: kotlin.String? = null, compositeTickerAnyOf: kotlin.String? = null, compositeTickerGt: kotlin.String? = null, compositeTickerGte: kotlin.String? = null, compositeTickerLt: kotlin.String? = null, compositeTickerLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "composite_ticker.asc") : GetEtfGlobalV1Taxonomies200Response {
        val localVarResponse = getEtfGlobalV1TaxonomiesWithHttpInfo(processedDate = processedDate, processedDateGt = processedDateGt, processedDateGte = processedDateGte, processedDateLt = processedDateLt, processedDateLte = processedDateLte, effectiveDate = effectiveDate, effectiveDateGt = effectiveDateGt, effectiveDateGte = effectiveDateGte, effectiveDateLt = effectiveDateLt, effectiveDateLte = effectiveDateLte, compositeTicker = compositeTicker, compositeTickerAnyOf = compositeTickerAnyOf, compositeTickerGt = compositeTickerGt, compositeTickerGte = compositeTickerGte, compositeTickerLt = compositeTickerLt, compositeTickerLte = compositeTickerLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetEtfGlobalV1Taxonomies200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /etf-global/v1/taxonomies
     * 
     * ETF Global taxonomy data containing detailed classification and categorization information for ETFs including investment strategy, methodology, and structural characteristics.
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param compositeTicker The stock ticker symbol used to identify this ETF product on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return ApiResponse<GetEtfGlobalV1Taxonomies200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEtfGlobalV1TaxonomiesWithHttpInfo(processedDate: kotlin.String?, processedDateGt: kotlin.String?, processedDateGte: kotlin.String?, processedDateLt: kotlin.String?, processedDateLte: kotlin.String?, effectiveDate: kotlin.String?, effectiveDateGt: kotlin.String?, effectiveDateGte: kotlin.String?, effectiveDateLt: kotlin.String?, effectiveDateLte: kotlin.String?, compositeTicker: kotlin.String?, compositeTickerAnyOf: kotlin.String?, compositeTickerGt: kotlin.String?, compositeTickerGte: kotlin.String?, compositeTickerLt: kotlin.String?, compositeTickerLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetEtfGlobalV1Taxonomies200Response?> {
        val localVariableConfig = getEtfGlobalV1TaxonomiesRequestConfig(processedDate = processedDate, processedDateGt = processedDateGt, processedDateGte = processedDateGte, processedDateLt = processedDateLt, processedDateLte = processedDateLte, effectiveDate = effectiveDate, effectiveDateGt = effectiveDateGt, effectiveDateGte = effectiveDateGte, effectiveDateLt = effectiveDateLt, effectiveDateLte = effectiveDateLte, compositeTicker = compositeTicker, compositeTickerAnyOf = compositeTickerAnyOf, compositeTickerGt = compositeTickerGt, compositeTickerGte = compositeTickerGte, compositeTickerLt = compositeTickerLt, compositeTickerLte = compositeTickerLte, limit = limit, sort = sort)

        return request<Unit, GetEtfGlobalV1Taxonomies200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEtfGlobalV1Taxonomies
     *
     * @param processedDate The date showing when ETF Global received and processed the data. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param processedDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDate The date showing when the information was accurate or valid; some issuers, such as Vanguard, release their data on a delay, so the effective_date can be several weeks earlier than the processed_date. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param effectiveDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param compositeTicker The stock ticker symbol used to identify this ETF product on exchanges. (optional)
     * @param compositeTickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param compositeTickerGt Filter greater than the value. (optional)
     * @param compositeTickerGte Filter greater than or equal to the value. (optional)
     * @param compositeTickerLt Filter less than the value. (optional)
     * @param compositeTickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;composite_ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "composite_ticker.asc")
     * @return RequestConfig
     */
    fun getEtfGlobalV1TaxonomiesRequestConfig(processedDate: kotlin.String?, processedDateGt: kotlin.String?, processedDateGte: kotlin.String?, processedDateLt: kotlin.String?, processedDateLte: kotlin.String?, effectiveDate: kotlin.String?, effectiveDateGt: kotlin.String?, effectiveDateGte: kotlin.String?, effectiveDateLt: kotlin.String?, effectiveDateLte: kotlin.String?, compositeTicker: kotlin.String?, compositeTickerAnyOf: kotlin.String?, compositeTickerGt: kotlin.String?, compositeTickerGte: kotlin.String?, compositeTickerLt: kotlin.String?, compositeTickerLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (processedDate != null) {
                    put("processed_date", listOf(processedDate.toString()))
                }
                if (processedDateGt != null) {
                    put("processed_date.gt", listOf(processedDateGt.toString()))
                }
                if (processedDateGte != null) {
                    put("processed_date.gte", listOf(processedDateGte.toString()))
                }
                if (processedDateLt != null) {
                    put("processed_date.lt", listOf(processedDateLt.toString()))
                }
                if (processedDateLte != null) {
                    put("processed_date.lte", listOf(processedDateLte.toString()))
                }
                if (effectiveDate != null) {
                    put("effective_date", listOf(effectiveDate.toString()))
                }
                if (effectiveDateGt != null) {
                    put("effective_date.gt", listOf(effectiveDateGt.toString()))
                }
                if (effectiveDateGte != null) {
                    put("effective_date.gte", listOf(effectiveDateGte.toString()))
                }
                if (effectiveDateLt != null) {
                    put("effective_date.lt", listOf(effectiveDateLt.toString()))
                }
                if (effectiveDateLte != null) {
                    put("effective_date.lte", listOf(effectiveDateLte.toString()))
                }
                if (compositeTicker != null) {
                    put("composite_ticker", listOf(compositeTicker.toString()))
                }
                if (compositeTickerAnyOf != null) {
                    put("composite_ticker.any_of", listOf(compositeTickerAnyOf.toString()))
                }
                if (compositeTickerGt != null) {
                    put("composite_ticker.gt", listOf(compositeTickerGt.toString()))
                }
                if (compositeTickerGte != null) {
                    put("composite_ticker.gte", listOf(compositeTickerGte.toString()))
                }
                if (compositeTickerLt != null) {
                    put("composite_ticker.lt", listOf(compositeTickerLt.toString()))
                }
                if (compositeTickerLte != null) {
                    put("composite_ticker.lte", listOf(compositeTickerLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/etf-global/v1/taxonomies",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /vX/reference/tickers/{id}/events
     * Ticker Events
     * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
     * @param id Identifier of an asset, which can be a Ticker, CUSIP, or Composite FIGI. Specify a case-sensitive  ticker symbol (e.g. AAPL for Apple Inc). When provided a ticker, events for the entity currently  represented by that ticker are returned. To find events for entities previously associated with a  ticker, obtain the relevant identifier using the [Ticker Details Endpoint](https://massive.com/docs/rest/stocks/tickers/ticker-overview).
     * @param types A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types. (optional)
     * @return GetEvents200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getEvents(id: kotlin.String, types: kotlin.String? = null) : GetEvents200Response {
        val localVarResponse = getEventsWithHttpInfo(id = id, types = types)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetEvents200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vX/reference/tickers/{id}/events
     * Ticker Events
     * Get a timeline of events for the entity associated with the given ticker, CUSIP, or Composite FIGI.
     * @param id Identifier of an asset, which can be a Ticker, CUSIP, or Composite FIGI. Specify a case-sensitive  ticker symbol (e.g. AAPL for Apple Inc). When provided a ticker, events for the entity currently  represented by that ticker are returned. To find events for entities previously associated with a  ticker, obtain the relevant identifier using the [Ticker Details Endpoint](https://massive.com/docs/rest/stocks/tickers/ticker-overview).
     * @param types A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types. (optional)
     * @return ApiResponse<GetEvents200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getEventsWithHttpInfo(id: kotlin.String, types: kotlin.String?) : ApiResponse<GetEvents200Response?> {
        val localVariableConfig = getEventsRequestConfig(id = id, types = types)

        return request<Unit, GetEvents200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getEvents
     *
     * @param id Identifier of an asset, which can be a Ticker, CUSIP, or Composite FIGI. Specify a case-sensitive  ticker symbol (e.g. AAPL for Apple Inc). When provided a ticker, events for the entity currently  represented by that ticker are returned. To find events for entities previously associated with a  ticker, obtain the relevant identifier using the [Ticker Details Endpoint](https://massive.com/docs/rest/stocks/tickers/ticker-overview).
     * @param types A comma-separated list of the types of event to include. Currently ticker_change is the only supported event_type. Leave blank to return all supported event_types. (optional)
     * @return RequestConfig
     */
    fun getEventsRequestConfig(id: kotlin.String, types: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (types != null) {
                    put("types", listOf(types.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vX/reference/tickers/{id}/events".replace("{"+"id"+"}", encodeURIComponent(id.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /fed/v1/inflation
     * 
     * A table tracking inflation and price indices, including Consumer Price Index (CPI) and Personal Consumption Expenditures (PCE) metrics over time.
     * @param date Calendar date of the observation (YYYYMMDD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return GetFedV1Inflation200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFedV1Inflation(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.asc") : GetFedV1Inflation200Response {
        val localVarResponse = getFedV1InflationWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFedV1Inflation200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /fed/v1/inflation
     * 
     * A table tracking inflation and price indices, including Consumer Price Index (CPI) and Personal Consumption Expenditures (PCE) metrics over time.
     * @param date Calendar date of the observation (YYYYMMDD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return ApiResponse<GetFedV1Inflation200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFedV1InflationWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetFedV1Inflation200Response?> {
        val localVariableConfig = getFedV1InflationRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit, sort = sort)

        return request<Unit, GetFedV1Inflation200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFedV1Inflation
     *
     * @param date Calendar date of the observation (YYYYMMDD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return RequestConfig
     */
    fun getFedV1InflationRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/fed/v1/inflation",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /fed/v1/inflation-expectations
     * 
     * A table tracking inflation expectations from both market-based and economic model perspectives across different time horizons.
     * @param date Calendar date of the observation (YYYYMMDD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return GetFedV1InflationExpectations200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFedV1InflationExpectations(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.asc") : GetFedV1InflationExpectations200Response {
        val localVarResponse = getFedV1InflationExpectationsWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFedV1InflationExpectations200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /fed/v1/inflation-expectations
     * 
     * A table tracking inflation expectations from both market-based and economic model perspectives across different time horizons.
     * @param date Calendar date of the observation (YYYYMMDD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return ApiResponse<GetFedV1InflationExpectations200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFedV1InflationExpectationsWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetFedV1InflationExpectations200Response?> {
        val localVariableConfig = getFedV1InflationExpectationsRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit, sort = sort)

        return request<Unit, GetFedV1InflationExpectations200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFedV1InflationExpectations
     *
     * @param date Calendar date of the observation (YYYYMMDD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return RequestConfig
     */
    fun getFedV1InflationExpectationsRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/fed/v1/inflation-expectations",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /fed/v1/treasury-yields
     * 
     * A record of U.S. Treasury bond yields across various maturity periods, tracking historical interest rates from short-term to long-term government securities.
     * @param date Calendar date of the yield observation (YYYY-MM-DD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return GetFedV1TreasuryYields200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFedV1TreasuryYields(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.asc") : GetFedV1TreasuryYields200Response {
        val localVarResponse = getFedV1TreasuryYieldsWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFedV1TreasuryYields200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /fed/v1/treasury-yields
     * 
     * A record of U.S. Treasury bond yields across various maturity periods, tracking historical interest rates from short-term to long-term government securities.
     * @param date Calendar date of the yield observation (YYYY-MM-DD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return ApiResponse<GetFedV1TreasuryYields200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFedV1TreasuryYieldsWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetFedV1TreasuryYields200Response?> {
        val localVariableConfig = getFedV1TreasuryYieldsRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, limit = limit, sort = sort)

        return request<Unit, GetFedV1TreasuryYields200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFedV1TreasuryYields
     *
     * @param date Calendar date of the yield observation (YYYY-MM-DD). (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return RequestConfig
     */
    fun getFedV1TreasuryYieldsRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/fed/v1/treasury-yields",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetForexAggregates(val value: kotlin.String) {
         @Json(name = "second") second("second"),
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetForexAggregates(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/aggs/ticker/{forexTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a forex pair over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; minute and multiplier &#x3D; 5 then 5-minute bars will be returned. 
     * @param forexTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return GetCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexAggregates(forexTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetForexAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean? = null, sort: SortGetForexAggregates? = null, limit: kotlin.Int? = null) : GetCryptoAggregates200Response {
        val localVarResponse = getForexAggregatesWithHttpInfo(forexTicker = forexTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{forexTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a forex pair over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; minute and multiplier &#x3D; 5 then 5-minute bars will be returned. 
     * @param forexTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return ApiResponse<GetCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexAggregatesWithHttpInfo(forexTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetForexAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetForexAggregates?, limit: kotlin.Int?) : ApiResponse<GetCryptoAggregates200Response?> {
        val localVariableConfig = getForexAggregatesRequestConfig(forexTicker = forexTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return request<Unit, GetCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexAggregates
     *
     * @param forexTicker The ticker symbol of the currency pair.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return RequestConfig
     */
    fun getForexAggregatesRequestConfig(forexTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetForexAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetForexAggregates?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{forexTicker}/range/{multiplier}/{timespan}/{from}/{to}".replace("{"+"forexTicker"+"}", encodeURIComponent(forexTicker.toString())).replace("{"+"multiplier"+"}", encodeURIComponent(multiplier.toString())).replace("{"+"timespan"+"}", encodeURIComponent(timespan.value.toString())).replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter direction
     */
     enum class DirectionGetForexSnapshotDirection(val value: kotlin.String) {
         @Json(name = "gainers") gainers("gainers"),
         @Json(name = "losers") losers("losers");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/{direction}
     * Gainers/Losers
     * Get the current top 20 gainers or losers of the day in forex markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @return GetForexSnapshotTickers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexSnapshotDirection(direction: DirectionGetForexSnapshotDirection) : GetForexSnapshotTickers200Response {
        val localVarResponse = getForexSnapshotDirectionWithHttpInfo(direction = direction)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetForexSnapshotTickers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/{direction}
     * Gainers/Losers
     * Get the current top 20 gainers or losers of the day in forex markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @return ApiResponse<GetForexSnapshotTickers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexSnapshotDirectionWithHttpInfo(direction: DirectionGetForexSnapshotDirection) : ApiResponse<GetForexSnapshotTickers200Response?> {
        val localVariableConfig = getForexSnapshotDirectionRequestConfig(direction = direction)

        return request<Unit, GetForexSnapshotTickers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexSnapshotDirection
     *
     * @param direction The direction of the snapshot results to return. 
     * @return RequestConfig
     */
    fun getForexSnapshotDirectionRequestConfig(direction: DirectionGetForexSnapshotDirection) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/forex/{direction}".replace("{"+"direction"+"}", encodeURIComponent(direction.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/tickers/{ticker}
     * Ticker
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker The forex ticker.
     * @return GetForexSnapshotTicker200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexSnapshotTicker(ticker: kotlin.String) : GetForexSnapshotTicker200Response {
        val localVarResponse = getForexSnapshotTickerWithHttpInfo(ticker = ticker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetForexSnapshotTicker200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/tickers/{ticker}
     * Ticker
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for a single traded currency symbol. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. 
     * @param ticker The forex ticker.
     * @return ApiResponse<GetForexSnapshotTicker200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexSnapshotTickerWithHttpInfo(ticker: kotlin.String) : ApiResponse<GetForexSnapshotTicker200Response?> {
        val localVariableConfig = getForexSnapshotTickerRequestConfig(ticker = ticker)

        return request<Unit, GetForexSnapshotTicker200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexSnapshotTicker
     *
     * @param ticker The forex ticker.
     * @return RequestConfig
     */
    fun getForexSnapshotTickerRequestConfig(ticker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/forex/tickers/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/tickers
     * All Tickers
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers. (optional)
     * @return GetForexSnapshotTickers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexSnapshotTickers(tickers: kotlin.collections.List<kotlin.String>? = null) : GetForexSnapshotTickers200Response {
        val localVarResponse = getForexSnapshotTickersWithHttpInfo(tickers = tickers)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetForexSnapshotTickers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/global/markets/forex/tickers
     * All Tickers
     * Get the current minute, day, and previous days aggregate, as well as the last trade and quote for all traded forex symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 12am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers. (optional)
     * @return ApiResponse<GetForexSnapshotTickers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexSnapshotTickersWithHttpInfo(tickers: kotlin.collections.List<kotlin.String>?) : ApiResponse<GetForexSnapshotTickers200Response?> {
        val localVariableConfig = getForexSnapshotTickersRequestConfig(tickers = tickers)

        return request<Unit, GetForexSnapshotTickers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexSnapshotTickers
     *
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, C:EURUSD, C:GBPCAD, and C:AUDINR. Empty string defaults to querying all tickers. (optional)
     * @return RequestConfig
     */
    fun getForexSnapshotTickersRequestConfig(tickers: kotlin.collections.List<kotlin.String>?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tickers != null) {
                    put("tickers", toMultiValue(tickers.toList(), "multi"))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/global/markets/forex/tickers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /forex/v1/exchanges
     * 
     * Global foreign exchange (FX) trading venues and market infrastructure, including electronic trading platforms, banks, and other institutions facilitating currency pair trading worldwide.
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return GetForexV1Exchanges200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getForexV1Exchanges(limit: kotlin.Int? = 100) : GetForexV1Exchanges200Response {
        val localVarResponse = getForexV1ExchangesWithHttpInfo(limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetForexV1Exchanges200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /forex/v1/exchanges
     * 
     * Global foreign exchange (FX) trading venues and market infrastructure, including electronic trading platforms, banks, and other institutions facilitating currency pair trading worldwide.
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return ApiResponse<GetForexV1Exchanges200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getForexV1ExchangesWithHttpInfo(limit: kotlin.Int?) : ApiResponse<GetForexV1Exchanges200Response?> {
        val localVariableConfig = getForexV1ExchangesRequestConfig(limit = limit)

        return request<Unit, GetForexV1Exchanges200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getForexV1Exchanges
     *
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return RequestConfig
     */
    fun getForexV1ExchangesRequestConfig(limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/forex/v1/exchanges",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sort
     */
     enum class SortGetFuturesAggregates(val value: kotlin.String) {
         @Json(name = "window_start.asc") windowStartPeriodAsc("window_start.asc"),
         @Json(name = "window_start.desc") windowStartPeriodDesc("window_start.desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /futures/vX/aggs/{ticker}
     * Aggregates
     * Get aggregates for a contract in a given time range.
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @param resolution This sets the size of the aggregate windows. It accepts custom values that specify the granularity and the duration of the window. For example: 15mins, 30secs, 12hours, or 7days. There are maximum allowable candle sizes. For example, you can request \&quot;1min\&quot; to \&quot;59mins\&quot;, but after that you will need to use \&quot;1hr\&quot;. If you make a request for a candle size that is not supported, we will return a 400 \&quot;Bad Request - resolution value is not allowed.\&quot; (optional, default to "1day")
     * @param windowStart Specifies the start time of the aggregate (OHLC) candles you want returned (YYYY-MM-DD date or nanosecond Unix timestamp). How it works - If not provided, the API returns the most recent candles available, up to the limit you set. - If provided, the value determines which candle(s) to return. The timestamp or date is snapped to the start time of the matching candle interval. - You can use comparison operators to form ranges:   - &#x60;window_start.gte&#x60;  greater than or equal to   - &#x60;window_start.gt&#x60;  greater than   - &#x60;window_start.lte&#x60;  less than or equal to   - &#x60;window_start.lt&#x60;  less than  Examples 1. Most recent minute candles    &#x60;/vX/aggs/ESU5?resolution&#x3D;1min&amp;limit&#x3D;5&#x60;  2. Daily candle for August 5, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start&#x3D;2025-08-05&#x60;  3. Daily candles from July 131, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start.gte&#x3D;2025-07-01&amp;window_start.lte&#x3D;2025-07-31&#x60;  4. 1,000 one-second candles after a specific timestamp    &#x60;/vX/aggs/ESU5?resolution&#x3D;1sec&amp;window_start.gt&#x3D;1751409877000000000&amp;limit&#x3D;1000&#x60; (optional)
     * @param limit The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1). (optional, default to 1000)
     * @param windowStartGte Range by window_start. (optional)
     * @param windowStartGt Range by window_start. (optional)
     * @param windowStartLte Range by window_start. (optional)
     * @param windowStartLt Range by window_start. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to window_start.desc)
     * @return GetFuturesAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFuturesAggregates(ticker: kotlin.String, resolution: kotlin.String? = "1day", windowStart: kotlin.String? = null, limit: kotlin.Int? = 1000, windowStartGte: kotlin.String? = null, windowStartGt: kotlin.String? = null, windowStartLte: kotlin.String? = null, windowStartLt: kotlin.String? = null, sort: SortGetFuturesAggregates? = SortGetFuturesAggregates.windowStartPeriodDesc) : GetFuturesAggregates200Response {
        val localVarResponse = getFuturesAggregatesWithHttpInfo(ticker = ticker, resolution = resolution, windowStart = windowStart, limit = limit, windowStartGte = windowStartGte, windowStartGt = windowStartGt, windowStartLte = windowStartLte, windowStartLt = windowStartLt, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFuturesAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/aggs/{ticker}
     * Aggregates
     * Get aggregates for a contract in a given time range.
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @param resolution This sets the size of the aggregate windows. It accepts custom values that specify the granularity and the duration of the window. For example: 15mins, 30secs, 12hours, or 7days. There are maximum allowable candle sizes. For example, you can request \&quot;1min\&quot; to \&quot;59mins\&quot;, but after that you will need to use \&quot;1hr\&quot;. If you make a request for a candle size that is not supported, we will return a 400 \&quot;Bad Request - resolution value is not allowed.\&quot; (optional, default to "1day")
     * @param windowStart Specifies the start time of the aggregate (OHLC) candles you want returned (YYYY-MM-DD date or nanosecond Unix timestamp). How it works - If not provided, the API returns the most recent candles available, up to the limit you set. - If provided, the value determines which candle(s) to return. The timestamp or date is snapped to the start time of the matching candle interval. - You can use comparison operators to form ranges:   - &#x60;window_start.gte&#x60;  greater than or equal to   - &#x60;window_start.gt&#x60;  greater than   - &#x60;window_start.lte&#x60;  less than or equal to   - &#x60;window_start.lt&#x60;  less than  Examples 1. Most recent minute candles    &#x60;/vX/aggs/ESU5?resolution&#x3D;1min&amp;limit&#x3D;5&#x60;  2. Daily candle for August 5, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start&#x3D;2025-08-05&#x60;  3. Daily candles from July 131, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start.gte&#x3D;2025-07-01&amp;window_start.lte&#x3D;2025-07-31&#x60;  4. 1,000 one-second candles after a specific timestamp    &#x60;/vX/aggs/ESU5?resolution&#x3D;1sec&amp;window_start.gt&#x3D;1751409877000000000&amp;limit&#x3D;1000&#x60; (optional)
     * @param limit The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1). (optional, default to 1000)
     * @param windowStartGte Range by window_start. (optional)
     * @param windowStartGt Range by window_start. (optional)
     * @param windowStartLte Range by window_start. (optional)
     * @param windowStartLt Range by window_start. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to window_start.desc)
     * @return ApiResponse<GetFuturesAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFuturesAggregatesWithHttpInfo(ticker: kotlin.String, resolution: kotlin.String?, windowStart: kotlin.String?, limit: kotlin.Int?, windowStartGte: kotlin.String?, windowStartGt: kotlin.String?, windowStartLte: kotlin.String?, windowStartLt: kotlin.String?, sort: SortGetFuturesAggregates?) : ApiResponse<GetFuturesAggregates200Response?> {
        val localVariableConfig = getFuturesAggregatesRequestConfig(ticker = ticker, resolution = resolution, windowStart = windowStart, limit = limit, windowStartGte = windowStartGte, windowStartGt = windowStartGt, windowStartLte = windowStartLte, windowStartLt = windowStartLt, sort = sort)

        return request<Unit, GetFuturesAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFuturesAggregates
     *
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @param resolution This sets the size of the aggregate windows. It accepts custom values that specify the granularity and the duration of the window. For example: 15mins, 30secs, 12hours, or 7days. There are maximum allowable candle sizes. For example, you can request \&quot;1min\&quot; to \&quot;59mins\&quot;, but after that you will need to use \&quot;1hr\&quot;. If you make a request for a candle size that is not supported, we will return a 400 \&quot;Bad Request - resolution value is not allowed.\&quot; (optional, default to "1day")
     * @param windowStart Specifies the start time of the aggregate (OHLC) candles you want returned (YYYY-MM-DD date or nanosecond Unix timestamp). How it works - If not provided, the API returns the most recent candles available, up to the limit you set. - If provided, the value determines which candle(s) to return. The timestamp or date is snapped to the start time of the matching candle interval. - You can use comparison operators to form ranges:   - &#x60;window_start.gte&#x60;  greater than or equal to   - &#x60;window_start.gt&#x60;  greater than   - &#x60;window_start.lte&#x60;  less than or equal to   - &#x60;window_start.lt&#x60;  less than  Examples 1. Most recent minute candles    &#x60;/vX/aggs/ESU5?resolution&#x3D;1min&amp;limit&#x3D;5&#x60;  2. Daily candle for August 5, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start&#x3D;2025-08-05&#x60;  3. Daily candles from July 131, 2025    &#x60;/vX/aggs/ESU5?resolution&#x3D;1day&amp;window_start.gte&#x3D;2025-07-01&amp;window_start.lte&#x3D;2025-07-31&#x60;  4. 1,000 one-second candles after a specific timestamp    &#x60;/vX/aggs/ESU5?resolution&#x3D;1sec&amp;window_start.gt&#x3D;1751409877000000000&amp;limit&#x3D;1000&#x60; (optional)
     * @param limit The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1). (optional, default to 1000)
     * @param windowStartGte Range by window_start. (optional)
     * @param windowStartGt Range by window_start. (optional)
     * @param windowStartLte Range by window_start. (optional)
     * @param windowStartLt Range by window_start. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to window_start.desc)
     * @return RequestConfig
     */
    fun getFuturesAggregatesRequestConfig(ticker: kotlin.String, resolution: kotlin.String?, windowStart: kotlin.String?, limit: kotlin.Int?, windowStartGte: kotlin.String?, windowStartGt: kotlin.String?, windowStartLte: kotlin.String?, windowStartLt: kotlin.String?, sort: SortGetFuturesAggregates?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (resolution != null) {
                    put("resolution", listOf(resolution.toString()))
                }
                if (windowStart != null) {
                    put("window_start", listOf(windowStart.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (windowStartGte != null) {
                    put("window_start.gte", listOf(windowStartGte.toString()))
                }
                if (windowStartGt != null) {
                    put("window_start.gt", listOf(windowStartGt.toString()))
                }
                if (windowStartLte != null) {
                    put("window_start.lte", listOf(windowStartLte.toString()))
                }
                if (windowStartLt != null) {
                    put("window_start.lt", listOf(windowStartLt.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/aggs/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sort
     */
     enum class SortGetFuturesQuotes(val value: kotlin.String) {
         @Json(name = "timestamp.asc") timestampPeriodAsc("timestamp.asc"),
         @Json(name = "timestamp.desc") timestampPeriodDesc("timestamp.desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /futures/vX/quotes/{ticker}
     * Quotes
     * Get quotes for a contract in a given time range.
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param sessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format. (optional)
     * @param limit The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1). (optional, default to 1000)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param sessionEndDateGte Range by session_end_date. (optional)
     * @param sessionEndDateGt Range by session_end_date. (optional)
     * @param sessionEndDateLte Range by session_end_date. (optional)
     * @param sessionEndDateLt Range by session_end_date. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to timestamp.desc)
     * @return GetFuturesQuotes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFuturesQuotes(ticker: kotlin.String, timestamp: kotlin.String? = null, sessionEndDate: kotlin.String? = null, limit: kotlin.Int? = 1000, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null, sessionEndDateGte: kotlin.String? = null, sessionEndDateGt: kotlin.String? = null, sessionEndDateLte: kotlin.String? = null, sessionEndDateLt: kotlin.String? = null, sort: SortGetFuturesQuotes? = SortGetFuturesQuotes.timestampPeriodDesc) : GetFuturesQuotes200Response {
        val localVarResponse = getFuturesQuotesWithHttpInfo(ticker = ticker, timestamp = timestamp, sessionEndDate = sessionEndDate, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, sessionEndDateGte = sessionEndDateGte, sessionEndDateGt = sessionEndDateGt, sessionEndDateLte = sessionEndDateLte, sessionEndDateLt = sessionEndDateLt, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFuturesQuotes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/quotes/{ticker}
     * Quotes
     * Get quotes for a contract in a given time range.
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param sessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format. (optional)
     * @param limit The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1). (optional, default to 1000)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param sessionEndDateGte Range by session_end_date. (optional)
     * @param sessionEndDateGt Range by session_end_date. (optional)
     * @param sessionEndDateLte Range by session_end_date. (optional)
     * @param sessionEndDateLt Range by session_end_date. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to timestamp.desc)
     * @return ApiResponse<GetFuturesQuotes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFuturesQuotesWithHttpInfo(ticker: kotlin.String, timestamp: kotlin.String?, sessionEndDate: kotlin.String?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, sessionEndDateGte: kotlin.String?, sessionEndDateGt: kotlin.String?, sessionEndDateLte: kotlin.String?, sessionEndDateLt: kotlin.String?, sort: SortGetFuturesQuotes?) : ApiResponse<GetFuturesQuotes200Response?> {
        val localVariableConfig = getFuturesQuotesRequestConfig(ticker = ticker, timestamp = timestamp, sessionEndDate = sessionEndDate, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, sessionEndDateGte = sessionEndDateGte, sessionEndDateGt = sessionEndDateGt, sessionEndDateLte = sessionEndDateLte, sessionEndDateLt = sessionEndDateLt, sort = sort)

        return request<Unit, GetFuturesQuotes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFuturesQuotes
     *
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param sessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format. (optional)
     * @param limit The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1). (optional, default to 1000)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param sessionEndDateGte Range by session_end_date. (optional)
     * @param sessionEndDateGt Range by session_end_date. (optional)
     * @param sessionEndDateLte Range by session_end_date. (optional)
     * @param sessionEndDateLt Range by session_end_date. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to timestamp.desc)
     * @return RequestConfig
     */
    fun getFuturesQuotesRequestConfig(ticker: kotlin.String, timestamp: kotlin.String?, sessionEndDate: kotlin.String?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, sessionEndDateGte: kotlin.String?, sessionEndDateGt: kotlin.String?, sessionEndDateLte: kotlin.String?, sessionEndDateLt: kotlin.String?, sort: SortGetFuturesQuotes?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (sessionEndDate != null) {
                    put("session_end_date", listOf(sessionEndDate.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
                if (sessionEndDateGte != null) {
                    put("session_end_date.gte", listOf(sessionEndDateGte.toString()))
                }
                if (sessionEndDateGt != null) {
                    put("session_end_date.gt", listOf(sessionEndDateGt.toString()))
                }
                if (sessionEndDateLte != null) {
                    put("session_end_date.lte", listOf(sessionEndDateLte.toString()))
                }
                if (sessionEndDateLt != null) {
                    put("session_end_date.lt", listOf(sessionEndDateLt.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/quotes/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sort
     */
     enum class SortGetFuturesTrades(val value: kotlin.String) {
         @Json(name = "timestamp.asc") timestampPeriodAsc("timestamp.asc"),
         @Json(name = "timestamp.desc") timestampPeriodDesc("timestamp.desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /futures/vX/trades/{ticker}
     * Trades
     * Get trades for a contract in a given time range.
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param sessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format. (optional)
     * @param limit The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1). (optional, default to 1000)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param sessionEndDateGte Range by session_end_date. (optional)
     * @param sessionEndDateGt Range by session_end_date. (optional)
     * @param sessionEndDateLte Range by session_end_date. (optional)
     * @param sessionEndDateLt Range by session_end_date. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to timestamp.desc)
     * @return GetFuturesTrades200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFuturesTrades(ticker: kotlin.String, timestamp: kotlin.String? = null, sessionEndDate: kotlin.String? = null, limit: kotlin.Int? = 1000, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null, sessionEndDateGte: kotlin.String? = null, sessionEndDateGt: kotlin.String? = null, sessionEndDateLte: kotlin.String? = null, sessionEndDateLt: kotlin.String? = null, sort: SortGetFuturesTrades? = SortGetFuturesTrades.timestampPeriodDesc) : GetFuturesTrades200Response {
        val localVarResponse = getFuturesTradesWithHttpInfo(ticker = ticker, timestamp = timestamp, sessionEndDate = sessionEndDate, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, sessionEndDateGte = sessionEndDateGte, sessionEndDateGt = sessionEndDateGt, sessionEndDateLte = sessionEndDateLte, sessionEndDateLt = sessionEndDateLt, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFuturesTrades200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/trades/{ticker}
     * Trades
     * Get trades for a contract in a given time range.
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param sessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format. (optional)
     * @param limit The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1). (optional, default to 1000)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param sessionEndDateGte Range by session_end_date. (optional)
     * @param sessionEndDateGt Range by session_end_date. (optional)
     * @param sessionEndDateLte Range by session_end_date. (optional)
     * @param sessionEndDateLt Range by session_end_date. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to timestamp.desc)
     * @return ApiResponse<GetFuturesTrades200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFuturesTradesWithHttpInfo(ticker: kotlin.String, timestamp: kotlin.String?, sessionEndDate: kotlin.String?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, sessionEndDateGte: kotlin.String?, sessionEndDateGt: kotlin.String?, sessionEndDateLte: kotlin.String?, sessionEndDateLt: kotlin.String?, sort: SortGetFuturesTrades?) : ApiResponse<GetFuturesTrades200Response?> {
        val localVariableConfig = getFuturesTradesRequestConfig(ticker = ticker, timestamp = timestamp, sessionEndDate = sessionEndDate, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, sessionEndDateGte = sessionEndDateGte, sessionEndDateGt = sessionEndDateGt, sessionEndDateLte = sessionEndDateLte, sessionEndDateLt = sessionEndDateLt, sort = sort)

        return request<Unit, GetFuturesTrades200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFuturesTrades
     *
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., GCJ5 for the April 2025 gold contract).
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param sessionEndDate Also known as the trading date, the date of the end of the trading session, in YYYY-MM-DD format. (optional)
     * @param limit The number of results to return per page (default&#x3D;1000, maximum&#x3D;50000, minimum&#x3D;1). (optional, default to 1000)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param sessionEndDateGte Range by session_end_date. (optional)
     * @param sessionEndDateGt Range by session_end_date. (optional)
     * @param sessionEndDateLte Range by session_end_date. (optional)
     * @param sessionEndDateLt Range by session_end_date. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to timestamp.desc)
     * @return RequestConfig
     */
    fun getFuturesTradesRequestConfig(ticker: kotlin.String, timestamp: kotlin.String?, sessionEndDate: kotlin.String?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, sessionEndDateGte: kotlin.String?, sessionEndDateGt: kotlin.String?, sessionEndDateLte: kotlin.String?, sessionEndDateLt: kotlin.String?, sort: SortGetFuturesTrades?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (sessionEndDate != null) {
                    put("session_end_date", listOf(sessionEndDate.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
                if (sessionEndDateGte != null) {
                    put("session_end_date.gte", listOf(sessionEndDateGte.toString()))
                }
                if (sessionEndDateGt != null) {
                    put("session_end_date.gt", listOf(sessionEndDateGt.toString()))
                }
                if (sessionEndDateLte != null) {
                    put("session_end_date.lte", listOf(sessionEndDateLte.toString()))
                }
                if (sessionEndDateLt != null) {
                    put("session_end_date.lt", listOf(sessionEndDateLt.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/trades/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /futures/vX/contracts-new
     * futures_contracts_v1 API
     * The Contracts API provides a single source for discovering all listed futures contracts and retrieving complete contract specifications. You can query the full contract index with filters for product code, trade dates, active status, and date, returning key attributes such as ticker, first and last trade dates, days to maturity, exchange code, and order quantity limits in paginated form. The same API also returns the full specification for a single contract, including settlement dates, tick sizes, and other trading and risk related fields. Point-in-time lookups allow you to reconstruct the exact contract definition that applied on any given day.  Use Cases: Historical research, trading system integration, portfolio workflows, risk management.
     * @param date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about contracts for the specified day. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param productCode The identifier for the contract&#39;s product. (optional)
     * @param productCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param productCodeGt Filter greater than the value. (optional)
     * @param productCodeGte Filter greater than or equal to the value. (optional)
     * @param productCodeLt Filter less than the value. (optional)
     * @param productCodeLte Filter less than or equal to the value. (optional)
     * @param ticker The ticker for the contract. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param active The contract is still trading. Value must be &#39;true&#39;, &#39;false&#39;, &#39;1&#39; or &#39;0&#39;. (optional)
     * @param type The type of contract, one of &#39;single&#39; or &#39;combo&#39;. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param firstTradeDate The first date the contract trades. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDate The last date the contract trades. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;1000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;product_code&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "product_code.asc")
     * @return GetFuturesVXContractsNew200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFuturesVXContractsNew(date: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, productCode: kotlin.String? = null, productCodeAnyOf: kotlin.String? = null, productCodeGt: kotlin.String? = null, productCodeGte: kotlin.String? = null, productCodeLt: kotlin.String? = null, productCodeLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, active: kotlin.String? = null, type: kotlin.String? = null, typeAnyOf: kotlin.String? = null, typeGt: kotlin.String? = null, typeGte: kotlin.String? = null, typeLt: kotlin.String? = null, typeLte: kotlin.String? = null, firstTradeDate: kotlin.String? = null, firstTradeDateGt: kotlin.String? = null, firstTradeDateGte: kotlin.String? = null, firstTradeDateLt: kotlin.String? = null, firstTradeDateLte: kotlin.String? = null, lastTradeDate: kotlin.String? = null, lastTradeDateGt: kotlin.String? = null, lastTradeDateGte: kotlin.String? = null, lastTradeDateLt: kotlin.String? = null, lastTradeDateLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "product_code.asc") : GetFuturesVXContractsNew200Response {
        val localVarResponse = getFuturesVXContractsNewWithHttpInfo(date = date, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, productCode = productCode, productCodeAnyOf = productCodeAnyOf, productCodeGt = productCodeGt, productCodeGte = productCodeGte, productCodeLt = productCodeLt, productCodeLte = productCodeLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, active = active, type = type, typeAnyOf = typeAnyOf, typeGt = typeGt, typeGte = typeGte, typeLt = typeLt, typeLte = typeLte, firstTradeDate = firstTradeDate, firstTradeDateGt = firstTradeDateGt, firstTradeDateGte = firstTradeDateGte, firstTradeDateLt = firstTradeDateLt, firstTradeDateLte = firstTradeDateLte, lastTradeDate = lastTradeDate, lastTradeDateGt = lastTradeDateGt, lastTradeDateGte = lastTradeDateGte, lastTradeDateLt = lastTradeDateLt, lastTradeDateLte = lastTradeDateLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFuturesVXContractsNew200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/contracts-new
     * futures_contracts_v1 API
     * The Contracts API provides a single source for discovering all listed futures contracts and retrieving complete contract specifications. You can query the full contract index with filters for product code, trade dates, active status, and date, returning key attributes such as ticker, first and last trade dates, days to maturity, exchange code, and order quantity limits in paginated form. The same API also returns the full specification for a single contract, including settlement dates, tick sizes, and other trading and risk related fields. Point-in-time lookups allow you to reconstruct the exact contract definition that applied on any given day.  Use Cases: Historical research, trading system integration, portfolio workflows, risk management.
     * @param date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about contracts for the specified day. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param productCode The identifier for the contract&#39;s product. (optional)
     * @param productCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param productCodeGt Filter greater than the value. (optional)
     * @param productCodeGte Filter greater than or equal to the value. (optional)
     * @param productCodeLt Filter less than the value. (optional)
     * @param productCodeLte Filter less than or equal to the value. (optional)
     * @param ticker The ticker for the contract. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param active The contract is still trading. Value must be &#39;true&#39;, &#39;false&#39;, &#39;1&#39; or &#39;0&#39;. (optional)
     * @param type The type of contract, one of &#39;single&#39; or &#39;combo&#39;. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param firstTradeDate The first date the contract trades. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDate The last date the contract trades. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;1000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;product_code&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "product_code.asc")
     * @return ApiResponse<GetFuturesVXContractsNew200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFuturesVXContractsNewWithHttpInfo(date: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, productCode: kotlin.String?, productCodeAnyOf: kotlin.String?, productCodeGt: kotlin.String?, productCodeGte: kotlin.String?, productCodeLt: kotlin.String?, productCodeLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, active: kotlin.String?, type: kotlin.String?, typeAnyOf: kotlin.String?, typeGt: kotlin.String?, typeGte: kotlin.String?, typeLt: kotlin.String?, typeLte: kotlin.String?, firstTradeDate: kotlin.String?, firstTradeDateGt: kotlin.String?, firstTradeDateGte: kotlin.String?, firstTradeDateLt: kotlin.String?, firstTradeDateLte: kotlin.String?, lastTradeDate: kotlin.String?, lastTradeDateGt: kotlin.String?, lastTradeDateGte: kotlin.String?, lastTradeDateLt: kotlin.String?, lastTradeDateLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetFuturesVXContractsNew200Response?> {
        val localVariableConfig = getFuturesVXContractsNewRequestConfig(date = date, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, productCode = productCode, productCodeAnyOf = productCodeAnyOf, productCodeGt = productCodeGt, productCodeGte = productCodeGte, productCodeLt = productCodeLt, productCodeLte = productCodeLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, active = active, type = type, typeAnyOf = typeAnyOf, typeGt = typeGt, typeGte = typeGte, typeLt = typeLt, typeLte = typeLte, firstTradeDate = firstTradeDate, firstTradeDateGt = firstTradeDateGt, firstTradeDateGte = firstTradeDateGte, firstTradeDateLt = firstTradeDateLt, firstTradeDateLte = firstTradeDateLte, lastTradeDate = lastTradeDate, lastTradeDateGt = lastTradeDateGt, lastTradeDateGte = lastTradeDateGte, lastTradeDateLt = lastTradeDateLt, lastTradeDateLte = lastTradeDateLte, limit = limit, sort = sort)

        return request<Unit, GetFuturesVXContractsNew200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFuturesVXContractsNew
     *
     * @param date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about contracts for the specified day. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param productCode The identifier for the contract&#39;s product. (optional)
     * @param productCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param productCodeGt Filter greater than the value. (optional)
     * @param productCodeGte Filter greater than or equal to the value. (optional)
     * @param productCodeLt Filter less than the value. (optional)
     * @param productCodeLte Filter less than or equal to the value. (optional)
     * @param ticker The ticker for the contract. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param active The contract is still trading. Value must be &#39;true&#39;, &#39;false&#39;, &#39;1&#39; or &#39;0&#39;. (optional)
     * @param type The type of contract, one of &#39;single&#39; or &#39;combo&#39;. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param firstTradeDate The first date the contract trades. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param firstTradeDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDate The last date the contract trades. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param lastTradeDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;1000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;product_code&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "product_code.asc")
     * @return RequestConfig
     */
    fun getFuturesVXContractsNewRequestConfig(date: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, productCode: kotlin.String?, productCodeAnyOf: kotlin.String?, productCodeGt: kotlin.String?, productCodeGte: kotlin.String?, productCodeLt: kotlin.String?, productCodeLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, active: kotlin.String?, type: kotlin.String?, typeAnyOf: kotlin.String?, typeGt: kotlin.String?, typeGte: kotlin.String?, typeLt: kotlin.String?, typeLte: kotlin.String?, firstTradeDate: kotlin.String?, firstTradeDateGt: kotlin.String?, firstTradeDateGte: kotlin.String?, firstTradeDateLt: kotlin.String?, firstTradeDateLte: kotlin.String?, lastTradeDate: kotlin.String?, lastTradeDateGt: kotlin.String?, lastTradeDateGte: kotlin.String?, lastTradeDateLt: kotlin.String?, lastTradeDateLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (productCode != null) {
                    put("product_code", listOf(productCode.toString()))
                }
                if (productCodeAnyOf != null) {
                    put("product_code.any_of", listOf(productCodeAnyOf.toString()))
                }
                if (productCodeGt != null) {
                    put("product_code.gt", listOf(productCodeGt.toString()))
                }
                if (productCodeGte != null) {
                    put("product_code.gte", listOf(productCodeGte.toString()))
                }
                if (productCodeLt != null) {
                    put("product_code.lt", listOf(productCodeLt.toString()))
                }
                if (productCodeLte != null) {
                    put("product_code.lte", listOf(productCodeLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (typeAnyOf != null) {
                    put("type.any_of", listOf(typeAnyOf.toString()))
                }
                if (typeGt != null) {
                    put("type.gt", listOf(typeGt.toString()))
                }
                if (typeGte != null) {
                    put("type.gte", listOf(typeGte.toString()))
                }
                if (typeLt != null) {
                    put("type.lt", listOf(typeLt.toString()))
                }
                if (typeLte != null) {
                    put("type.lte", listOf(typeLte.toString()))
                }
                if (firstTradeDate != null) {
                    put("first_trade_date", listOf(firstTradeDate.toString()))
                }
                if (firstTradeDateGt != null) {
                    put("first_trade_date.gt", listOf(firstTradeDateGt.toString()))
                }
                if (firstTradeDateGte != null) {
                    put("first_trade_date.gte", listOf(firstTradeDateGte.toString()))
                }
                if (firstTradeDateLt != null) {
                    put("first_trade_date.lt", listOf(firstTradeDateLt.toString()))
                }
                if (firstTradeDateLte != null) {
                    put("first_trade_date.lte", listOf(firstTradeDateLte.toString()))
                }
                if (lastTradeDate != null) {
                    put("last_trade_date", listOf(lastTradeDate.toString()))
                }
                if (lastTradeDateGt != null) {
                    put("last_trade_date.gt", listOf(lastTradeDateGt.toString()))
                }
                if (lastTradeDateGte != null) {
                    put("last_trade_date.gte", listOf(lastTradeDateGte.toString()))
                }
                if (lastTradeDateLt != null) {
                    put("last_trade_date.lt", listOf(lastTradeDateLt.toString()))
                }
                if (lastTradeDateLte != null) {
                    put("last_trade_date.lte", listOf(lastTradeDateLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/contracts-new",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /futures/vX/exchanges
     * 
     * US futures exchanges and trading venues including major derivatives exchanges (CME, CBOT, NYMEX, COMEX) and other futures market infrastructure for commodity, financial, and other derivative contract trading.
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return GetFuturesVXExchanges200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFuturesVXExchanges(limit: kotlin.Int? = 100) : GetFuturesVXExchanges200Response {
        val localVarResponse = getFuturesVXExchangesWithHttpInfo(limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFuturesVXExchanges200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/exchanges
     * 
     * US futures exchanges and trading venues including major derivatives exchanges (CME, CBOT, NYMEX, COMEX) and other futures market infrastructure for commodity, financial, and other derivative contract trading.
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return ApiResponse<GetFuturesVXExchanges200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFuturesVXExchangesWithHttpInfo(limit: kotlin.Int?) : ApiResponse<GetFuturesVXExchanges200Response?> {
        val localVariableConfig = getFuturesVXExchangesRequestConfig(limit = limit)

        return request<Unit, GetFuturesVXExchanges200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFuturesVXExchanges
     *
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return RequestConfig
     */
    fun getFuturesVXExchangesRequestConfig(limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/exchanges",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /futures/vX/products-new
     * Futures Products API
     * The Products API is a unified source for discovering all supported futures products and retrieving full product specifications. It returns the complete product universe with product codes, names, exchange identifiers, sector and asset class classifications, product type, settlement method, and pricing and quotation details. You can filter by name, exchange, sector, asset class, product type, or date to capture the product set or product definition that existed at a specific point in time. It also retrieves the full specification for a single product, supporting accurate system configuration, analytics, trading workflows, and historical reconciliation.  Use Cases: Product specification, historical product checks, risk management, trading system integration.
     * @param name The full name of the product. (optional)
     * @param nameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param nameGt Filter greater than the value. (optional)
     * @param nameGte Filter greater than or equal to the value. (optional)
     * @param nameLt Filter less than the value. (optional)
     * @param nameLte Filter less than or equal to the value. (optional)
     * @param productCode The identifier for the product. (optional)
     * @param productCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param productCodeGt Filter greater than the value. (optional)
     * @param productCodeGte Filter greater than or equal to the value. (optional)
     * @param productCodeLt Filter less than the value. (optional)
     * @param productCodeLte Filter less than or equal to the value. (optional)
     * @param date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param sector The sector to which the product belongs. (optional)
     * @param sectorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param sectorGt Filter greater than the value. (optional)
     * @param sectorGte Filter greater than or equal to the value. (optional)
     * @param sectorLt Filter less than the value. (optional)
     * @param sectorLte Filter less than or equal to the value. (optional)
     * @param subSector The sub-sector to which the product belongs. (optional)
     * @param subSectorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param subSectorGt Filter greater than the value. (optional)
     * @param subSectorGte Filter greater than or equal to the value. (optional)
     * @param subSectorLt Filter less than the value. (optional)
     * @param subSectorLte Filter less than or equal to the value. (optional)
     * @param assetClass The asset class to which the product belongs. (optional)
     * @param assetClassAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param assetClassGt Filter greater than the value. (optional)
     * @param assetClassGte Filter greater than or equal to the value. (optional)
     * @param assetClassLt Filter less than the value. (optional)
     * @param assetClassLte Filter less than or equal to the value. (optional)
     * @param assetSubClass The asset sub-class to which the product belongs. (optional)
     * @param assetSubClassAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param assetSubClassGt Filter greater than the value. (optional)
     * @param assetSubClassGte Filter greater than or equal to the value. (optional)
     * @param assetSubClassLt Filter less than the value. (optional)
     * @param assetSubClassLte Filter less than or equal to the value. (optional)
     * @param type The type of product, one of &#39;single&#39; or &#39;combo&#39;. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return GetFuturesVXProductsNew200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFuturesVXProductsNew(name: kotlin.String? = null, nameAnyOf: kotlin.String? = null, nameGt: kotlin.String? = null, nameGte: kotlin.String? = null, nameLt: kotlin.String? = null, nameLte: kotlin.String? = null, productCode: kotlin.String? = null, productCodeAnyOf: kotlin.String? = null, productCodeGt: kotlin.String? = null, productCodeGte: kotlin.String? = null, productCodeLt: kotlin.String? = null, productCodeLte: kotlin.String? = null, date: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, sector: kotlin.String? = null, sectorAnyOf: kotlin.String? = null, sectorGt: kotlin.String? = null, sectorGte: kotlin.String? = null, sectorLt: kotlin.String? = null, sectorLte: kotlin.String? = null, subSector: kotlin.String? = null, subSectorAnyOf: kotlin.String? = null, subSectorGt: kotlin.String? = null, subSectorGte: kotlin.String? = null, subSectorLt: kotlin.String? = null, subSectorLte: kotlin.String? = null, assetClass: kotlin.String? = null, assetClassAnyOf: kotlin.String? = null, assetClassGt: kotlin.String? = null, assetClassGte: kotlin.String? = null, assetClassLt: kotlin.String? = null, assetClassLte: kotlin.String? = null, assetSubClass: kotlin.String? = null, assetSubClassAnyOf: kotlin.String? = null, assetSubClassGt: kotlin.String? = null, assetSubClassGte: kotlin.String? = null, assetSubClassLt: kotlin.String? = null, assetSubClassLte: kotlin.String? = null, type: kotlin.String? = null, typeAnyOf: kotlin.String? = null, typeGt: kotlin.String? = null, typeGte: kotlin.String? = null, typeLt: kotlin.String? = null, typeLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.asc") : GetFuturesVXProductsNew200Response {
        val localVarResponse = getFuturesVXProductsNewWithHttpInfo(name = name, nameAnyOf = nameAnyOf, nameGt = nameGt, nameGte = nameGte, nameLt = nameLt, nameLte = nameLte, productCode = productCode, productCodeAnyOf = productCodeAnyOf, productCodeGt = productCodeGt, productCodeGte = productCodeGte, productCodeLt = productCodeLt, productCodeLte = productCodeLte, date = date, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, sector = sector, sectorAnyOf = sectorAnyOf, sectorGt = sectorGt, sectorGte = sectorGte, sectorLt = sectorLt, sectorLte = sectorLte, subSector = subSector, subSectorAnyOf = subSectorAnyOf, subSectorGt = subSectorGt, subSectorGte = subSectorGte, subSectorLt = subSectorLt, subSectorLte = subSectorLte, assetClass = assetClass, assetClassAnyOf = assetClassAnyOf, assetClassGt = assetClassGt, assetClassGte = assetClassGte, assetClassLt = assetClassLt, assetClassLte = assetClassLte, assetSubClass = assetSubClass, assetSubClassAnyOf = assetSubClassAnyOf, assetSubClassGt = assetSubClassGt, assetSubClassGte = assetSubClassGte, assetSubClassLt = assetSubClassLt, assetSubClassLte = assetSubClassLte, type = type, typeAnyOf = typeAnyOf, typeGt = typeGt, typeGte = typeGte, typeLt = typeLt, typeLte = typeLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFuturesVXProductsNew200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/products-new
     * Futures Products API
     * The Products API is a unified source for discovering all supported futures products and retrieving full product specifications. It returns the complete product universe with product codes, names, exchange identifiers, sector and asset class classifications, product type, settlement method, and pricing and quotation details. You can filter by name, exchange, sector, asset class, product type, or date to capture the product set or product definition that existed at a specific point in time. It also retrieves the full specification for a single product, supporting accurate system configuration, analytics, trading workflows, and historical reconciliation.  Use Cases: Product specification, historical product checks, risk management, trading system integration.
     * @param name The full name of the product. (optional)
     * @param nameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param nameGt Filter greater than the value. (optional)
     * @param nameGte Filter greater than or equal to the value. (optional)
     * @param nameLt Filter less than the value. (optional)
     * @param nameLte Filter less than or equal to the value. (optional)
     * @param productCode The identifier for the product. (optional)
     * @param productCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param productCodeGt Filter greater than the value. (optional)
     * @param productCodeGte Filter greater than or equal to the value. (optional)
     * @param productCodeLt Filter less than the value. (optional)
     * @param productCodeLte Filter less than or equal to the value. (optional)
     * @param date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param sector The sector to which the product belongs. (optional)
     * @param sectorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param sectorGt Filter greater than the value. (optional)
     * @param sectorGte Filter greater than or equal to the value. (optional)
     * @param sectorLt Filter less than the value. (optional)
     * @param sectorLte Filter less than or equal to the value. (optional)
     * @param subSector The sub-sector to which the product belongs. (optional)
     * @param subSectorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param subSectorGt Filter greater than the value. (optional)
     * @param subSectorGte Filter greater than or equal to the value. (optional)
     * @param subSectorLt Filter less than the value. (optional)
     * @param subSectorLte Filter less than or equal to the value. (optional)
     * @param assetClass The asset class to which the product belongs. (optional)
     * @param assetClassAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param assetClassGt Filter greater than the value. (optional)
     * @param assetClassGte Filter greater than or equal to the value. (optional)
     * @param assetClassLt Filter less than the value. (optional)
     * @param assetClassLte Filter less than or equal to the value. (optional)
     * @param assetSubClass The asset sub-class to which the product belongs. (optional)
     * @param assetSubClassAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param assetSubClassGt Filter greater than the value. (optional)
     * @param assetSubClassGte Filter greater than or equal to the value. (optional)
     * @param assetSubClassLt Filter less than the value. (optional)
     * @param assetSubClassLte Filter less than or equal to the value. (optional)
     * @param type The type of product, one of &#39;single&#39; or &#39;combo&#39;. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return ApiResponse<GetFuturesVXProductsNew200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFuturesVXProductsNewWithHttpInfo(name: kotlin.String?, nameAnyOf: kotlin.String?, nameGt: kotlin.String?, nameGte: kotlin.String?, nameLt: kotlin.String?, nameLte: kotlin.String?, productCode: kotlin.String?, productCodeAnyOf: kotlin.String?, productCodeGt: kotlin.String?, productCodeGte: kotlin.String?, productCodeLt: kotlin.String?, productCodeLte: kotlin.String?, date: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, sector: kotlin.String?, sectorAnyOf: kotlin.String?, sectorGt: kotlin.String?, sectorGte: kotlin.String?, sectorLt: kotlin.String?, sectorLte: kotlin.String?, subSector: kotlin.String?, subSectorAnyOf: kotlin.String?, subSectorGt: kotlin.String?, subSectorGte: kotlin.String?, subSectorLt: kotlin.String?, subSectorLte: kotlin.String?, assetClass: kotlin.String?, assetClassAnyOf: kotlin.String?, assetClassGt: kotlin.String?, assetClassGte: kotlin.String?, assetClassLt: kotlin.String?, assetClassLte: kotlin.String?, assetSubClass: kotlin.String?, assetSubClassAnyOf: kotlin.String?, assetSubClassGt: kotlin.String?, assetSubClassGte: kotlin.String?, assetSubClassLt: kotlin.String?, assetSubClassLte: kotlin.String?, type: kotlin.String?, typeAnyOf: kotlin.String?, typeGt: kotlin.String?, typeGte: kotlin.String?, typeLt: kotlin.String?, typeLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetFuturesVXProductsNew200Response?> {
        val localVariableConfig = getFuturesVXProductsNewRequestConfig(name = name, nameAnyOf = nameAnyOf, nameGt = nameGt, nameGte = nameGte, nameLt = nameLt, nameLte = nameLte, productCode = productCode, productCodeAnyOf = productCodeAnyOf, productCodeGt = productCodeGt, productCodeGte = productCodeGte, productCodeLt = productCodeLt, productCodeLte = productCodeLte, date = date, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, sector = sector, sectorAnyOf = sectorAnyOf, sectorGt = sectorGt, sectorGte = sectorGte, sectorLt = sectorLt, sectorLte = sectorLte, subSector = subSector, subSectorAnyOf = subSectorAnyOf, subSectorGt = subSectorGt, subSectorGte = subSectorGte, subSectorLt = subSectorLt, subSectorLte = subSectorLte, assetClass = assetClass, assetClassAnyOf = assetClassAnyOf, assetClassGt = assetClassGt, assetClassGte = assetClassGte, assetClassLt = assetClassLt, assetClassLte = assetClassLte, assetSubClass = assetSubClass, assetSubClassAnyOf = assetSubClassAnyOf, assetSubClassGt = assetSubClassGt, assetSubClassGte = assetSubClassGte, assetSubClassLt = assetSubClassLt, assetSubClassLte = assetSubClassLte, type = type, typeAnyOf = typeAnyOf, typeGt = typeGt, typeGte = typeGte, typeLt = typeLt, typeLte = typeLte, limit = limit, sort = sort)

        return request<Unit, GetFuturesVXProductsNew200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFuturesVXProductsNew
     *
     * @param name The full name of the product. (optional)
     * @param nameAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param nameGt Filter greater than the value. (optional)
     * @param nameGte Filter greater than or equal to the value. (optional)
     * @param nameLt Filter less than the value. (optional)
     * @param nameLte Filter less than or equal to the value. (optional)
     * @param productCode The identifier for the product. (optional)
     * @param productCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param productCodeGt Filter greater than the value. (optional)
     * @param productCodeGte Filter greater than or equal to the value. (optional)
     * @param productCodeLt Filter less than the value. (optional)
     * @param productCodeLte Filter less than or equal to the value. (optional)
     * @param date A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param dateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param sector The sector to which the product belongs. (optional)
     * @param sectorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param sectorGt Filter greater than the value. (optional)
     * @param sectorGte Filter greater than or equal to the value. (optional)
     * @param sectorLt Filter less than the value. (optional)
     * @param sectorLte Filter less than or equal to the value. (optional)
     * @param subSector The sub-sector to which the product belongs. (optional)
     * @param subSectorAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param subSectorGt Filter greater than the value. (optional)
     * @param subSectorGte Filter greater than or equal to the value. (optional)
     * @param subSectorLt Filter less than the value. (optional)
     * @param subSectorLte Filter less than or equal to the value. (optional)
     * @param assetClass The asset class to which the product belongs. (optional)
     * @param assetClassAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param assetClassGt Filter greater than the value. (optional)
     * @param assetClassGte Filter greater than or equal to the value. (optional)
     * @param assetClassLt Filter less than the value. (optional)
     * @param assetClassLte Filter less than or equal to the value. (optional)
     * @param assetSubClass The asset sub-class to which the product belongs. (optional)
     * @param assetSubClassAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param assetSubClassGt Filter greater than the value. (optional)
     * @param assetSubClassGte Filter greater than or equal to the value. (optional)
     * @param assetSubClassLt Filter less than the value. (optional)
     * @param assetSubClassLte Filter less than or equal to the value. (optional)
     * @param type The type of product, one of &#39;single&#39; or &#39;combo&#39;. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "date.asc")
     * @return RequestConfig
     */
    fun getFuturesVXProductsNewRequestConfig(name: kotlin.String?, nameAnyOf: kotlin.String?, nameGt: kotlin.String?, nameGte: kotlin.String?, nameLt: kotlin.String?, nameLte: kotlin.String?, productCode: kotlin.String?, productCodeAnyOf: kotlin.String?, productCodeGt: kotlin.String?, productCodeGte: kotlin.String?, productCodeLt: kotlin.String?, productCodeLte: kotlin.String?, date: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, sector: kotlin.String?, sectorAnyOf: kotlin.String?, sectorGt: kotlin.String?, sectorGte: kotlin.String?, sectorLt: kotlin.String?, sectorLte: kotlin.String?, subSector: kotlin.String?, subSectorAnyOf: kotlin.String?, subSectorGt: kotlin.String?, subSectorGte: kotlin.String?, subSectorLt: kotlin.String?, subSectorLte: kotlin.String?, assetClass: kotlin.String?, assetClassAnyOf: kotlin.String?, assetClassGt: kotlin.String?, assetClassGte: kotlin.String?, assetClassLt: kotlin.String?, assetClassLte: kotlin.String?, assetSubClass: kotlin.String?, assetSubClassAnyOf: kotlin.String?, assetSubClassGt: kotlin.String?, assetSubClassGte: kotlin.String?, assetSubClassLt: kotlin.String?, assetSubClassLte: kotlin.String?, type: kotlin.String?, typeAnyOf: kotlin.String?, typeGt: kotlin.String?, typeGte: kotlin.String?, typeLt: kotlin.String?, typeLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (nameAnyOf != null) {
                    put("name.any_of", listOf(nameAnyOf.toString()))
                }
                if (nameGt != null) {
                    put("name.gt", listOf(nameGt.toString()))
                }
                if (nameGte != null) {
                    put("name.gte", listOf(nameGte.toString()))
                }
                if (nameLt != null) {
                    put("name.lt", listOf(nameLt.toString()))
                }
                if (nameLte != null) {
                    put("name.lte", listOf(nameLte.toString()))
                }
                if (productCode != null) {
                    put("product_code", listOf(productCode.toString()))
                }
                if (productCodeAnyOf != null) {
                    put("product_code.any_of", listOf(productCodeAnyOf.toString()))
                }
                if (productCodeGt != null) {
                    put("product_code.gt", listOf(productCodeGt.toString()))
                }
                if (productCodeGte != null) {
                    put("product_code.gte", listOf(productCodeGte.toString()))
                }
                if (productCodeLt != null) {
                    put("product_code.lt", listOf(productCodeLt.toString()))
                }
                if (productCodeLte != null) {
                    put("product_code.lte", listOf(productCodeLte.toString()))
                }
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (sector != null) {
                    put("sector", listOf(sector.toString()))
                }
                if (sectorAnyOf != null) {
                    put("sector.any_of", listOf(sectorAnyOf.toString()))
                }
                if (sectorGt != null) {
                    put("sector.gt", listOf(sectorGt.toString()))
                }
                if (sectorGte != null) {
                    put("sector.gte", listOf(sectorGte.toString()))
                }
                if (sectorLt != null) {
                    put("sector.lt", listOf(sectorLt.toString()))
                }
                if (sectorLte != null) {
                    put("sector.lte", listOf(sectorLte.toString()))
                }
                if (subSector != null) {
                    put("sub_sector", listOf(subSector.toString()))
                }
                if (subSectorAnyOf != null) {
                    put("sub_sector.any_of", listOf(subSectorAnyOf.toString()))
                }
                if (subSectorGt != null) {
                    put("sub_sector.gt", listOf(subSectorGt.toString()))
                }
                if (subSectorGte != null) {
                    put("sub_sector.gte", listOf(subSectorGte.toString()))
                }
                if (subSectorLt != null) {
                    put("sub_sector.lt", listOf(subSectorLt.toString()))
                }
                if (subSectorLte != null) {
                    put("sub_sector.lte", listOf(subSectorLte.toString()))
                }
                if (assetClass != null) {
                    put("asset_class", listOf(assetClass.toString()))
                }
                if (assetClassAnyOf != null) {
                    put("asset_class.any_of", listOf(assetClassAnyOf.toString()))
                }
                if (assetClassGt != null) {
                    put("asset_class.gt", listOf(assetClassGt.toString()))
                }
                if (assetClassGte != null) {
                    put("asset_class.gte", listOf(assetClassGte.toString()))
                }
                if (assetClassLt != null) {
                    put("asset_class.lt", listOf(assetClassLt.toString()))
                }
                if (assetClassLte != null) {
                    put("asset_class.lte", listOf(assetClassLte.toString()))
                }
                if (assetSubClass != null) {
                    put("asset_sub_class", listOf(assetSubClass.toString()))
                }
                if (assetSubClassAnyOf != null) {
                    put("asset_sub_class.any_of", listOf(assetSubClassAnyOf.toString()))
                }
                if (assetSubClassGt != null) {
                    put("asset_sub_class.gt", listOf(assetSubClassGt.toString()))
                }
                if (assetSubClassGte != null) {
                    put("asset_sub_class.gte", listOf(assetSubClassGte.toString()))
                }
                if (assetSubClassLt != null) {
                    put("asset_sub_class.lt", listOf(assetSubClassLt.toString()))
                }
                if (assetSubClassLte != null) {
                    put("asset_sub_class.lte", listOf(assetSubClassLte.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (typeAnyOf != null) {
                    put("type.any_of", listOf(typeAnyOf.toString()))
                }
                if (typeGt != null) {
                    put("type.gt", listOf(typeGt.toString()))
                }
                if (typeGte != null) {
                    put("type.gte", listOf(typeGte.toString()))
                }
                if (typeLt != null) {
                    put("type.lt", listOf(typeLt.toString()))
                }
                if (typeLte != null) {
                    put("type.lte", listOf(typeLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/products-new",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /futures/vX/snapshot
     * futures_snapshot_v1 API
     * Retrieve a snapshot of the most recent futures contract data.
     * @param productCode The code for the contracts&#39; underlying product. (optional)
     * @param productCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param productCodeGt Filter greater than the value. (optional)
     * @param productCodeGte Filter greater than or equal to the value. (optional)
     * @param productCodeLt Filter less than the value. (optional)
     * @param productCodeLte Filter less than or equal to the value. (optional)
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., ESZ24 for the December 2024 S&amp;P 500 E-mini contract). (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return GetFuturesVXSnapshot200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getFuturesVXSnapshot(productCode: kotlin.String? = null, productCodeAnyOf: kotlin.String? = null, productCodeGt: kotlin.String? = null, productCodeGte: kotlin.String? = null, productCodeLt: kotlin.String? = null, productCodeLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "ticker.asc") : GetFuturesVXSnapshot200Response {
        val localVarResponse = getFuturesVXSnapshotWithHttpInfo(productCode = productCode, productCodeAnyOf = productCodeAnyOf, productCodeGt = productCodeGt, productCodeGte = productCodeGte, productCodeLt = productCodeLt, productCodeLte = productCodeLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetFuturesVXSnapshot200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/snapshot
     * futures_snapshot_v1 API
     * Retrieve a snapshot of the most recent futures contract data.
     * @param productCode The code for the contracts&#39; underlying product. (optional)
     * @param productCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param productCodeGt Filter greater than the value. (optional)
     * @param productCodeGte Filter greater than or equal to the value. (optional)
     * @param productCodeLt Filter less than the value. (optional)
     * @param productCodeLte Filter less than or equal to the value. (optional)
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., ESZ24 for the December 2024 S&amp;P 500 E-mini contract). (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return ApiResponse<GetFuturesVXSnapshot200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getFuturesVXSnapshotWithHttpInfo(productCode: kotlin.String?, productCodeAnyOf: kotlin.String?, productCodeGt: kotlin.String?, productCodeGte: kotlin.String?, productCodeLt: kotlin.String?, productCodeLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetFuturesVXSnapshot200Response?> {
        val localVariableConfig = getFuturesVXSnapshotRequestConfig(productCode = productCode, productCodeAnyOf = productCodeAnyOf, productCodeGt = productCodeGt, productCodeGte = productCodeGte, productCodeLt = productCodeLt, productCodeLte = productCodeLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, limit = limit, sort = sort)

        return request<Unit, GetFuturesVXSnapshot200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getFuturesVXSnapshot
     *
     * @param productCode The code for the contracts&#39; underlying product. (optional)
     * @param productCodeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param productCodeGt Filter greater than the value. (optional)
     * @param productCodeGte Filter greater than or equal to the value. (optional)
     * @param productCodeLt Filter less than the value. (optional)
     * @param productCodeLte Filter less than or equal to the value. (optional)
     * @param ticker The futures contract identifier, including the base symbol and contract expiration (e.g., ESZ24 for the December 2024 S&amp;P 500 E-mini contract). (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return RequestConfig
     */
    fun getFuturesVXSnapshotRequestConfig(productCode: kotlin.String?, productCodeAnyOf: kotlin.String?, productCodeGt: kotlin.String?, productCodeGte: kotlin.String?, productCodeLt: kotlin.String?, productCodeLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (productCode != null) {
                    put("product_code", listOf(productCode.toString()))
                }
                if (productCodeAnyOf != null) {
                    put("product_code.any_of", listOf(productCodeAnyOf.toString()))
                }
                if (productCodeGt != null) {
                    put("product_code.gt", listOf(productCodeGt.toString()))
                }
                if (productCodeGte != null) {
                    put("product_code.gte", listOf(productCodeGte.toString()))
                }
                if (productCodeLt != null) {
                    put("product_code.lt", listOf(productCodeLt.toString()))
                }
                if (productCodeLte != null) {
                    put("product_code.lte", listOf(productCodeLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/snapshot",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/grouped/locale/global/market/crypto/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetGroupedCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGroupedCryptoAggregates(date: kotlin.String, adjusted: kotlin.Boolean? = null) : GetGroupedCryptoAggregates200Response {
        val localVarResponse = getGroupedCryptoAggregatesWithHttpInfo(date = date, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetGroupedCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/grouped/locale/global/market/crypto/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire cryptocurrency markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetGroupedCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGroupedCryptoAggregatesWithHttpInfo(date: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetGroupedCryptoAggregates200Response?> {
        val localVariableConfig = getGroupedCryptoAggregatesRequestConfig(date = date, adjusted = adjusted)

        return request<Unit, GetGroupedCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGroupedCryptoAggregates
     *
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getGroupedCryptoAggregatesRequestConfig(date: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/grouped/locale/global/market/crypto/{date}".replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/grouped/locale/global/market/fx/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetGroupedCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGroupedForexAggregates(date: kotlin.String, adjusted: kotlin.Boolean? = null) : GetGroupedCryptoAggregates200Response {
        val localVarResponse = getGroupedForexAggregatesWithHttpInfo(date = date, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetGroupedCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/grouped/locale/global/market/fx/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire forex markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetGroupedCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGroupedForexAggregatesWithHttpInfo(date: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetGroupedCryptoAggregates200Response?> {
        val localVariableConfig = getGroupedForexAggregatesRequestConfig(date = date, adjusted = adjusted)

        return request<Unit, GetGroupedCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGroupedForexAggregates
     *
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getGroupedForexAggregatesRequestConfig(date: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/grouped/locale/global/market/fx/{date}".replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/grouped/locale/us/market/stocks/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return GetGroupedStocksAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getGroupedStocksAggregates(date: kotlin.String, adjusted: kotlin.Boolean? = null, includeOtc: kotlin.Boolean? = null) : GetGroupedStocksAggregates200Response {
        val localVarResponse = getGroupedStocksAggregatesWithHttpInfo(date = date, adjusted = adjusted, includeOtc = includeOtc)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetGroupedStocksAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/grouped/locale/us/market/stocks/{date}
     * Grouped Daily (Bars)
     * Get the daily open, high, low, and close (OHLC) for the entire stocks/equities markets. 
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return ApiResponse<GetGroupedStocksAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getGroupedStocksAggregatesWithHttpInfo(date: kotlin.String, adjusted: kotlin.Boolean?, includeOtc: kotlin.Boolean?) : ApiResponse<GetGroupedStocksAggregates200Response?> {
        val localVariableConfig = getGroupedStocksAggregatesRequestConfig(date = date, adjusted = adjusted, includeOtc = includeOtc)

        return request<Unit, GetGroupedStocksAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getGroupedStocksAggregates
     *
     * @param date The beginning date for the aggregate window.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return RequestConfig
     */
    fun getGroupedStocksAggregatesRequestConfig(date: kotlin.String, adjusted: kotlin.Boolean?, includeOtc: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (includeOtc != null) {
                    put("include_otc", listOf(includeOtc.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/grouped/locale/us/market/stocks/{date}".replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetIndicesAggregates(val value: kotlin.String) {
         @Json(name = "second") second("second"),
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetIndicesAggregates(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/aggs/ticker/{indicesTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for an index over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; minute and multiplier &#x3D; 5 then 5-minute bars will be returned. 
     * @param indicesTicker The ticker symbol of Index.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return GetPreviousIndicesAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndicesAggregates(indicesTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetIndicesAggregates, from: kotlin.String, to: kotlin.String, sort: SortGetIndicesAggregates? = null, limit: kotlin.Int? = null) : GetPreviousIndicesAggregates200Response {
        val localVarResponse = getIndicesAggregatesWithHttpInfo(indicesTicker = indicesTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, sort = sort, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetPreviousIndicesAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{indicesTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for an index over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; minute and multiplier &#x3D; 5 then 5-minute bars will be returned. 
     * @param indicesTicker The ticker symbol of Index.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return ApiResponse<GetPreviousIndicesAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndicesAggregatesWithHttpInfo(indicesTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetIndicesAggregates, from: kotlin.String, to: kotlin.String, sort: SortGetIndicesAggregates?, limit: kotlin.Int?) : ApiResponse<GetPreviousIndicesAggregates200Response?> {
        val localVariableConfig = getIndicesAggregatesRequestConfig(indicesTicker = indicesTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, sort = sort, limit = limit)

        return request<Unit, GetPreviousIndicesAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndicesAggregates
     *
     * @param indicesTicker The ticker symbol of Index.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return RequestConfig
     */
    fun getIndicesAggregatesRequestConfig(indicesTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetIndicesAggregates, from: kotlin.String, to: kotlin.String, sort: SortGetIndicesAggregates?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{indicesTicker}/range/{multiplier}/{timespan}/{from}/{to}".replace("{"+"indicesTicker"+"}", encodeURIComponent(indicesTicker.toString())).replace("{"+"multiplier"+"}", encodeURIComponent(multiplier.toString())).replace("{"+"timespan"+"}", encodeURIComponent(timespan.value.toString())).replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/open-close/{indicesTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours values of a index symbol on a certain date. 
     * @param indicesTicker The ticker symbol of Index.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @return GetIndicesOpenClose200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndicesOpenClose(indicesTicker: kotlin.String, date: kotlin.String) : GetIndicesOpenClose200Response {
        val localVarResponse = getIndicesOpenCloseWithHttpInfo(indicesTicker = indicesTicker, date = date)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetIndicesOpenClose200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/open-close/{indicesTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours values of a index symbol on a certain date. 
     * @param indicesTicker The ticker symbol of Index.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @return ApiResponse<GetIndicesOpenClose200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndicesOpenCloseWithHttpInfo(indicesTicker: kotlin.String, date: kotlin.String) : ApiResponse<GetIndicesOpenClose200Response?> {
        val localVariableConfig = getIndicesOpenCloseRequestConfig(indicesTicker = indicesTicker, date = date)

        return request<Unit, GetIndicesOpenClose200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndicesOpenClose
     *
     * @param indicesTicker The ticker symbol of Index.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @return RequestConfig
     */
    fun getIndicesOpenCloseRequestConfig(indicesTicker: kotlin.String, date: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/open-close/{indicesTicker}/{date}".replace("{"+"indicesTicker"+"}", encodeURIComponent(indicesTicker.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderGetIndicesSnapshot(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetIndicesSnapshot(val value: kotlin.String) {
         @Json(name = "ticker") ticker("ticker");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/snapshot/indices
     * Indices Snapshot
     * Get a Snapshot of indices data for said tickers
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return GetIndicesSnapshot200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getIndicesSnapshot(tickerAnyOf: kotlin.String? = null, ticker: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, order: OrderGetIndicesSnapshot? = null, limit: kotlin.Int? = 10, sort: SortGetIndicesSnapshot? = SortGetIndicesSnapshot.ticker) : GetIndicesSnapshot200Response {
        val localVarResponse = getIndicesSnapshotWithHttpInfo(tickerAnyOf = tickerAnyOf, ticker = ticker, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetIndicesSnapshot200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/snapshot/indices
     * Indices Snapshot
     * Get a Snapshot of indices data for said tickers
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ApiResponse<GetIndicesSnapshot200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getIndicesSnapshotWithHttpInfo(tickerAnyOf: kotlin.String?, ticker: kotlin.String?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, order: OrderGetIndicesSnapshot?, limit: kotlin.Int?, sort: SortGetIndicesSnapshot?) : ApiResponse<GetIndicesSnapshot200Response?> {
        val localVariableConfig = getIndicesSnapshotRequestConfig(tickerAnyOf = tickerAnyOf, ticker = ticker, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetIndicesSnapshot200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getIndicesSnapshot
     *
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return RequestConfig
     */
    fun getIndicesSnapshotRequestConfig(tickerAnyOf: kotlin.String?, ticker: kotlin.String?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, order: OrderGetIndicesSnapshot?, limit: kotlin.Int?, sort: SortGetIndicesSnapshot?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/snapshot/indices",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/last/crypto/{from}/{to}
     * Last Trade for a Crypto Pair
     * Get the last trade tick for a cryptocurrency pair.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return GetLastCryptoTrade200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLastCryptoTrade(from: kotlin.String, to: kotlin.String) : GetLastCryptoTrade200Response {
        val localVarResponse = getLastCryptoTradeWithHttpInfo(from = from, to = to)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetLastCryptoTrade200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/last/crypto/{from}/{to}
     * Last Trade for a Crypto Pair
     * Get the last trade tick for a cryptocurrency pair.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return ApiResponse<GetLastCryptoTrade200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLastCryptoTradeWithHttpInfo(from: kotlin.String, to: kotlin.String) : ApiResponse<GetLastCryptoTrade200Response?> {
        val localVariableConfig = getLastCryptoTradeRequestConfig(from = from, to = to)

        return request<Unit, GetLastCryptoTrade200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLastCryptoTrade
     *
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return RequestConfig
     */
    fun getLastCryptoTradeRequestConfig(from: kotlin.String, to: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/last/crypto/{from}/{to}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/last_quote/currencies/{from}/{to}
     * Last Quote for a Currency Pair
     * Get the last quote tick for a forex currency pair.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return GetLastCurrencyQuote200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLastCurrencyQuote(from: kotlin.String, to: kotlin.String) : GetLastCurrencyQuote200Response {
        val localVarResponse = getLastCurrencyQuoteWithHttpInfo(from = from, to = to)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetLastCurrencyQuote200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/last_quote/currencies/{from}/{to}
     * Last Quote for a Currency Pair
     * Get the last quote tick for a forex currency pair.
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return ApiResponse<GetLastCurrencyQuote200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLastCurrencyQuoteWithHttpInfo(from: kotlin.String, to: kotlin.String) : ApiResponse<GetLastCurrencyQuote200Response?> {
        val localVariableConfig = getLastCurrencyQuoteRequestConfig(from = from, to = to)

        return request<Unit, GetLastCurrencyQuote200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLastCurrencyQuote
     *
     * @param from The \&quot;from\&quot; symbol of the pair.
     * @param to The \&quot;to\&quot; symbol of the pair.
     * @return RequestConfig
     */
    fun getLastCurrencyQuoteRequestConfig(from: kotlin.String, to: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/last_quote/currencies/{from}/{to}".replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/last/nbbo/{stocksTicker}
     * Last Quote
     * Get the most recent NBBO (Quote) tick for a given stock.
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return GetLastStocksQuote200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLastStocksQuote(stocksTicker: kotlin.String) : GetLastStocksQuote200Response {
        val localVarResponse = getLastStocksQuoteWithHttpInfo(stocksTicker = stocksTicker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetLastStocksQuote200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/last/nbbo/{stocksTicker}
     * Last Quote
     * Get the most recent NBBO (Quote) tick for a given stock.
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return ApiResponse<GetLastStocksQuote200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLastStocksQuoteWithHttpInfo(stocksTicker: kotlin.String) : ApiResponse<GetLastStocksQuote200Response?> {
        val localVariableConfig = getLastStocksQuoteRequestConfig(stocksTicker = stocksTicker)

        return request<Unit, GetLastStocksQuote200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLastStocksQuote
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return RequestConfig
     */
    fun getLastStocksQuoteRequestConfig(stocksTicker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/last/nbbo/{stocksTicker}".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/last/trade/{stocksTicker}
     * Last Trade
     * Get the most recent trade for a given stock.
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return GetLastStocksTrade200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getLastStocksTrade(stocksTicker: kotlin.String) : GetLastStocksTrade200Response {
        val localVarResponse = getLastStocksTradeWithHttpInfo(stocksTicker = stocksTicker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetLastStocksTrade200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/last/trade/{stocksTicker}
     * Last Trade
     * Get the most recent trade for a given stock.
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return ApiResponse<GetLastStocksTrade200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getLastStocksTradeWithHttpInfo(stocksTicker: kotlin.String) : ApiResponse<GetLastStocksTrade200Response?> {
        val localVariableConfig = getLastStocksTradeRequestConfig(stocksTicker = stocksTicker)

        return request<Unit, GetLastStocksTrade200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getLastStocksTrade
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return RequestConfig
     */
    fun getLastStocksTradeRequestConfig(stocksTicker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/last/trade/{stocksTicker}".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/marketstatus/upcoming
     * Market Holidays
     * Get upcoming market holidays and their open/close times.
     * @return kotlin.collections.List<GetMarketHolidays200ResponseInner>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMarketHolidays() : kotlin.collections.List<GetMarketHolidays200ResponseInner> {
        val localVarResponse = getMarketHolidaysWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as kotlin.collections.List<GetMarketHolidays200ResponseInner>
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/marketstatus/upcoming
     * Market Holidays
     * Get upcoming market holidays and their open/close times.
     * @return ApiResponse<kotlin.collections.List<GetMarketHolidays200ResponseInner>?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMarketHolidaysWithHttpInfo() : ApiResponse<kotlin.collections.List<GetMarketHolidays200ResponseInner>?> {
        val localVariableConfig = getMarketHolidaysRequestConfig()

        return request<Unit, kotlin.collections.List<GetMarketHolidays200ResponseInner>>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMarketHolidays
     *
     * @return RequestConfig
     */
    fun getMarketHolidaysRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/marketstatus/upcoming",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/marketstatus/now
     * Market Status
     * Get the current trading status of the exchanges and overall financial markets.
     * @return GetMarketStatus200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getMarketStatus() : GetMarketStatus200Response {
        val localVarResponse = getMarketStatusWithHttpInfo()

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetMarketStatus200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/marketstatus/now
     * Market Status
     * Get the current trading status of the exchanges and overall financial markets.
     * @return ApiResponse<GetMarketStatus200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getMarketStatusWithHttpInfo() : ApiResponse<GetMarketStatus200Response?> {
        val localVariableConfig = getMarketStatusRequestConfig()

        return request<Unit, GetMarketStatus200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getMarketStatus
     *
     * @return RequestConfig
     */
    fun getMarketStatusRequestConfig() : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/marketstatus/now",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v3/snapshot/options/{underlyingAsset}/{optionContract}
     * Option Contract
     * Get the snapshot of an option contract for a stock equity.
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param optionContract The option contract identifier.
     * @return GetOptionContract200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionContract(underlyingAsset: kotlin.String, optionContract: kotlin.String) : GetOptionContract200Response {
        val localVarResponse = getOptionContractWithHttpInfo(underlyingAsset = underlyingAsset, optionContract = optionContract)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionContract200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/snapshot/options/{underlyingAsset}/{optionContract}
     * Option Contract
     * Get the snapshot of an option contract for a stock equity.
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param optionContract The option contract identifier.
     * @return ApiResponse<GetOptionContract200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionContractWithHttpInfo(underlyingAsset: kotlin.String, optionContract: kotlin.String) : ApiResponse<GetOptionContract200Response?> {
        val localVariableConfig = getOptionContractRequestConfig(underlyingAsset = underlyingAsset, optionContract = optionContract)

        return request<Unit, GetOptionContract200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionContract
     *
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param optionContract The option contract identifier.
     * @return RequestConfig
     */
    fun getOptionContractRequestConfig(underlyingAsset: kotlin.String, optionContract: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/snapshot/options/{underlyingAsset}/{optionContract}".replace("{"+"underlyingAsset"+"}", encodeURIComponent(underlyingAsset.toString())).replace("{"+"optionContract"+"}", encodeURIComponent(optionContract.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetOptionsAggregates(val value: kotlin.String) {
         @Json(name = "second") second("second"),
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetOptionsAggregates(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/aggs/ticker/{optionsTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for an option contract over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; minute and multiplier &#x3D; 5 then 5-minute bars will be returned. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return GetCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsAggregates(optionsTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetOptionsAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean? = null, sort: SortGetOptionsAggregates? = null, limit: kotlin.Int? = null) : GetCryptoAggregates200Response {
        val localVarResponse = getOptionsAggregatesWithHttpInfo(optionsTicker = optionsTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{optionsTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for an option contract over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; minute and multiplier &#x3D; 5 then 5-minute bars will be returned. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return ApiResponse<GetCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsAggregatesWithHttpInfo(optionsTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetOptionsAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetOptionsAggregates?, limit: kotlin.Int?) : ApiResponse<GetCryptoAggregates200Response?> {
        val localVariableConfig = getOptionsAggregatesRequestConfig(optionsTicker = optionsTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return request<Unit, GetCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsAggregates
     *
     * @param optionsTicker The ticker symbol of the options contract.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return RequestConfig
     */
    fun getOptionsAggregatesRequestConfig(optionsTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetOptionsAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetOptionsAggregates?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{optionsTicker}/range/{multiplier}/{timespan}/{from}/{to}".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())).replace("{"+"multiplier"+"}", encodeURIComponent(multiplier.toString())).replace("{"+"timespan"+"}", encodeURIComponent(timespan.value.toString())).replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter contractType
     */
     enum class ContractTypeGetOptionsChain(val value: kotlin.String) {
         @Json(name = "call") call("call"),
         @Json(name = "put") put("put");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetOptionsChain(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetOptionsChain(val value: kotlin.String) {
         @Json(name = "ticker") ticker("ticker"),
         @Json(name = "expiration_date") expirationDate("expiration_date"),
         @Json(name = "strike_price") strikePrice("strike_price");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/snapshot/options/{underlyingAsset}
     * Options Chain
     * Get the snapshot of all options contracts for an underlying ticker.
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return GetOptionsChain200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsChain(underlyingAsset: kotlin.String, strikePrice: java.math.BigDecimal? = null, expirationDate: kotlin.String? = null, contractType: ContractTypeGetOptionsChain? = null, strikePriceGte: java.math.BigDecimal? = null, strikePriceGt: java.math.BigDecimal? = null, strikePriceLte: java.math.BigDecimal? = null, strikePriceLt: java.math.BigDecimal? = null, expirationDateGte: kotlin.String? = null, expirationDateGt: kotlin.String? = null, expirationDateLte: kotlin.String? = null, expirationDateLt: kotlin.String? = null, order: OrderGetOptionsChain? = null, limit: kotlin.Int? = 10, sort: SortGetOptionsChain? = SortGetOptionsChain.ticker) : GetOptionsChain200Response {
        val localVarResponse = getOptionsChainWithHttpInfo(underlyingAsset = underlyingAsset, strikePrice = strikePrice, expirationDate = expirationDate, contractType = contractType, strikePriceGte = strikePriceGte, strikePriceGt = strikePriceGt, strikePriceLte = strikePriceLte, strikePriceLt = strikePriceLt, expirationDateGte = expirationDateGte, expirationDateGt = expirationDateGt, expirationDateLte = expirationDateLte, expirationDateLt = expirationDateLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionsChain200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/snapshot/options/{underlyingAsset}
     * Options Chain
     * Get the snapshot of all options contracts for an underlying ticker.
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ApiResponse<GetOptionsChain200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsChainWithHttpInfo(underlyingAsset: kotlin.String, strikePrice: java.math.BigDecimal?, expirationDate: kotlin.String?, contractType: ContractTypeGetOptionsChain?, strikePriceGte: java.math.BigDecimal?, strikePriceGt: java.math.BigDecimal?, strikePriceLte: java.math.BigDecimal?, strikePriceLt: java.math.BigDecimal?, expirationDateGte: kotlin.String?, expirationDateGt: kotlin.String?, expirationDateLte: kotlin.String?, expirationDateLt: kotlin.String?, order: OrderGetOptionsChain?, limit: kotlin.Int?, sort: SortGetOptionsChain?) : ApiResponse<GetOptionsChain200Response?> {
        val localVariableConfig = getOptionsChainRequestConfig(underlyingAsset = underlyingAsset, strikePrice = strikePrice, expirationDate = expirationDate, contractType = contractType, strikePriceGte = strikePriceGte, strikePriceGt = strikePriceGt, strikePriceLte = strikePriceLte, strikePriceLt = strikePriceLt, expirationDateGte = expirationDateGte, expirationDateGt = expirationDateGt, expirationDateLte = expirationDateLte, expirationDateLt = expirationDateLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetOptionsChain200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsChain
     *
     * @param underlyingAsset The underlying ticker symbol of the option contract.
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return RequestConfig
     */
    fun getOptionsChainRequestConfig(underlyingAsset: kotlin.String, strikePrice: java.math.BigDecimal?, expirationDate: kotlin.String?, contractType: ContractTypeGetOptionsChain?, strikePriceGte: java.math.BigDecimal?, strikePriceGt: java.math.BigDecimal?, strikePriceLte: java.math.BigDecimal?, strikePriceLt: java.math.BigDecimal?, expirationDateGte: kotlin.String?, expirationDateGt: kotlin.String?, expirationDateLte: kotlin.String?, expirationDateLt: kotlin.String?, order: OrderGetOptionsChain?, limit: kotlin.Int?, sort: SortGetOptionsChain?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (strikePrice != null) {
                    put("strike_price", listOf(strikePrice.toString()))
                }
                if (expirationDate != null) {
                    put("expiration_date", listOf(expirationDate.toString()))
                }
                if (contractType != null) {
                    put("contract_type", listOf(contractType.value))
                }
                if (strikePriceGte != null) {
                    put("strike_price.gte", listOf(strikePriceGte.toString()))
                }
                if (strikePriceGt != null) {
                    put("strike_price.gt", listOf(strikePriceGt.toString()))
                }
                if (strikePriceLte != null) {
                    put("strike_price.lte", listOf(strikePriceLte.toString()))
                }
                if (strikePriceLt != null) {
                    put("strike_price.lt", listOf(strikePriceLt.toString()))
                }
                if (expirationDateGte != null) {
                    put("expiration_date.gte", listOf(expirationDateGte.toString()))
                }
                if (expirationDateGt != null) {
                    put("expiration_date.gt", listOf(expirationDateGt.toString()))
                }
                if (expirationDateLte != null) {
                    put("expiration_date.lte", listOf(expirationDateLte.toString()))
                }
                if (expirationDateLt != null) {
                    put("expiration_date.lt", listOf(expirationDateLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/snapshot/options/{underlyingAsset}".replace("{"+"underlyingAsset"+"}", encodeURIComponent(underlyingAsset.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v3/reference/options/contracts/{options_ticker}
     * Options Contract
     * Get an options contract
     * @param optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://massive.com/blog/how-to-read-a-stock-options-ticker/).
     * @param asOf Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @return GetOptionsContract200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsContract(optionsTicker: kotlin.String, asOf: kotlin.String? = null) : GetOptionsContract200Response {
        val localVarResponse = getOptionsContractWithHttpInfo(optionsTicker = optionsTicker, asOf = asOf)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionsContract200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/options/contracts/{options_ticker}
     * Options Contract
     * Get an options contract
     * @param optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://massive.com/blog/how-to-read-a-stock-options-ticker/).
     * @param asOf Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @return ApiResponse<GetOptionsContract200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsContractWithHttpInfo(optionsTicker: kotlin.String, asOf: kotlin.String?) : ApiResponse<GetOptionsContract200Response?> {
        val localVariableConfig = getOptionsContractRequestConfig(optionsTicker = optionsTicker, asOf = asOf)

        return request<Unit, GetOptionsContract200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsContract
     *
     * @param optionsTicker Query for a contract by options ticker. You can learn more about the structure of options tickers [here](https://massive.com/blog/how-to-read-a-stock-options-ticker/).
     * @param asOf Specify a point in time for the contract as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @return RequestConfig
     */
    fun getOptionsContractRequestConfig(optionsTicker: kotlin.String, asOf: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (asOf != null) {
                    put("as_of", listOf(asOf.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/options/contracts/{options_ticker}".replace("{"+"options_ticker"+"}", encodeURIComponent(optionsTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/open-close/{optionsTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours prices of an options contract on a certain date. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetOptionsOpenClose200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsOpenClose(optionsTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean? = null) : GetOptionsOpenClose200Response {
        val localVarResponse = getOptionsOpenCloseWithHttpInfo(optionsTicker = optionsTicker, date = date, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionsOpenClose200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/open-close/{optionsTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours prices of an options contract on a certain date. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetOptionsOpenClose200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsOpenCloseWithHttpInfo(optionsTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : ApiResponse<GetOptionsOpenClose200Response?> {
        val localVariableConfig = getOptionsOpenCloseRequestConfig(optionsTicker = optionsTicker, date = date, adjusted = adjusted)

        return request<Unit, GetOptionsOpenClose200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsOpenClose
     *
     * @param optionsTicker The ticker symbol of the options contract.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getOptionsOpenCloseRequestConfig(optionsTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/open-close/{optionsTicker}/{date}".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /options/v1/exchanges
     * 
     * US options exchanges and trading venues including traditional options exchanges (CBOE, ISE, etc.), Securities Information Processors (SIP), and other options market infrastructure for derivatives trading.
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return GetOptionsV1Exchanges200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getOptionsV1Exchanges(limit: kotlin.Int? = 100) : GetOptionsV1Exchanges200Response {
        val localVarResponse = getOptionsV1ExchangesWithHttpInfo(limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionsV1Exchanges200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /options/v1/exchanges
     * 
     * US options exchanges and trading venues including traditional options exchanges (CBOE, ISE, etc.), Securities Information Processors (SIP), and other options market infrastructure for derivatives trading.
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return ApiResponse<GetOptionsV1Exchanges200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getOptionsV1ExchangesWithHttpInfo(limit: kotlin.Int?) : ApiResponse<GetOptionsV1Exchanges200Response?> {
        val localVariableConfig = getOptionsV1ExchangesRequestConfig(limit = limit)

        return request<Unit, GetOptionsV1Exchanges200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getOptionsV1Exchanges
     *
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return RequestConfig
     */
    fun getOptionsV1ExchangesRequestConfig(limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/options/v1/exchanges",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/ticker/{cryptoTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetPreviousCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPreviousCryptoAggregates(cryptoTicker: kotlin.String, adjusted: kotlin.Boolean? = null) : GetPreviousCryptoAggregates200Response {
        val localVarResponse = getPreviousCryptoAggregatesWithHttpInfo(cryptoTicker = cryptoTicker, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetPreviousCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{cryptoTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified cryptocurrency pair. 
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetPreviousCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPreviousCryptoAggregatesWithHttpInfo(cryptoTicker: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetPreviousCryptoAggregates200Response?> {
        val localVariableConfig = getPreviousCryptoAggregatesRequestConfig(cryptoTicker = cryptoTicker, adjusted = adjusted)

        return request<Unit, GetPreviousCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPreviousCryptoAggregates
     *
     * @param cryptoTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getPreviousCryptoAggregatesRequestConfig(cryptoTicker: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{cryptoTicker}/prev".replace("{"+"cryptoTicker"+"}", encodeURIComponent(cryptoTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/ticker/{forexTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified forex pair. 
     * @param forexTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetPreviousForexAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPreviousForexAggregates(forexTicker: kotlin.String, adjusted: kotlin.Boolean? = null) : GetPreviousForexAggregates200Response {
        val localVarResponse = getPreviousForexAggregatesWithHttpInfo(forexTicker = forexTicker, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetPreviousForexAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{forexTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified forex pair. 
     * @param forexTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetPreviousForexAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPreviousForexAggregatesWithHttpInfo(forexTicker: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetPreviousForexAggregates200Response?> {
        val localVariableConfig = getPreviousForexAggregatesRequestConfig(forexTicker = forexTicker, adjusted = adjusted)

        return request<Unit, GetPreviousForexAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPreviousForexAggregates
     *
     * @param forexTicker The ticker symbol of the currency pair.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getPreviousForexAggregatesRequestConfig(forexTicker: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{forexTicker}/prev".replace("{"+"forexTicker"+"}", encodeURIComponent(forexTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/ticker/{indicesTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified index. 
     * @param indicesTicker The ticker symbol of Index.
     * @return GetPreviousIndicesAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPreviousIndicesAggregates(indicesTicker: kotlin.String) : GetPreviousIndicesAggregates200Response {
        val localVarResponse = getPreviousIndicesAggregatesWithHttpInfo(indicesTicker = indicesTicker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetPreviousIndicesAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{indicesTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified index. 
     * @param indicesTicker The ticker symbol of Index.
     * @return ApiResponse<GetPreviousIndicesAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPreviousIndicesAggregatesWithHttpInfo(indicesTicker: kotlin.String) : ApiResponse<GetPreviousIndicesAggregates200Response?> {
        val localVariableConfig = getPreviousIndicesAggregatesRequestConfig(indicesTicker = indicesTicker)

        return request<Unit, GetPreviousIndicesAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPreviousIndicesAggregates
     *
     * @param indicesTicker The ticker symbol of Index.
     * @return RequestConfig
     */
    fun getPreviousIndicesAggregatesRequestConfig(indicesTicker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{indicesTicker}/prev".replace("{"+"indicesTicker"+"}", encodeURIComponent(indicesTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/ticker/{optionsTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified option contract. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPreviousOptionsAggregates(optionsTicker: kotlin.String, adjusted: kotlin.Boolean? = null) : GetCryptoAggregates200Response {
        val localVarResponse = getPreviousOptionsAggregatesWithHttpInfo(optionsTicker = optionsTicker, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{optionsTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified option contract. 
     * @param optionsTicker The ticker symbol of the options contract.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPreviousOptionsAggregatesWithHttpInfo(optionsTicker: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetCryptoAggregates200Response?> {
        val localVariableConfig = getPreviousOptionsAggregatesRequestConfig(optionsTicker = optionsTicker, adjusted = adjusted)

        return request<Unit, GetCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPreviousOptionsAggregates
     *
     * @param optionsTicker The ticker symbol of the options contract.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getPreviousOptionsAggregatesRequestConfig(optionsTicker: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{optionsTicker}/prev".replace("{"+"optionsTicker"+"}", encodeURIComponent(optionsTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/aggs/ticker/{stocksTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified stock ticker. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetCryptoAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getPreviousStocksAggregates(stocksTicker: kotlin.String, adjusted: kotlin.Boolean? = null) : GetCryptoAggregates200Response {
        val localVarResponse = getPreviousStocksAggregatesWithHttpInfo(stocksTicker = stocksTicker, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetCryptoAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{stocksTicker}/prev
     * Previous Close
     * Get the previous day&#39;s open, high, low, and close (OHLC) for the specified stock ticker. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetCryptoAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getPreviousStocksAggregatesWithHttpInfo(stocksTicker: kotlin.String, adjusted: kotlin.Boolean?) : ApiResponse<GetCryptoAggregates200Response?> {
        val localVariableConfig = getPreviousStocksAggregatesRequestConfig(stocksTicker = stocksTicker, adjusted = adjusted)

        return request<Unit, GetCryptoAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getPreviousStocksAggregates
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getPreviousStocksAggregatesRequestConfig(stocksTicker: kotlin.String, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{stocksTicker}/prev".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/related-companies/{ticker}
     * Related Companies
     * Get a list of tickers related to the queried ticker based on News and Returns data.
     * @param ticker The ticker symbol to search.
     * @return GetRelatedCompanies200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getRelatedCompanies(ticker: kotlin.String) : GetRelatedCompanies200Response {
        val localVarResponse = getRelatedCompaniesWithHttpInfo(ticker = ticker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetRelatedCompanies200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/related-companies/{ticker}
     * Related Companies
     * Get a list of tickers related to the queried ticker based on News and Returns data.
     * @param ticker The ticker symbol to search.
     * @return ApiResponse<GetRelatedCompanies200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getRelatedCompaniesWithHttpInfo(ticker: kotlin.String) : ApiResponse<GetRelatedCompanies200Response?> {
        val localVariableConfig = getRelatedCompaniesRequestConfig(ticker = ticker)

        return request<Unit, GetRelatedCompanies200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getRelatedCompanies
     *
     * @param ticker The ticker symbol to search.
     * @return RequestConfig
     */
    fun getRelatedCompaniesRequestConfig(ticker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/related-companies/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/summaries
     * Summaries
     * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
     * @param tickerAnyOf Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://massive.com/docs/rest/stocks/tickers/all-tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @return GetSnapshotSummary200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSnapshotSummary(tickerAnyOf: kotlin.String? = null) : GetSnapshotSummary200Response {
        val localVarResponse = getSnapshotSummaryWithHttpInfo(tickerAnyOf = tickerAnyOf)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSnapshotSummary200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/summaries
     * Summaries
     * Get everything needed to visualize the tick-by-tick movement of a list of tickers.
     * @param tickerAnyOf Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://massive.com/docs/rest/stocks/tickers/all-tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @return ApiResponse<GetSnapshotSummary200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSnapshotSummaryWithHttpInfo(tickerAnyOf: kotlin.String?) : ApiResponse<GetSnapshotSummary200Response?> {
        val localVariableConfig = getSnapshotSummaryRequestConfig(tickerAnyOf = tickerAnyOf)

        return request<Unit, GetSnapshotSummary200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSnapshotSummary
     *
     * @param tickerAnyOf Comma separated list of tickers. This API currently supports Stocks/Equities, Crypto, Options, and Forex. See &lt;a rel&#x3D;\&quot;nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://massive.com/docs/rest/stocks/tickers/all-tickers\&quot;&gt;the tickers endpoint&lt;/a&gt; for more details on supported tickers. If no tickers are passed then no results will be returned.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack. (optional)
     * @return RequestConfig
     */
    fun getSnapshotSummaryRequestConfig(tickerAnyOf: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/summaries",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter type
     */
     enum class TypeGetSnapshots(val value: kotlin.String) {
         @Json(name = "stocks") stocks("stocks"),
         @Json(name = "options") options("options"),
         @Json(name = "crypto") crypto("crypto"),
         @Json(name = "fx") fx("fx"),
         @Json(name = "indices") indices("indices");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetSnapshots(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetSnapshots(val value: kotlin.String) {
         @Json(name = "ticker") ticker("ticker");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/snapshot
     * Universal Snapshot
     * Get snapshots for assets of all types
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param type Query by the type of asset. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.  (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return GetSnapshots200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getSnapshots(ticker: kotlin.String? = null, type: TypeGetSnapshots? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, order: OrderGetSnapshots? = null, limit: kotlin.Int? = 10, sort: SortGetSnapshots? = SortGetSnapshots.ticker) : GetSnapshots200Response {
        val localVarResponse = getSnapshotsWithHttpInfo(ticker = ticker, type = type, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, tickerAnyOf = tickerAnyOf, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetSnapshots200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/snapshot
     * Universal Snapshot
     * Get snapshots for assets of all types
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param type Query by the type of asset. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.  (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ApiResponse<GetSnapshots200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getSnapshotsWithHttpInfo(ticker: kotlin.String?, type: TypeGetSnapshots?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, tickerAnyOf: kotlin.String?, order: OrderGetSnapshots?, limit: kotlin.Int?, sort: SortGetSnapshots?) : ApiResponse<GetSnapshots200Response?> {
        val localVariableConfig = getSnapshotsRequestConfig(ticker = ticker, type = type, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, tickerAnyOf = tickerAnyOf, order = order, limit = limit, sort = sort)

        return request<Unit, GetSnapshots200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getSnapshots
     *
     * @param ticker Search a range of tickers lexicographically. (optional)
     * @param type Query by the type of asset. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param tickerAnyOf Comma separated list of tickers, up to a maximum of 250. If no tickers are passed then all results will be returned in a paginated manner.  Warning: The maximum number of characters allowed in a URL are subject to your technology stack.  (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 250. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return RequestConfig
     */
    fun getSnapshotsRequestConfig(ticker: kotlin.String?, type: TypeGetSnapshots?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, tickerAnyOf: kotlin.String?, order: OrderGetSnapshots?, limit: kotlin.Int?, sort: SortGetSnapshots?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.value))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/snapshot",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetStocksAggregates(val value: kotlin.String) {
         @Json(name = "second") second("second"),
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetStocksAggregates(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a stock over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; minute and multiplier &#x3D; 5 then 5-minute bars will be returned. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return GetStocksAggregates200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksAggregates(stocksTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetStocksAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean? = null, sort: SortGetStocksAggregates? = null, limit: kotlin.Int? = null) : GetStocksAggregates200Response {
        val localVarResponse = getStocksAggregatesWithHttpInfo(stocksTicker = stocksTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksAggregates200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}
     * Aggregates (Bars)
     * Get aggregate bars for a stock over a given date range in custom time window sizes. &lt;br /&gt; &lt;br /&gt; For example, if timespan &#x3D; minute and multiplier &#x3D; 5 then 5-minute bars will be returned. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return ApiResponse<GetStocksAggregates200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksAggregatesWithHttpInfo(stocksTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetStocksAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetStocksAggregates?, limit: kotlin.Int?) : ApiResponse<GetStocksAggregates200Response?> {
        val localVariableConfig = getStocksAggregatesRequestConfig(stocksTicker = stocksTicker, multiplier = multiplier, timespan = timespan, from = from, to = to, adjusted = adjusted, sort = sort, limit = limit)

        return request<Unit, GetStocksAggregates200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksAggregates
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param multiplier The size of the timespan multiplier.
     * @param timespan The size of the time window.
     * @param from The start of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param to The end of the aggregate time window. Either a date with the format YYYY-MM-DD or a millisecond timestamp.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @param sort Sort the results by timestamp. &#x60;asc&#x60; will return results in ascending order (oldest at the top), &#x60;desc&#x60; will return results in descending order (newest at the top).  (optional)
     * @param limit Limits the number of base aggregates queried to create the aggregate results. Max 50000 and Default 5000. Read more about how limit is used to calculate aggregate results in our article on &lt;a href&#x3D;\&quot;https://massive.com/blog/aggs-api-updates/\&quot; target&#x3D;\&quot;_blank\&quot; alt&#x3D;\&quot;Aggregate Data API Improvements\&quot;&gt;Aggregate Data API Improvements&lt;/a&gt;.  (optional)
     * @return RequestConfig
     */
    fun getStocksAggregatesRequestConfig(stocksTicker: kotlin.String, multiplier: kotlin.Int, timespan: TimespanGetStocksAggregates, from: kotlin.String, to: kotlin.String, adjusted: kotlin.Boolean?, sort: SortGetStocksAggregates?, limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/aggs/ticker/{stocksTicker}/range/{multiplier}/{timespan}/{from}/{to}".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())).replace("{"+"multiplier"+"}", encodeURIComponent(multiplier.toString())).replace("{"+"timespan"+"}", encodeURIComponent(timespan.value.toString())).replace("{"+"from"+"}", encodeURIComponent(from.toString())).replace("{"+"to"+"}", encodeURIComponent(to.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetStocksEMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetStocksEMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksEMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/ema/{stockTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetStocksEMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksEMA(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetStocksEMA? = TimespanGetStocksEMA.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 50, seriesType: SeriesTypeGetStocksEMA? = SeriesTypeGetStocksEMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetStocksEMA? = OrderGetStocksEMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetStocksEMA200Response {
        val localVarResponse = getStocksEMAWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksEMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/ema/{stockTicker}
     * Exponential Moving Average (EMA)
     * Get the exponential moving average (EMA) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetStocksEMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksEMAWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksEMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetStocksEMA200Response?> {
        val localVariableConfig = getStocksEMARequestConfig(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetStocksEMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksEMA
     *
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get exponential moving average (EMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the exponential moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the exponential moving average (EMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the exponential moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the exponential moving average (EMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getStocksEMARequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksEMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksEMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksEMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/ema/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /stocks/filings/vX/risk-factors
     * 
     * The risk factors identified in companies&#39; 10K filings.
     * @param filingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD). (optional)
     * @param filingDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param filingDateGt Filter greater than the value. (optional)
     * @param filingDateGte Filter greater than or equal to the value. (optional)
     * @param filingDateLt Filter less than the value. (optional)
     * @param filingDateLte Filter less than or equal to the value. (optional)
     * @param ticker Stock ticker symbol for the company. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param cik SEC Central Index Key (10 digits, zero-padded). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;49999&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;filing_date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "filing_date.desc")
     * @return GetStocksFilingsVXRiskFactors200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksFilingsVXRiskFactors(filingDate: kotlin.String? = null, filingDateAnyOf: kotlin.String? = null, filingDateGt: kotlin.String? = null, filingDateGte: kotlin.String? = null, filingDateLt: kotlin.String? = null, filingDateLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, cik: kotlin.String? = null, cikAnyOf: kotlin.String? = null, cikGt: kotlin.String? = null, cikGte: kotlin.String? = null, cikLt: kotlin.String? = null, cikLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "filing_date.desc") : GetStocksFilingsVXRiskFactors200Response {
        val localVarResponse = getStocksFilingsVXRiskFactorsWithHttpInfo(filingDate = filingDate, filingDateAnyOf = filingDateAnyOf, filingDateGt = filingDateGt, filingDateGte = filingDateGte, filingDateLt = filingDateLt, filingDateLte = filingDateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksFilingsVXRiskFactors200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/filings/vX/risk-factors
     * 
     * The risk factors identified in companies&#39; 10K filings.
     * @param filingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD). (optional)
     * @param filingDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param filingDateGt Filter greater than the value. (optional)
     * @param filingDateGte Filter greater than or equal to the value. (optional)
     * @param filingDateLt Filter less than the value. (optional)
     * @param filingDateLte Filter less than or equal to the value. (optional)
     * @param ticker Stock ticker symbol for the company. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param cik SEC Central Index Key (10 digits, zero-padded). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;49999&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;filing_date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "filing_date.desc")
     * @return ApiResponse<GetStocksFilingsVXRiskFactors200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksFilingsVXRiskFactorsWithHttpInfo(filingDate: kotlin.String?, filingDateAnyOf: kotlin.String?, filingDateGt: kotlin.String?, filingDateGte: kotlin.String?, filingDateLt: kotlin.String?, filingDateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksFilingsVXRiskFactors200Response?> {
        val localVariableConfig = getStocksFilingsVXRiskFactorsRequestConfig(filingDate = filingDate, filingDateAnyOf = filingDateAnyOf, filingDateGt = filingDateGt, filingDateGte = filingDateGte, filingDateLt = filingDateLt, filingDateLte = filingDateLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, limit = limit, sort = sort)

        return request<Unit, GetStocksFilingsVXRiskFactors200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksFilingsVXRiskFactors
     *
     * @param filingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD). (optional)
     * @param filingDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param filingDateGt Filter greater than the value. (optional)
     * @param filingDateGte Filter greater than or equal to the value. (optional)
     * @param filingDateLt Filter less than the value. (optional)
     * @param filingDateLte Filter less than or equal to the value. (optional)
     * @param ticker Stock ticker symbol for the company. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param cik SEC Central Index Key (10 digits, zero-padded). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;49999&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;filing_date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "filing_date.desc")
     * @return RequestConfig
     */
    fun getStocksFilingsVXRiskFactorsRequestConfig(filingDate: kotlin.String?, filingDateAnyOf: kotlin.String?, filingDateGt: kotlin.String?, filingDateGte: kotlin.String?, filingDateLt: kotlin.String?, filingDateLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (filingDate != null) {
                    put("filing_date", listOf(filingDate.toString()))
                }
                if (filingDateAnyOf != null) {
                    put("filing_date.any_of", listOf(filingDateAnyOf.toString()))
                }
                if (filingDateGt != null) {
                    put("filing_date.gt", listOf(filingDateGt.toString()))
                }
                if (filingDateGte != null) {
                    put("filing_date.gte", listOf(filingDateGte.toString()))
                }
                if (filingDateLt != null) {
                    put("filing_date.lt", listOf(filingDateLt.toString()))
                }
                if (filingDateLte != null) {
                    put("filing_date.lte", listOf(filingDateLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (cik != null) {
                    put("cik", listOf(cik.toString()))
                }
                if (cikAnyOf != null) {
                    put("cik.any_of", listOf(cikAnyOf.toString()))
                }
                if (cikGt != null) {
                    put("cik.gt", listOf(cikGt.toString()))
                }
                if (cikGte != null) {
                    put("cik.gte", listOf(cikGte.toString()))
                }
                if (cikLt != null) {
                    put("cik.lt", listOf(cikLt.toString()))
                }
                if (cikLte != null) {
                    put("cik.lte", listOf(cikLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/filings/vX/risk-factors",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter formType
     */
     enum class FormTypeGetStocksFilingsVXText(val value: kotlin.String) {
         @Json(name = "10-K") _10minusK("10-K");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter formTypeAnyOf
     */
     enum class FormTypeAnyOfGetStocksFilingsVXText(val value: kotlin.String) {
         @Json(name = "10-K") _10minusK("10-K");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter section
     */
     enum class SectionGetStocksFilingsVXText(val value: kotlin.String) {
         @Json(name = "business") business("business"),
         @Json(name = "risk_factors") riskFactors("risk_factors");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sectionAnyOf
     */
     enum class SectionAnyOfGetStocksFilingsVXText(val value: kotlin.String) {
         @Json(name = "business") business("business"),
         @Json(name = "risk_factors") riskFactors("risk_factors");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /stocks/filings/vX/text
     * 
     * SEC document text sections providing raw text content from specific sections of SEC filings (10-K, 10-Q, etc.).
     * @param cik SEC Central Index Key (10 digits, zero-padded). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param ticker Stock ticker symbol for the company. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param formType SEC form type (e.g., &#39;10-K&#39; for annual reports, &#39;10-Q&#39; for quarterly reports). (optional)
     * @param formTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param section Standardized section identifier from the filing (e.g. &#39;business&#39;, &#39;risk_factors&#39;, etc.). (optional)
     * @param sectionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param filingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEnd Period end date that the filing relates to (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;9999&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "period_end.desc")
     * @return GetStocksFilingsVXText200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksFilingsVXText(cik: kotlin.String? = null, cikAnyOf: kotlin.String? = null, cikGt: kotlin.String? = null, cikGte: kotlin.String? = null, cikLt: kotlin.String? = null, cikLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, formType: FormTypeGetStocksFilingsVXText? = null, formTypeAnyOf: FormTypeAnyOfGetStocksFilingsVXText? = null, section: SectionGetStocksFilingsVXText? = null, sectionAnyOf: SectionAnyOfGetStocksFilingsVXText? = null, filingDate: kotlin.String? = null, filingDateGt: kotlin.String? = null, filingDateGte: kotlin.String? = null, filingDateLt: kotlin.String? = null, filingDateLte: kotlin.String? = null, periodEnd: kotlin.String? = null, periodEndGt: kotlin.String? = null, periodEndGte: kotlin.String? = null, periodEndLt: kotlin.String? = null, periodEndLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "period_end.desc") : GetStocksFilingsVXText200Response {
        val localVarResponse = getStocksFilingsVXTextWithHttpInfo(cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, formType = formType, formTypeAnyOf = formTypeAnyOf, section = section, sectionAnyOf = sectionAnyOf, filingDate = filingDate, filingDateGt = filingDateGt, filingDateGte = filingDateGte, filingDateLt = filingDateLt, filingDateLte = filingDateLte, periodEnd = periodEnd, periodEndGt = periodEndGt, periodEndGte = periodEndGte, periodEndLt = periodEndLt, periodEndLte = periodEndLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksFilingsVXText200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/filings/vX/text
     * 
     * SEC document text sections providing raw text content from specific sections of SEC filings (10-K, 10-Q, etc.).
     * @param cik SEC Central Index Key (10 digits, zero-padded). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param ticker Stock ticker symbol for the company. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param formType SEC form type (e.g., &#39;10-K&#39; for annual reports, &#39;10-Q&#39; for quarterly reports). (optional)
     * @param formTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param section Standardized section identifier from the filing (e.g. &#39;business&#39;, &#39;risk_factors&#39;, etc.). (optional)
     * @param sectionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param filingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEnd Period end date that the filing relates to (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;9999&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "period_end.desc")
     * @return ApiResponse<GetStocksFilingsVXText200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksFilingsVXTextWithHttpInfo(cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, formType: FormTypeGetStocksFilingsVXText?, formTypeAnyOf: FormTypeAnyOfGetStocksFilingsVXText?, section: SectionGetStocksFilingsVXText?, sectionAnyOf: SectionAnyOfGetStocksFilingsVXText?, filingDate: kotlin.String?, filingDateGt: kotlin.String?, filingDateGte: kotlin.String?, filingDateLt: kotlin.String?, filingDateLte: kotlin.String?, periodEnd: kotlin.String?, periodEndGt: kotlin.String?, periodEndGte: kotlin.String?, periodEndLt: kotlin.String?, periodEndLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksFilingsVXText200Response?> {
        val localVariableConfig = getStocksFilingsVXTextRequestConfig(cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, formType = formType, formTypeAnyOf = formTypeAnyOf, section = section, sectionAnyOf = sectionAnyOf, filingDate = filingDate, filingDateGt = filingDateGt, filingDateGte = filingDateGte, filingDateLt = filingDateLt, filingDateLte = filingDateLte, periodEnd = periodEnd, periodEndGt = periodEndGt, periodEndGte = periodEndGte, periodEndLt = periodEndLt, periodEndLte = periodEndLte, limit = limit, sort = sort)

        return request<Unit, GetStocksFilingsVXText200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksFilingsVXText
     *
     * @param cik SEC Central Index Key (10 digits, zero-padded). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param ticker Stock ticker symbol for the company. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param formType SEC form type (e.g., &#39;10-K&#39; for annual reports, &#39;10-Q&#39; for quarterly reports). (optional)
     * @param formTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param section Standardized section identifier from the filing (e.g. &#39;business&#39;, &#39;risk_factors&#39;, etc.). (optional)
     * @param sectionAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param filingDate Date when the filing was submitted to the SEC (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEnd Period end date that the filing relates to (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;9999&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "period_end.desc")
     * @return RequestConfig
     */
    fun getStocksFilingsVXTextRequestConfig(cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, formType: FormTypeGetStocksFilingsVXText?, formTypeAnyOf: FormTypeAnyOfGetStocksFilingsVXText?, section: SectionGetStocksFilingsVXText?, sectionAnyOf: SectionAnyOfGetStocksFilingsVXText?, filingDate: kotlin.String?, filingDateGt: kotlin.String?, filingDateGte: kotlin.String?, filingDateLt: kotlin.String?, filingDateLte: kotlin.String?, periodEnd: kotlin.String?, periodEndGt: kotlin.String?, periodEndGte: kotlin.String?, periodEndLt: kotlin.String?, periodEndLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (cik != null) {
                    put("cik", listOf(cik.toString()))
                }
                if (cikAnyOf != null) {
                    put("cik.any_of", listOf(cikAnyOf.toString()))
                }
                if (cikGt != null) {
                    put("cik.gt", listOf(cikGt.toString()))
                }
                if (cikGte != null) {
                    put("cik.gte", listOf(cikGte.toString()))
                }
                if (cikLt != null) {
                    put("cik.lt", listOf(cikLt.toString()))
                }
                if (cikLte != null) {
                    put("cik.lte", listOf(cikLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (formType != null) {
                    put("form_type", listOf(formType.value))
                }
                if (formTypeAnyOf != null) {
                    put("form_type.any_of", listOf(formTypeAnyOf.value))
                }
                if (section != null) {
                    put("section", listOf(section.value))
                }
                if (sectionAnyOf != null) {
                    put("section.any_of", listOf(sectionAnyOf.value))
                }
                if (filingDate != null) {
                    put("filing_date", listOf(filingDate.toString()))
                }
                if (filingDateGt != null) {
                    put("filing_date.gt", listOf(filingDateGt.toString()))
                }
                if (filingDateGte != null) {
                    put("filing_date.gte", listOf(filingDateGte.toString()))
                }
                if (filingDateLt != null) {
                    put("filing_date.lt", listOf(filingDateLt.toString()))
                }
                if (filingDateLte != null) {
                    put("filing_date.lte", listOf(filingDateLte.toString()))
                }
                if (periodEnd != null) {
                    put("period_end", listOf(periodEnd.toString()))
                }
                if (periodEndGt != null) {
                    put("period_end.gt", listOf(periodEndGt.toString()))
                }
                if (periodEndGte != null) {
                    put("period_end.gte", listOf(periodEndGte.toString()))
                }
                if (periodEndLt != null) {
                    put("period_end.lt", listOf(periodEndLt.toString()))
                }
                if (periodEndLte != null) {
                    put("period_end.lte", listOf(periodEndLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/filings/vX/text",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /stocks/financials/v1/balance-sheets
     * 
     * A comprehensive financial dataset containing quarterly and annual balance sheet data for public companies. Includes detailed asset, liability, and equity positions representing the company&#39;s financial position at specific points in time. Balance sheet data represents point-in-time snapshots rather than cumulative flows, showing what the company owns, owes, and shareholders&#39; equity as of each period end date.
     * @param cik The company&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a company&#39;s CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param periodEnd The last date of the reporting period, representing the specific point in time when the balance sheet snapshot was taken. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDate The date when the financial statement was filed with the SEC. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param fiscalYear The fiscal year for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalQuarterGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param timeframe The reporting period type. Possible values include: quarterly, annual. (optional)
     * @param timeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param timeframeGt Filter greater than the value. (optional)
     * @param timeframeGte Filter greater than or equal to the value. (optional)
     * @param timeframeLt Filter less than the value. (optional)
     * @param timeframeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "period_end.asc")
     * @return GetStocksFinancialsV1BalanceSheets200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksFinancialsV1BalanceSheets(cik: kotlin.String? = null, cikAnyOf: kotlin.String? = null, cikGt: kotlin.String? = null, cikGte: kotlin.String? = null, cikLt: kotlin.String? = null, cikLte: kotlin.String? = null, tickers: kotlin.String? = null, tickersAllOf: kotlin.String? = null, tickersAnyOf: kotlin.String? = null, periodEnd: kotlin.String? = null, periodEndGt: kotlin.String? = null, periodEndGte: kotlin.String? = null, periodEndLt: kotlin.String? = null, periodEndLte: kotlin.String? = null, filingDate: kotlin.String? = null, filingDateGt: kotlin.String? = null, filingDateGte: kotlin.String? = null, filingDateLt: kotlin.String? = null, filingDateLte: kotlin.String? = null, fiscalYear: kotlin.Double? = null, fiscalYearGt: kotlin.Double? = null, fiscalYearGte: kotlin.Double? = null, fiscalYearLt: kotlin.Double? = null, fiscalYearLte: kotlin.Double? = null, fiscalQuarter: kotlin.Double? = null, fiscalQuarterGt: kotlin.Double? = null, fiscalQuarterGte: kotlin.Double? = null, fiscalQuarterLt: kotlin.Double? = null, fiscalQuarterLte: kotlin.Double? = null, timeframe: kotlin.String? = null, timeframeAnyOf: kotlin.String? = null, timeframeGt: kotlin.String? = null, timeframeGte: kotlin.String? = null, timeframeLt: kotlin.String? = null, timeframeLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "period_end.asc") : GetStocksFinancialsV1BalanceSheets200Response {
        val localVarResponse = getStocksFinancialsV1BalanceSheetsWithHttpInfo(cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, tickers = tickers, tickersAllOf = tickersAllOf, tickersAnyOf = tickersAnyOf, periodEnd = periodEnd, periodEndGt = periodEndGt, periodEndGte = periodEndGte, periodEndLt = periodEndLt, periodEndLte = periodEndLte, filingDate = filingDate, filingDateGt = filingDateGt, filingDateGte = filingDateGte, filingDateLt = filingDateLt, filingDateLte = filingDateLte, fiscalYear = fiscalYear, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalQuarter = fiscalQuarter, fiscalQuarterGt = fiscalQuarterGt, fiscalQuarterGte = fiscalQuarterGte, fiscalQuarterLt = fiscalQuarterLt, fiscalQuarterLte = fiscalQuarterLte, timeframe = timeframe, timeframeAnyOf = timeframeAnyOf, timeframeGt = timeframeGt, timeframeGte = timeframeGte, timeframeLt = timeframeLt, timeframeLte = timeframeLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksFinancialsV1BalanceSheets200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/financials/v1/balance-sheets
     * 
     * A comprehensive financial dataset containing quarterly and annual balance sheet data for public companies. Includes detailed asset, liability, and equity positions representing the company&#39;s financial position at specific points in time. Balance sheet data represents point-in-time snapshots rather than cumulative flows, showing what the company owns, owes, and shareholders&#39; equity as of each period end date.
     * @param cik The company&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a company&#39;s CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param periodEnd The last date of the reporting period, representing the specific point in time when the balance sheet snapshot was taken. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDate The date when the financial statement was filed with the SEC. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param fiscalYear The fiscal year for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalQuarterGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param timeframe The reporting period type. Possible values include: quarterly, annual. (optional)
     * @param timeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param timeframeGt Filter greater than the value. (optional)
     * @param timeframeGte Filter greater than or equal to the value. (optional)
     * @param timeframeLt Filter less than the value. (optional)
     * @param timeframeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "period_end.asc")
     * @return ApiResponse<GetStocksFinancialsV1BalanceSheets200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksFinancialsV1BalanceSheetsWithHttpInfo(cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, tickers: kotlin.String?, tickersAllOf: kotlin.String?, tickersAnyOf: kotlin.String?, periodEnd: kotlin.String?, periodEndGt: kotlin.String?, periodEndGte: kotlin.String?, periodEndLt: kotlin.String?, periodEndLte: kotlin.String?, filingDate: kotlin.String?, filingDateGt: kotlin.String?, filingDateGte: kotlin.String?, filingDateLt: kotlin.String?, filingDateLte: kotlin.String?, fiscalYear: kotlin.Double?, fiscalYearGt: kotlin.Double?, fiscalYearGte: kotlin.Double?, fiscalYearLt: kotlin.Double?, fiscalYearLte: kotlin.Double?, fiscalQuarter: kotlin.Double?, fiscalQuarterGt: kotlin.Double?, fiscalQuarterGte: kotlin.Double?, fiscalQuarterLt: kotlin.Double?, fiscalQuarterLte: kotlin.Double?, timeframe: kotlin.String?, timeframeAnyOf: kotlin.String?, timeframeGt: kotlin.String?, timeframeGte: kotlin.String?, timeframeLt: kotlin.String?, timeframeLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksFinancialsV1BalanceSheets200Response?> {
        val localVariableConfig = getStocksFinancialsV1BalanceSheetsRequestConfig(cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, tickers = tickers, tickersAllOf = tickersAllOf, tickersAnyOf = tickersAnyOf, periodEnd = periodEnd, periodEndGt = periodEndGt, periodEndGte = periodEndGte, periodEndLt = periodEndLt, periodEndLte = periodEndLte, filingDate = filingDate, filingDateGt = filingDateGt, filingDateGte = filingDateGte, filingDateLt = filingDateLt, filingDateLte = filingDateLte, fiscalYear = fiscalYear, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalQuarter = fiscalQuarter, fiscalQuarterGt = fiscalQuarterGt, fiscalQuarterGte = fiscalQuarterGte, fiscalQuarterLt = fiscalQuarterLt, fiscalQuarterLte = fiscalQuarterLte, timeframe = timeframe, timeframeAnyOf = timeframeAnyOf, timeframeGt = timeframeGt, timeframeGte = timeframeGte, timeframeLt = timeframeLt, timeframeLte = timeframeLte, limit = limit, sort = sort)

        return request<Unit, GetStocksFinancialsV1BalanceSheets200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksFinancialsV1BalanceSheets
     *
     * @param cik The company&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a company&#39;s CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param periodEnd The last date of the reporting period, representing the specific point in time when the balance sheet snapshot was taken. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDate The date when the financial statement was filed with the SEC. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param fiscalYear The fiscal year for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalQuarterGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param timeframe The reporting period type. Possible values include: quarterly, annual. (optional)
     * @param timeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param timeframeGt Filter greater than the value. (optional)
     * @param timeframeGte Filter greater than or equal to the value. (optional)
     * @param timeframeLt Filter less than the value. (optional)
     * @param timeframeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "period_end.asc")
     * @return RequestConfig
     */
    fun getStocksFinancialsV1BalanceSheetsRequestConfig(cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, tickers: kotlin.String?, tickersAllOf: kotlin.String?, tickersAnyOf: kotlin.String?, periodEnd: kotlin.String?, periodEndGt: kotlin.String?, periodEndGte: kotlin.String?, periodEndLt: kotlin.String?, periodEndLte: kotlin.String?, filingDate: kotlin.String?, filingDateGt: kotlin.String?, filingDateGte: kotlin.String?, filingDateLt: kotlin.String?, filingDateLte: kotlin.String?, fiscalYear: kotlin.Double?, fiscalYearGt: kotlin.Double?, fiscalYearGte: kotlin.Double?, fiscalYearLt: kotlin.Double?, fiscalYearLte: kotlin.Double?, fiscalQuarter: kotlin.Double?, fiscalQuarterGt: kotlin.Double?, fiscalQuarterGte: kotlin.Double?, fiscalQuarterLt: kotlin.Double?, fiscalQuarterLte: kotlin.Double?, timeframe: kotlin.String?, timeframeAnyOf: kotlin.String?, timeframeGt: kotlin.String?, timeframeGte: kotlin.String?, timeframeLt: kotlin.String?, timeframeLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (cik != null) {
                    put("cik", listOf(cik.toString()))
                }
                if (cikAnyOf != null) {
                    put("cik.any_of", listOf(cikAnyOf.toString()))
                }
                if (cikGt != null) {
                    put("cik.gt", listOf(cikGt.toString()))
                }
                if (cikGte != null) {
                    put("cik.gte", listOf(cikGte.toString()))
                }
                if (cikLt != null) {
                    put("cik.lt", listOf(cikLt.toString()))
                }
                if (cikLte != null) {
                    put("cik.lte", listOf(cikLte.toString()))
                }
                if (tickers != null) {
                    put("tickers", listOf(tickers.toString()))
                }
                if (tickersAllOf != null) {
                    put("tickers.all_of", listOf(tickersAllOf.toString()))
                }
                if (tickersAnyOf != null) {
                    put("tickers.any_of", listOf(tickersAnyOf.toString()))
                }
                if (periodEnd != null) {
                    put("period_end", listOf(periodEnd.toString()))
                }
                if (periodEndGt != null) {
                    put("period_end.gt", listOf(periodEndGt.toString()))
                }
                if (periodEndGte != null) {
                    put("period_end.gte", listOf(periodEndGte.toString()))
                }
                if (periodEndLt != null) {
                    put("period_end.lt", listOf(periodEndLt.toString()))
                }
                if (periodEndLte != null) {
                    put("period_end.lte", listOf(periodEndLte.toString()))
                }
                if (filingDate != null) {
                    put("filing_date", listOf(filingDate.toString()))
                }
                if (filingDateGt != null) {
                    put("filing_date.gt", listOf(filingDateGt.toString()))
                }
                if (filingDateGte != null) {
                    put("filing_date.gte", listOf(filingDateGte.toString()))
                }
                if (filingDateLt != null) {
                    put("filing_date.lt", listOf(filingDateLt.toString()))
                }
                if (filingDateLte != null) {
                    put("filing_date.lte", listOf(filingDateLte.toString()))
                }
                if (fiscalYear != null) {
                    put("fiscal_year", listOf(fiscalYear.toString()))
                }
                if (fiscalYearGt != null) {
                    put("fiscal_year.gt", listOf(fiscalYearGt.toString()))
                }
                if (fiscalYearGte != null) {
                    put("fiscal_year.gte", listOf(fiscalYearGte.toString()))
                }
                if (fiscalYearLt != null) {
                    put("fiscal_year.lt", listOf(fiscalYearLt.toString()))
                }
                if (fiscalYearLte != null) {
                    put("fiscal_year.lte", listOf(fiscalYearLte.toString()))
                }
                if (fiscalQuarter != null) {
                    put("fiscal_quarter", listOf(fiscalQuarter.toString()))
                }
                if (fiscalQuarterGt != null) {
                    put("fiscal_quarter.gt", listOf(fiscalQuarterGt.toString()))
                }
                if (fiscalQuarterGte != null) {
                    put("fiscal_quarter.gte", listOf(fiscalQuarterGte.toString()))
                }
                if (fiscalQuarterLt != null) {
                    put("fiscal_quarter.lt", listOf(fiscalQuarterLt.toString()))
                }
                if (fiscalQuarterLte != null) {
                    put("fiscal_quarter.lte", listOf(fiscalQuarterLte.toString()))
                }
                if (timeframe != null) {
                    put("timeframe", listOf(timeframe.toString()))
                }
                if (timeframeAnyOf != null) {
                    put("timeframe.any_of", listOf(timeframeAnyOf.toString()))
                }
                if (timeframeGt != null) {
                    put("timeframe.gt", listOf(timeframeGt.toString()))
                }
                if (timeframeGte != null) {
                    put("timeframe.gte", listOf(timeframeGte.toString()))
                }
                if (timeframeLt != null) {
                    put("timeframe.lt", listOf(timeframeLt.toString()))
                }
                if (timeframeLte != null) {
                    put("timeframe.lte", listOf(timeframeLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/financials/v1/balance-sheets",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /stocks/financials/v1/cash-flow-statements
     * 
     * A comprehensive financial dataset containing quarterly, annual, and trailing twelve-month cash flow statement data for public companies. Includes detailed operating, investing, and financing cash flows with proper TTM calculations that sum all cash flow components over four quarters. TTM records are validated to ensure exactly four distinct quarters spanning 250-400 days for accurate trailing twelve-month cash flow analysis.
     * @param cik The company&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param periodEnd The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDate The date when the financial statement was filed with the SEC. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalYear The fiscal year for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalQuarterGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months. (optional)
     * @param timeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param timeframeGt Filter greater than the value. (optional)
     * @param timeframeGte Filter greater than or equal to the value. (optional)
     * @param timeframeLt Filter less than the value. (optional)
     * @param timeframeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "period_end.asc")
     * @return GetStocksFinancialsV1CashFlowStatements200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksFinancialsV1CashFlowStatements(cik: kotlin.String? = null, cikAnyOf: kotlin.String? = null, cikGt: kotlin.String? = null, cikGte: kotlin.String? = null, cikLt: kotlin.String? = null, cikLte: kotlin.String? = null, periodEnd: kotlin.String? = null, periodEndGt: kotlin.String? = null, periodEndGte: kotlin.String? = null, periodEndLt: kotlin.String? = null, periodEndLte: kotlin.String? = null, filingDate: kotlin.String? = null, filingDateGt: kotlin.String? = null, filingDateGte: kotlin.String? = null, filingDateLt: kotlin.String? = null, filingDateLte: kotlin.String? = null, tickers: kotlin.String? = null, tickersAllOf: kotlin.String? = null, tickersAnyOf: kotlin.String? = null, fiscalYear: kotlin.Double? = null, fiscalYearGt: kotlin.Double? = null, fiscalYearGte: kotlin.Double? = null, fiscalYearLt: kotlin.Double? = null, fiscalYearLte: kotlin.Double? = null, fiscalQuarter: kotlin.Double? = null, fiscalQuarterGt: kotlin.Double? = null, fiscalQuarterGte: kotlin.Double? = null, fiscalQuarterLt: kotlin.Double? = null, fiscalQuarterLte: kotlin.Double? = null, timeframe: kotlin.String? = null, timeframeAnyOf: kotlin.String? = null, timeframeGt: kotlin.String? = null, timeframeGte: kotlin.String? = null, timeframeLt: kotlin.String? = null, timeframeLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "period_end.asc") : GetStocksFinancialsV1CashFlowStatements200Response {
        val localVarResponse = getStocksFinancialsV1CashFlowStatementsWithHttpInfo(cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, periodEnd = periodEnd, periodEndGt = periodEndGt, periodEndGte = periodEndGte, periodEndLt = periodEndLt, periodEndLte = periodEndLte, filingDate = filingDate, filingDateGt = filingDateGt, filingDateGte = filingDateGte, filingDateLt = filingDateLt, filingDateLte = filingDateLte, tickers = tickers, tickersAllOf = tickersAllOf, tickersAnyOf = tickersAnyOf, fiscalYear = fiscalYear, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalQuarter = fiscalQuarter, fiscalQuarterGt = fiscalQuarterGt, fiscalQuarterGte = fiscalQuarterGte, fiscalQuarterLt = fiscalQuarterLt, fiscalQuarterLte = fiscalQuarterLte, timeframe = timeframe, timeframeAnyOf = timeframeAnyOf, timeframeGt = timeframeGt, timeframeGte = timeframeGte, timeframeLt = timeframeLt, timeframeLte = timeframeLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksFinancialsV1CashFlowStatements200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/financials/v1/cash-flow-statements
     * 
     * A comprehensive financial dataset containing quarterly, annual, and trailing twelve-month cash flow statement data for public companies. Includes detailed operating, investing, and financing cash flows with proper TTM calculations that sum all cash flow components over four quarters. TTM records are validated to ensure exactly four distinct quarters spanning 250-400 days for accurate trailing twelve-month cash flow analysis.
     * @param cik The company&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param periodEnd The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDate The date when the financial statement was filed with the SEC. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalYear The fiscal year for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalQuarterGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months. (optional)
     * @param timeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param timeframeGt Filter greater than the value. (optional)
     * @param timeframeGte Filter greater than or equal to the value. (optional)
     * @param timeframeLt Filter less than the value. (optional)
     * @param timeframeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "period_end.asc")
     * @return ApiResponse<GetStocksFinancialsV1CashFlowStatements200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksFinancialsV1CashFlowStatementsWithHttpInfo(cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, periodEnd: kotlin.String?, periodEndGt: kotlin.String?, periodEndGte: kotlin.String?, periodEndLt: kotlin.String?, periodEndLte: kotlin.String?, filingDate: kotlin.String?, filingDateGt: kotlin.String?, filingDateGte: kotlin.String?, filingDateLt: kotlin.String?, filingDateLte: kotlin.String?, tickers: kotlin.String?, tickersAllOf: kotlin.String?, tickersAnyOf: kotlin.String?, fiscalYear: kotlin.Double?, fiscalYearGt: kotlin.Double?, fiscalYearGte: kotlin.Double?, fiscalYearLt: kotlin.Double?, fiscalYearLte: kotlin.Double?, fiscalQuarter: kotlin.Double?, fiscalQuarterGt: kotlin.Double?, fiscalQuarterGte: kotlin.Double?, fiscalQuarterLt: kotlin.Double?, fiscalQuarterLte: kotlin.Double?, timeframe: kotlin.String?, timeframeAnyOf: kotlin.String?, timeframeGt: kotlin.String?, timeframeGte: kotlin.String?, timeframeLt: kotlin.String?, timeframeLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksFinancialsV1CashFlowStatements200Response?> {
        val localVariableConfig = getStocksFinancialsV1CashFlowStatementsRequestConfig(cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, periodEnd = periodEnd, periodEndGt = periodEndGt, periodEndGte = periodEndGte, periodEndLt = periodEndLt, periodEndLte = periodEndLte, filingDate = filingDate, filingDateGt = filingDateGt, filingDateGte = filingDateGte, filingDateLt = filingDateLt, filingDateLte = filingDateLte, tickers = tickers, tickersAllOf = tickersAllOf, tickersAnyOf = tickersAnyOf, fiscalYear = fiscalYear, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalQuarter = fiscalQuarter, fiscalQuarterGt = fiscalQuarterGt, fiscalQuarterGte = fiscalQuarterGte, fiscalQuarterLt = fiscalQuarterLt, fiscalQuarterLte = fiscalQuarterLte, timeframe = timeframe, timeframeAnyOf = timeframeAnyOf, timeframeGt = timeframeGt, timeframeGte = timeframeGte, timeframeLt = timeframeLt, timeframeLte = timeframeLte, limit = limit, sort = sort)

        return request<Unit, GetStocksFinancialsV1CashFlowStatements200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksFinancialsV1CashFlowStatements
     *
     * @param cik The company&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param periodEnd The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDate The date when the financial statement was filed with the SEC. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param fiscalYear The fiscal year for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalQuarterGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months. (optional)
     * @param timeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param timeframeGt Filter greater than the value. (optional)
     * @param timeframeGte Filter greater than or equal to the value. (optional)
     * @param timeframeLt Filter less than the value. (optional)
     * @param timeframeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "period_end.asc")
     * @return RequestConfig
     */
    fun getStocksFinancialsV1CashFlowStatementsRequestConfig(cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, periodEnd: kotlin.String?, periodEndGt: kotlin.String?, periodEndGte: kotlin.String?, periodEndLt: kotlin.String?, periodEndLte: kotlin.String?, filingDate: kotlin.String?, filingDateGt: kotlin.String?, filingDateGte: kotlin.String?, filingDateLt: kotlin.String?, filingDateLte: kotlin.String?, tickers: kotlin.String?, tickersAllOf: kotlin.String?, tickersAnyOf: kotlin.String?, fiscalYear: kotlin.Double?, fiscalYearGt: kotlin.Double?, fiscalYearGte: kotlin.Double?, fiscalYearLt: kotlin.Double?, fiscalYearLte: kotlin.Double?, fiscalQuarter: kotlin.Double?, fiscalQuarterGt: kotlin.Double?, fiscalQuarterGte: kotlin.Double?, fiscalQuarterLt: kotlin.Double?, fiscalQuarterLte: kotlin.Double?, timeframe: kotlin.String?, timeframeAnyOf: kotlin.String?, timeframeGt: kotlin.String?, timeframeGte: kotlin.String?, timeframeLt: kotlin.String?, timeframeLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (cik != null) {
                    put("cik", listOf(cik.toString()))
                }
                if (cikAnyOf != null) {
                    put("cik.any_of", listOf(cikAnyOf.toString()))
                }
                if (cikGt != null) {
                    put("cik.gt", listOf(cikGt.toString()))
                }
                if (cikGte != null) {
                    put("cik.gte", listOf(cikGte.toString()))
                }
                if (cikLt != null) {
                    put("cik.lt", listOf(cikLt.toString()))
                }
                if (cikLte != null) {
                    put("cik.lte", listOf(cikLte.toString()))
                }
                if (periodEnd != null) {
                    put("period_end", listOf(periodEnd.toString()))
                }
                if (periodEndGt != null) {
                    put("period_end.gt", listOf(periodEndGt.toString()))
                }
                if (periodEndGte != null) {
                    put("period_end.gte", listOf(periodEndGte.toString()))
                }
                if (periodEndLt != null) {
                    put("period_end.lt", listOf(periodEndLt.toString()))
                }
                if (periodEndLte != null) {
                    put("period_end.lte", listOf(periodEndLte.toString()))
                }
                if (filingDate != null) {
                    put("filing_date", listOf(filingDate.toString()))
                }
                if (filingDateGt != null) {
                    put("filing_date.gt", listOf(filingDateGt.toString()))
                }
                if (filingDateGte != null) {
                    put("filing_date.gte", listOf(filingDateGte.toString()))
                }
                if (filingDateLt != null) {
                    put("filing_date.lt", listOf(filingDateLt.toString()))
                }
                if (filingDateLte != null) {
                    put("filing_date.lte", listOf(filingDateLte.toString()))
                }
                if (tickers != null) {
                    put("tickers", listOf(tickers.toString()))
                }
                if (tickersAllOf != null) {
                    put("tickers.all_of", listOf(tickersAllOf.toString()))
                }
                if (tickersAnyOf != null) {
                    put("tickers.any_of", listOf(tickersAnyOf.toString()))
                }
                if (fiscalYear != null) {
                    put("fiscal_year", listOf(fiscalYear.toString()))
                }
                if (fiscalYearGt != null) {
                    put("fiscal_year.gt", listOf(fiscalYearGt.toString()))
                }
                if (fiscalYearGte != null) {
                    put("fiscal_year.gte", listOf(fiscalYearGte.toString()))
                }
                if (fiscalYearLt != null) {
                    put("fiscal_year.lt", listOf(fiscalYearLt.toString()))
                }
                if (fiscalYearLte != null) {
                    put("fiscal_year.lte", listOf(fiscalYearLte.toString()))
                }
                if (fiscalQuarter != null) {
                    put("fiscal_quarter", listOf(fiscalQuarter.toString()))
                }
                if (fiscalQuarterGt != null) {
                    put("fiscal_quarter.gt", listOf(fiscalQuarterGt.toString()))
                }
                if (fiscalQuarterGte != null) {
                    put("fiscal_quarter.gte", listOf(fiscalQuarterGte.toString()))
                }
                if (fiscalQuarterLt != null) {
                    put("fiscal_quarter.lt", listOf(fiscalQuarterLt.toString()))
                }
                if (fiscalQuarterLte != null) {
                    put("fiscal_quarter.lte", listOf(fiscalQuarterLte.toString()))
                }
                if (timeframe != null) {
                    put("timeframe", listOf(timeframe.toString()))
                }
                if (timeframeAnyOf != null) {
                    put("timeframe.any_of", listOf(timeframeAnyOf.toString()))
                }
                if (timeframeGt != null) {
                    put("timeframe.gt", listOf(timeframeGt.toString()))
                }
                if (timeframeGte != null) {
                    put("timeframe.gte", listOf(timeframeGte.toString()))
                }
                if (timeframeLt != null) {
                    put("timeframe.lt", listOf(timeframeLt.toString()))
                }
                if (timeframeLte != null) {
                    put("timeframe.lte", listOf(timeframeLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/financials/v1/cash-flow-statements",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /stocks/financials/v1/income-statements
     * 
     * A comprehensive database of income statement financial data for public companies, including key metrics such as revenue, expenses, and net income for various reporting periods.
     * @param cik The company&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param periodEnd The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDate The date when the financial statement was filed with the SEC. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param fiscalYear The fiscal year for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalQuarterGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months. (optional)
     * @param timeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param timeframeGt Filter greater than the value. (optional)
     * @param timeframeGte Filter greater than or equal to the value. (optional)
     * @param timeframeLt Filter less than the value. (optional)
     * @param timeframeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "period_end.asc")
     * @return GetStocksFinancialsV1IncomeStatements200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksFinancialsV1IncomeStatements(cik: kotlin.String? = null, cikAnyOf: kotlin.String? = null, cikGt: kotlin.String? = null, cikGte: kotlin.String? = null, cikLt: kotlin.String? = null, cikLte: kotlin.String? = null, tickers: kotlin.String? = null, tickersAllOf: kotlin.String? = null, tickersAnyOf: kotlin.String? = null, periodEnd: kotlin.String? = null, periodEndGt: kotlin.String? = null, periodEndGte: kotlin.String? = null, periodEndLt: kotlin.String? = null, periodEndLte: kotlin.String? = null, filingDate: kotlin.String? = null, filingDateGt: kotlin.String? = null, filingDateGte: kotlin.String? = null, filingDateLt: kotlin.String? = null, filingDateLte: kotlin.String? = null, fiscalYear: kotlin.Double? = null, fiscalYearGt: kotlin.Double? = null, fiscalYearGte: kotlin.Double? = null, fiscalYearLt: kotlin.Double? = null, fiscalYearLte: kotlin.Double? = null, fiscalQuarter: kotlin.Double? = null, fiscalQuarterGt: kotlin.Double? = null, fiscalQuarterGte: kotlin.Double? = null, fiscalQuarterLt: kotlin.Double? = null, fiscalQuarterLte: kotlin.Double? = null, timeframe: kotlin.String? = null, timeframeAnyOf: kotlin.String? = null, timeframeGt: kotlin.String? = null, timeframeGte: kotlin.String? = null, timeframeLt: kotlin.String? = null, timeframeLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "period_end.asc") : GetStocksFinancialsV1IncomeStatements200Response {
        val localVarResponse = getStocksFinancialsV1IncomeStatementsWithHttpInfo(cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, tickers = tickers, tickersAllOf = tickersAllOf, tickersAnyOf = tickersAnyOf, periodEnd = periodEnd, periodEndGt = periodEndGt, periodEndGte = periodEndGte, periodEndLt = periodEndLt, periodEndLte = periodEndLte, filingDate = filingDate, filingDateGt = filingDateGt, filingDateGte = filingDateGte, filingDateLt = filingDateLt, filingDateLte = filingDateLte, fiscalYear = fiscalYear, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalQuarter = fiscalQuarter, fiscalQuarterGt = fiscalQuarterGt, fiscalQuarterGte = fiscalQuarterGte, fiscalQuarterLt = fiscalQuarterLt, fiscalQuarterLte = fiscalQuarterLte, timeframe = timeframe, timeframeAnyOf = timeframeAnyOf, timeframeGt = timeframeGt, timeframeGte = timeframeGte, timeframeLt = timeframeLt, timeframeLte = timeframeLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksFinancialsV1IncomeStatements200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/financials/v1/income-statements
     * 
     * A comprehensive database of income statement financial data for public companies, including key metrics such as revenue, expenses, and net income for various reporting periods.
     * @param cik The company&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param periodEnd The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDate The date when the financial statement was filed with the SEC. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param fiscalYear The fiscal year for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalQuarterGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months. (optional)
     * @param timeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param timeframeGt Filter greater than the value. (optional)
     * @param timeframeGte Filter greater than or equal to the value. (optional)
     * @param timeframeLt Filter less than the value. (optional)
     * @param timeframeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "period_end.asc")
     * @return ApiResponse<GetStocksFinancialsV1IncomeStatements200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksFinancialsV1IncomeStatementsWithHttpInfo(cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, tickers: kotlin.String?, tickersAllOf: kotlin.String?, tickersAnyOf: kotlin.String?, periodEnd: kotlin.String?, periodEndGt: kotlin.String?, periodEndGte: kotlin.String?, periodEndLt: kotlin.String?, periodEndLte: kotlin.String?, filingDate: kotlin.String?, filingDateGt: kotlin.String?, filingDateGte: kotlin.String?, filingDateLt: kotlin.String?, filingDateLte: kotlin.String?, fiscalYear: kotlin.Double?, fiscalYearGt: kotlin.Double?, fiscalYearGte: kotlin.Double?, fiscalYearLt: kotlin.Double?, fiscalYearLte: kotlin.Double?, fiscalQuarter: kotlin.Double?, fiscalQuarterGt: kotlin.Double?, fiscalQuarterGte: kotlin.Double?, fiscalQuarterLt: kotlin.Double?, fiscalQuarterLte: kotlin.Double?, timeframe: kotlin.String?, timeframeAnyOf: kotlin.String?, timeframeGt: kotlin.String?, timeframeGte: kotlin.String?, timeframeLt: kotlin.String?, timeframeLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksFinancialsV1IncomeStatements200Response?> {
        val localVariableConfig = getStocksFinancialsV1IncomeStatementsRequestConfig(cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, tickers = tickers, tickersAllOf = tickersAllOf, tickersAnyOf = tickersAnyOf, periodEnd = periodEnd, periodEndGt = periodEndGt, periodEndGte = periodEndGte, periodEndLt = periodEndLt, periodEndLte = periodEndLte, filingDate = filingDate, filingDateGt = filingDateGt, filingDateGte = filingDateGte, filingDateLt = filingDateLt, filingDateLte = filingDateLte, fiscalYear = fiscalYear, fiscalYearGt = fiscalYearGt, fiscalYearGte = fiscalYearGte, fiscalYearLt = fiscalYearLt, fiscalYearLte = fiscalYearLte, fiscalQuarter = fiscalQuarter, fiscalQuarterGt = fiscalQuarterGt, fiscalQuarterGte = fiscalQuarterGte, fiscalQuarterLt = fiscalQuarterLt, fiscalQuarterLte = fiscalQuarterLte, timeframe = timeframe, timeframeAnyOf = timeframeAnyOf, timeframeGt = timeframeGt, timeframeGte = timeframeGte, timeframeLt = timeframeLt, timeframeLte = timeframeLte, limit = limit, sort = sort)

        return request<Unit, GetStocksFinancialsV1IncomeStatements200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksFinancialsV1IncomeStatements
     *
     * @param cik The company&#39;s Central Index Key (CIK), a unique identifier assigned by the U.S. Securities and Exchange Commission (SEC). You can look up a companys CIK using the [SEC CIK Lookup tool](https://www.sec.gov/search-filings/cik-lookup). (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param tickers Filter for arrays that contain the value. (optional)
     * @param tickersAllOf Filter for arrays that contain all of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickersAnyOf Filter for arrays that contain any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param periodEnd The last date of the reporting period (formatted as YYYY-MM-DD). Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param periodEndLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDate The date when the financial statement was filed with the SEC. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param filingDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param fiscalYear The fiscal year for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalYearGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalYearGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalYearLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalYearLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarter The fiscal quarter number (1, 2, 3, or 4) for the reporting period. Value must be a floating point number. (optional)
     * @param fiscalQuarterGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLt Filter less than the value. Value must be a floating point number. (optional)
     * @param fiscalQuarterLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param timeframe The reporting period type. Possible values include: quarterly, annual, trailing_twelve_months. (optional)
     * @param timeframeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param timeframeGt Filter greater than the value. (optional)
     * @param timeframeGte Filter greater than or equal to the value. (optional)
     * @param timeframeLt Filter less than the value. (optional)
     * @param timeframeLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;period_end&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "period_end.asc")
     * @return RequestConfig
     */
    fun getStocksFinancialsV1IncomeStatementsRequestConfig(cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, tickers: kotlin.String?, tickersAllOf: kotlin.String?, tickersAnyOf: kotlin.String?, periodEnd: kotlin.String?, periodEndGt: kotlin.String?, periodEndGte: kotlin.String?, periodEndLt: kotlin.String?, periodEndLte: kotlin.String?, filingDate: kotlin.String?, filingDateGt: kotlin.String?, filingDateGte: kotlin.String?, filingDateLt: kotlin.String?, filingDateLte: kotlin.String?, fiscalYear: kotlin.Double?, fiscalYearGt: kotlin.Double?, fiscalYearGte: kotlin.Double?, fiscalYearLt: kotlin.Double?, fiscalYearLte: kotlin.Double?, fiscalQuarter: kotlin.Double?, fiscalQuarterGt: kotlin.Double?, fiscalQuarterGte: kotlin.Double?, fiscalQuarterLt: kotlin.Double?, fiscalQuarterLte: kotlin.Double?, timeframe: kotlin.String?, timeframeAnyOf: kotlin.String?, timeframeGt: kotlin.String?, timeframeGte: kotlin.String?, timeframeLt: kotlin.String?, timeframeLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (cik != null) {
                    put("cik", listOf(cik.toString()))
                }
                if (cikAnyOf != null) {
                    put("cik.any_of", listOf(cikAnyOf.toString()))
                }
                if (cikGt != null) {
                    put("cik.gt", listOf(cikGt.toString()))
                }
                if (cikGte != null) {
                    put("cik.gte", listOf(cikGte.toString()))
                }
                if (cikLt != null) {
                    put("cik.lt", listOf(cikLt.toString()))
                }
                if (cikLte != null) {
                    put("cik.lte", listOf(cikLte.toString()))
                }
                if (tickers != null) {
                    put("tickers", listOf(tickers.toString()))
                }
                if (tickersAllOf != null) {
                    put("tickers.all_of", listOf(tickersAllOf.toString()))
                }
                if (tickersAnyOf != null) {
                    put("tickers.any_of", listOf(tickersAnyOf.toString()))
                }
                if (periodEnd != null) {
                    put("period_end", listOf(periodEnd.toString()))
                }
                if (periodEndGt != null) {
                    put("period_end.gt", listOf(periodEndGt.toString()))
                }
                if (periodEndGte != null) {
                    put("period_end.gte", listOf(periodEndGte.toString()))
                }
                if (periodEndLt != null) {
                    put("period_end.lt", listOf(periodEndLt.toString()))
                }
                if (periodEndLte != null) {
                    put("period_end.lte", listOf(periodEndLte.toString()))
                }
                if (filingDate != null) {
                    put("filing_date", listOf(filingDate.toString()))
                }
                if (filingDateGt != null) {
                    put("filing_date.gt", listOf(filingDateGt.toString()))
                }
                if (filingDateGte != null) {
                    put("filing_date.gte", listOf(filingDateGte.toString()))
                }
                if (filingDateLt != null) {
                    put("filing_date.lt", listOf(filingDateLt.toString()))
                }
                if (filingDateLte != null) {
                    put("filing_date.lte", listOf(filingDateLte.toString()))
                }
                if (fiscalYear != null) {
                    put("fiscal_year", listOf(fiscalYear.toString()))
                }
                if (fiscalYearGt != null) {
                    put("fiscal_year.gt", listOf(fiscalYearGt.toString()))
                }
                if (fiscalYearGte != null) {
                    put("fiscal_year.gte", listOf(fiscalYearGte.toString()))
                }
                if (fiscalYearLt != null) {
                    put("fiscal_year.lt", listOf(fiscalYearLt.toString()))
                }
                if (fiscalYearLte != null) {
                    put("fiscal_year.lte", listOf(fiscalYearLte.toString()))
                }
                if (fiscalQuarter != null) {
                    put("fiscal_quarter", listOf(fiscalQuarter.toString()))
                }
                if (fiscalQuarterGt != null) {
                    put("fiscal_quarter.gt", listOf(fiscalQuarterGt.toString()))
                }
                if (fiscalQuarterGte != null) {
                    put("fiscal_quarter.gte", listOf(fiscalQuarterGte.toString()))
                }
                if (fiscalQuarterLt != null) {
                    put("fiscal_quarter.lt", listOf(fiscalQuarterLt.toString()))
                }
                if (fiscalQuarterLte != null) {
                    put("fiscal_quarter.lte", listOf(fiscalQuarterLte.toString()))
                }
                if (timeframe != null) {
                    put("timeframe", listOf(timeframe.toString()))
                }
                if (timeframeAnyOf != null) {
                    put("timeframe.any_of", listOf(timeframeAnyOf.toString()))
                }
                if (timeframeGt != null) {
                    put("timeframe.gt", listOf(timeframeGt.toString()))
                }
                if (timeframeGte != null) {
                    put("timeframe.gte", listOf(timeframeGte.toString()))
                }
                if (timeframeLt != null) {
                    put("timeframe.lt", listOf(timeframeLt.toString()))
                }
                if (timeframeLte != null) {
                    put("timeframe.lte", listOf(timeframeLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/financials/v1/income-statements",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /stocks/financials/v1/ratios
     * 
     * A comprehensive financial ratios dataset providing key valuation, profitability, liquidity, and leverage metrics for public companies. Combines data from income statements, balance sheets, and cash flow statements with daily stock prices to calculate ratios on a daily basis. Uses trailing twelve months (TTM) data for income/cash flow metrics and quarterly data for balance sheet items. Fundamental data updates are applied starting from each filing&#39;s period end date. Market cap calculations use point-in-time shares outstanding for historical accuracy.
     * @param ticker Stock ticker symbol for the company. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param cik Central Index Key (CIK) number assigned by the SEC to identify the company. (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param price Stock price used in ratio calculations, typically the closing price for the given date. Value must be a floating point number. (optional)
     * @param priceGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param averageVolume Average trading volume over the last 30 trading days, providing context for liquidity. Value must be a floating point number. (optional)
     * @param averageVolumeGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param averageVolumeGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param averageVolumeLt Filter less than the value. Value must be a floating point number. (optional)
     * @param averageVolumeLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param marketCap Market capitalization, calculated as stock price multiplied by total shares outstanding. Value must be a floating point number. (optional)
     * @param marketCapGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param marketCapGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param marketCapLt Filter less than the value. Value must be a floating point number. (optional)
     * @param marketCapLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param earningsPerShare Earnings per share, calculated as net income available to common shareholders divided by weighted shares outstanding. Value must be a floating point number. (optional)
     * @param earningsPerShareGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param earningsPerShareGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param earningsPerShareLt Filter less than the value. Value must be a floating point number. (optional)
     * @param earningsPerShareLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToEarnings Price-to-earnings ratio, calculated as stock price divided by earnings per share. Only calculated when earnings per share is positive. Value must be a floating point number. (optional)
     * @param priceToEarningsGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToEarningsGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToEarningsLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToEarningsLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToBook Price-to-book ratio, calculated as stock price divided by book value per share, comparing market value to book value. Value must be a floating point number. (optional)
     * @param priceToBookGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToBookGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToBookLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToBookLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToSales Price-to-sales ratio, calculated as stock price divided by revenue per share, measuring valuation relative to sales. Value must be a floating point number. (optional)
     * @param priceToSalesGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToSalesGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToSalesLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToSalesLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToCashFlow Price-to-cash-flow ratio, calculated as stock price divided by operating cash flow per share. Only calculated when operating cash flow per share is positive. Value must be a floating point number. (optional)
     * @param priceToCashFlowGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToCashFlowGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToCashFlowLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToCashFlowLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlow Price-to-free-cash-flow ratio, calculated as stock price divided by free cash flow per share. Only calculated when free cash flow per share is positive. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param dividendYield Dividend yield, calculated as annual dividends per share divided by stock price, measuring the income return on investment. Value must be a floating point number. (optional)
     * @param dividendYieldGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param dividendYieldGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param dividendYieldLt Filter less than the value. Value must be a floating point number. (optional)
     * @param dividendYieldLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnAssets Return on assets ratio, calculated as net income divided by total assets, measuring how efficiently a company uses its assets to generate profit. Value must be a floating point number. (optional)
     * @param returnOnAssetsGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param returnOnAssetsGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnAssetsLt Filter less than the value. Value must be a floating point number. (optional)
     * @param returnOnAssetsLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnEquity Return on equity ratio, calculated as net income divided by total shareholders&#39; equity, measuring profitability relative to shareholders&#39; equity. Value must be a floating point number. (optional)
     * @param returnOnEquityGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param returnOnEquityGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnEquityLt Filter less than the value. Value must be a floating point number. (optional)
     * @param returnOnEquityLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param debtToEquity Debt-to-equity ratio, calculated as total debt (current debt plus long-term debt) divided by total shareholders&#39; equity, measuring financial leverage. Value must be a floating point number. (optional)
     * @param debtToEquityGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param debtToEquityGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param debtToEquityLt Filter less than the value. Value must be a floating point number. (optional)
     * @param debtToEquityLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param current Current ratio, calculated as total current assets divided by total current liabilities, measuring short-term liquidity. Value must be a floating point number. (optional)
     * @param currentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param currentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param currentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param currentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quick Quick ratio (acid-test ratio), calculated as (current assets minus inventories) divided by current liabilities, measuring immediate liquidity. Value must be a floating point number. (optional)
     * @param quickGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quickGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quickLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quickLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param cash Cash ratio, calculated as cash and cash equivalents divided by current liabilities, measuring the most liquid form of liquidity coverage. Value must be a floating point number. (optional)
     * @param cashGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param cashGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param cashLt Filter less than the value. Value must be a floating point number. (optional)
     * @param cashLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param evToSales Enterprise value to sales ratio, calculated as enterprise value divided by revenue, measuring company valuation relative to sales. Value must be a floating point number. (optional)
     * @param evToSalesGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param evToSalesGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param evToSalesLt Filter less than the value. Value must be a floating point number. (optional)
     * @param evToSalesLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param evToEbitda Enterprise value to EBITDA ratio, calculated as enterprise value divided by EBITDA, measuring company valuation relative to earnings before interest, taxes, depreciation, and amortization. Value must be a floating point number. (optional)
     * @param evToEbitdaGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param evToEbitdaGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param evToEbitdaLt Filter less than the value. Value must be a floating point number. (optional)
     * @param evToEbitdaLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param enterpriseValue Enterprise value, calculated as market capitalization plus total debt minus cash and cash equivalents, representing total company value. Value must be a floating point number. (optional)
     * @param enterpriseValueGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param enterpriseValueGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param enterpriseValueLt Filter less than the value. Value must be a floating point number. (optional)
     * @param enterpriseValueLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param freeCashFlow Free cash flow, calculated as operating cash flow minus capital expenditures (purchase of property, plant, and equipment). Value must be a floating point number. (optional)
     * @param freeCashFlowGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param freeCashFlowGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param freeCashFlowLt Filter less than the value. Value must be a floating point number. (optional)
     * @param freeCashFlowLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return GetStocksFinancialsV1Ratios200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksFinancialsV1Ratios(ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, cik: kotlin.String? = null, cikAnyOf: kotlin.String? = null, cikGt: kotlin.String? = null, cikGte: kotlin.String? = null, cikLt: kotlin.String? = null, cikLte: kotlin.String? = null, price: kotlin.Double? = null, priceGt: kotlin.Double? = null, priceGte: kotlin.Double? = null, priceLt: kotlin.Double? = null, priceLte: kotlin.Double? = null, averageVolume: kotlin.Double? = null, averageVolumeGt: kotlin.Double? = null, averageVolumeGte: kotlin.Double? = null, averageVolumeLt: kotlin.Double? = null, averageVolumeLte: kotlin.Double? = null, marketCap: kotlin.Double? = null, marketCapGt: kotlin.Double? = null, marketCapGte: kotlin.Double? = null, marketCapLt: kotlin.Double? = null, marketCapLte: kotlin.Double? = null, earningsPerShare: kotlin.Double? = null, earningsPerShareGt: kotlin.Double? = null, earningsPerShareGte: kotlin.Double? = null, earningsPerShareLt: kotlin.Double? = null, earningsPerShareLte: kotlin.Double? = null, priceToEarnings: kotlin.Double? = null, priceToEarningsGt: kotlin.Double? = null, priceToEarningsGte: kotlin.Double? = null, priceToEarningsLt: kotlin.Double? = null, priceToEarningsLte: kotlin.Double? = null, priceToBook: kotlin.Double? = null, priceToBookGt: kotlin.Double? = null, priceToBookGte: kotlin.Double? = null, priceToBookLt: kotlin.Double? = null, priceToBookLte: kotlin.Double? = null, priceToSales: kotlin.Double? = null, priceToSalesGt: kotlin.Double? = null, priceToSalesGte: kotlin.Double? = null, priceToSalesLt: kotlin.Double? = null, priceToSalesLte: kotlin.Double? = null, priceToCashFlow: kotlin.Double? = null, priceToCashFlowGt: kotlin.Double? = null, priceToCashFlowGte: kotlin.Double? = null, priceToCashFlowLt: kotlin.Double? = null, priceToCashFlowLte: kotlin.Double? = null, priceToFreeCashFlow: kotlin.Double? = null, priceToFreeCashFlowGt: kotlin.Double? = null, priceToFreeCashFlowGte: kotlin.Double? = null, priceToFreeCashFlowLt: kotlin.Double? = null, priceToFreeCashFlowLte: kotlin.Double? = null, dividendYield: kotlin.Double? = null, dividendYieldGt: kotlin.Double? = null, dividendYieldGte: kotlin.Double? = null, dividendYieldLt: kotlin.Double? = null, dividendYieldLte: kotlin.Double? = null, returnOnAssets: kotlin.Double? = null, returnOnAssetsGt: kotlin.Double? = null, returnOnAssetsGte: kotlin.Double? = null, returnOnAssetsLt: kotlin.Double? = null, returnOnAssetsLte: kotlin.Double? = null, returnOnEquity: kotlin.Double? = null, returnOnEquityGt: kotlin.Double? = null, returnOnEquityGte: kotlin.Double? = null, returnOnEquityLt: kotlin.Double? = null, returnOnEquityLte: kotlin.Double? = null, debtToEquity: kotlin.Double? = null, debtToEquityGt: kotlin.Double? = null, debtToEquityGte: kotlin.Double? = null, debtToEquityLt: kotlin.Double? = null, debtToEquityLte: kotlin.Double? = null, current: kotlin.Double? = null, currentGt: kotlin.Double? = null, currentGte: kotlin.Double? = null, currentLt: kotlin.Double? = null, currentLte: kotlin.Double? = null, quick: kotlin.Double? = null, quickGt: kotlin.Double? = null, quickGte: kotlin.Double? = null, quickLt: kotlin.Double? = null, quickLte: kotlin.Double? = null, cash: kotlin.Double? = null, cashGt: kotlin.Double? = null, cashGte: kotlin.Double? = null, cashLt: kotlin.Double? = null, cashLte: kotlin.Double? = null, evToSales: kotlin.Double? = null, evToSalesGt: kotlin.Double? = null, evToSalesGte: kotlin.Double? = null, evToSalesLt: kotlin.Double? = null, evToSalesLte: kotlin.Double? = null, evToEbitda: kotlin.Double? = null, evToEbitdaGt: kotlin.Double? = null, evToEbitdaGte: kotlin.Double? = null, evToEbitdaLt: kotlin.Double? = null, evToEbitdaLte: kotlin.Double? = null, enterpriseValue: kotlin.Double? = null, enterpriseValueGt: kotlin.Double? = null, enterpriseValueGte: kotlin.Double? = null, enterpriseValueLt: kotlin.Double? = null, enterpriseValueLte: kotlin.Double? = null, freeCashFlow: kotlin.Double? = null, freeCashFlowGt: kotlin.Double? = null, freeCashFlowGte: kotlin.Double? = null, freeCashFlowLt: kotlin.Double? = null, freeCashFlowLte: kotlin.Double? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "ticker.asc") : GetStocksFinancialsV1Ratios200Response {
        val localVarResponse = getStocksFinancialsV1RatiosWithHttpInfo(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, price = price, priceGt = priceGt, priceGte = priceGte, priceLt = priceLt, priceLte = priceLte, averageVolume = averageVolume, averageVolumeGt = averageVolumeGt, averageVolumeGte = averageVolumeGte, averageVolumeLt = averageVolumeLt, averageVolumeLte = averageVolumeLte, marketCap = marketCap, marketCapGt = marketCapGt, marketCapGte = marketCapGte, marketCapLt = marketCapLt, marketCapLte = marketCapLte, earningsPerShare = earningsPerShare, earningsPerShareGt = earningsPerShareGt, earningsPerShareGte = earningsPerShareGte, earningsPerShareLt = earningsPerShareLt, earningsPerShareLte = earningsPerShareLte, priceToEarnings = priceToEarnings, priceToEarningsGt = priceToEarningsGt, priceToEarningsGte = priceToEarningsGte, priceToEarningsLt = priceToEarningsLt, priceToEarningsLte = priceToEarningsLte, priceToBook = priceToBook, priceToBookGt = priceToBookGt, priceToBookGte = priceToBookGte, priceToBookLt = priceToBookLt, priceToBookLte = priceToBookLte, priceToSales = priceToSales, priceToSalesGt = priceToSalesGt, priceToSalesGte = priceToSalesGte, priceToSalesLt = priceToSalesLt, priceToSalesLte = priceToSalesLte, priceToCashFlow = priceToCashFlow, priceToCashFlowGt = priceToCashFlowGt, priceToCashFlowGte = priceToCashFlowGte, priceToCashFlowLt = priceToCashFlowLt, priceToCashFlowLte = priceToCashFlowLte, priceToFreeCashFlow = priceToFreeCashFlow, priceToFreeCashFlowGt = priceToFreeCashFlowGt, priceToFreeCashFlowGte = priceToFreeCashFlowGte, priceToFreeCashFlowLt = priceToFreeCashFlowLt, priceToFreeCashFlowLte = priceToFreeCashFlowLte, dividendYield = dividendYield, dividendYieldGt = dividendYieldGt, dividendYieldGte = dividendYieldGte, dividendYieldLt = dividendYieldLt, dividendYieldLte = dividendYieldLte, returnOnAssets = returnOnAssets, returnOnAssetsGt = returnOnAssetsGt, returnOnAssetsGte = returnOnAssetsGte, returnOnAssetsLt = returnOnAssetsLt, returnOnAssetsLte = returnOnAssetsLte, returnOnEquity = returnOnEquity, returnOnEquityGt = returnOnEquityGt, returnOnEquityGte = returnOnEquityGte, returnOnEquityLt = returnOnEquityLt, returnOnEquityLte = returnOnEquityLte, debtToEquity = debtToEquity, debtToEquityGt = debtToEquityGt, debtToEquityGte = debtToEquityGte, debtToEquityLt = debtToEquityLt, debtToEquityLte = debtToEquityLte, current = current, currentGt = currentGt, currentGte = currentGte, currentLt = currentLt, currentLte = currentLte, quick = quick, quickGt = quickGt, quickGte = quickGte, quickLt = quickLt, quickLte = quickLte, cash = cash, cashGt = cashGt, cashGte = cashGte, cashLt = cashLt, cashLte = cashLte, evToSales = evToSales, evToSalesGt = evToSalesGt, evToSalesGte = evToSalesGte, evToSalesLt = evToSalesLt, evToSalesLte = evToSalesLte, evToEbitda = evToEbitda, evToEbitdaGt = evToEbitdaGt, evToEbitdaGte = evToEbitdaGte, evToEbitdaLt = evToEbitdaLt, evToEbitdaLte = evToEbitdaLte, enterpriseValue = enterpriseValue, enterpriseValueGt = enterpriseValueGt, enterpriseValueGte = enterpriseValueGte, enterpriseValueLt = enterpriseValueLt, enterpriseValueLte = enterpriseValueLte, freeCashFlow = freeCashFlow, freeCashFlowGt = freeCashFlowGt, freeCashFlowGte = freeCashFlowGte, freeCashFlowLt = freeCashFlowLt, freeCashFlowLte = freeCashFlowLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksFinancialsV1Ratios200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/financials/v1/ratios
     * 
     * A comprehensive financial ratios dataset providing key valuation, profitability, liquidity, and leverage metrics for public companies. Combines data from income statements, balance sheets, and cash flow statements with daily stock prices to calculate ratios on a daily basis. Uses trailing twelve months (TTM) data for income/cash flow metrics and quarterly data for balance sheet items. Fundamental data updates are applied starting from each filing&#39;s period end date. Market cap calculations use point-in-time shares outstanding for historical accuracy.
     * @param ticker Stock ticker symbol for the company. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param cik Central Index Key (CIK) number assigned by the SEC to identify the company. (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param price Stock price used in ratio calculations, typically the closing price for the given date. Value must be a floating point number. (optional)
     * @param priceGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param averageVolume Average trading volume over the last 30 trading days, providing context for liquidity. Value must be a floating point number. (optional)
     * @param averageVolumeGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param averageVolumeGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param averageVolumeLt Filter less than the value. Value must be a floating point number. (optional)
     * @param averageVolumeLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param marketCap Market capitalization, calculated as stock price multiplied by total shares outstanding. Value must be a floating point number. (optional)
     * @param marketCapGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param marketCapGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param marketCapLt Filter less than the value. Value must be a floating point number. (optional)
     * @param marketCapLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param earningsPerShare Earnings per share, calculated as net income available to common shareholders divided by weighted shares outstanding. Value must be a floating point number. (optional)
     * @param earningsPerShareGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param earningsPerShareGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param earningsPerShareLt Filter less than the value. Value must be a floating point number. (optional)
     * @param earningsPerShareLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToEarnings Price-to-earnings ratio, calculated as stock price divided by earnings per share. Only calculated when earnings per share is positive. Value must be a floating point number. (optional)
     * @param priceToEarningsGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToEarningsGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToEarningsLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToEarningsLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToBook Price-to-book ratio, calculated as stock price divided by book value per share, comparing market value to book value. Value must be a floating point number. (optional)
     * @param priceToBookGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToBookGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToBookLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToBookLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToSales Price-to-sales ratio, calculated as stock price divided by revenue per share, measuring valuation relative to sales. Value must be a floating point number. (optional)
     * @param priceToSalesGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToSalesGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToSalesLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToSalesLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToCashFlow Price-to-cash-flow ratio, calculated as stock price divided by operating cash flow per share. Only calculated when operating cash flow per share is positive. Value must be a floating point number. (optional)
     * @param priceToCashFlowGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToCashFlowGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToCashFlowLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToCashFlowLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlow Price-to-free-cash-flow ratio, calculated as stock price divided by free cash flow per share. Only calculated when free cash flow per share is positive. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param dividendYield Dividend yield, calculated as annual dividends per share divided by stock price, measuring the income return on investment. Value must be a floating point number. (optional)
     * @param dividendYieldGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param dividendYieldGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param dividendYieldLt Filter less than the value. Value must be a floating point number. (optional)
     * @param dividendYieldLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnAssets Return on assets ratio, calculated as net income divided by total assets, measuring how efficiently a company uses its assets to generate profit. Value must be a floating point number. (optional)
     * @param returnOnAssetsGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param returnOnAssetsGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnAssetsLt Filter less than the value. Value must be a floating point number. (optional)
     * @param returnOnAssetsLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnEquity Return on equity ratio, calculated as net income divided by total shareholders&#39; equity, measuring profitability relative to shareholders&#39; equity. Value must be a floating point number. (optional)
     * @param returnOnEquityGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param returnOnEquityGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnEquityLt Filter less than the value. Value must be a floating point number. (optional)
     * @param returnOnEquityLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param debtToEquity Debt-to-equity ratio, calculated as total debt (current debt plus long-term debt) divided by total shareholders&#39; equity, measuring financial leverage. Value must be a floating point number. (optional)
     * @param debtToEquityGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param debtToEquityGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param debtToEquityLt Filter less than the value. Value must be a floating point number. (optional)
     * @param debtToEquityLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param current Current ratio, calculated as total current assets divided by total current liabilities, measuring short-term liquidity. Value must be a floating point number. (optional)
     * @param currentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param currentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param currentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param currentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quick Quick ratio (acid-test ratio), calculated as (current assets minus inventories) divided by current liabilities, measuring immediate liquidity. Value must be a floating point number. (optional)
     * @param quickGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quickGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quickLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quickLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param cash Cash ratio, calculated as cash and cash equivalents divided by current liabilities, measuring the most liquid form of liquidity coverage. Value must be a floating point number. (optional)
     * @param cashGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param cashGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param cashLt Filter less than the value. Value must be a floating point number. (optional)
     * @param cashLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param evToSales Enterprise value to sales ratio, calculated as enterprise value divided by revenue, measuring company valuation relative to sales. Value must be a floating point number. (optional)
     * @param evToSalesGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param evToSalesGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param evToSalesLt Filter less than the value. Value must be a floating point number. (optional)
     * @param evToSalesLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param evToEbitda Enterprise value to EBITDA ratio, calculated as enterprise value divided by EBITDA, measuring company valuation relative to earnings before interest, taxes, depreciation, and amortization. Value must be a floating point number. (optional)
     * @param evToEbitdaGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param evToEbitdaGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param evToEbitdaLt Filter less than the value. Value must be a floating point number. (optional)
     * @param evToEbitdaLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param enterpriseValue Enterprise value, calculated as market capitalization plus total debt minus cash and cash equivalents, representing total company value. Value must be a floating point number. (optional)
     * @param enterpriseValueGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param enterpriseValueGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param enterpriseValueLt Filter less than the value. Value must be a floating point number. (optional)
     * @param enterpriseValueLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param freeCashFlow Free cash flow, calculated as operating cash flow minus capital expenditures (purchase of property, plant, and equipment). Value must be a floating point number. (optional)
     * @param freeCashFlowGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param freeCashFlowGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param freeCashFlowLt Filter less than the value. Value must be a floating point number. (optional)
     * @param freeCashFlowLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return ApiResponse<GetStocksFinancialsV1Ratios200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksFinancialsV1RatiosWithHttpInfo(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, price: kotlin.Double?, priceGt: kotlin.Double?, priceGte: kotlin.Double?, priceLt: kotlin.Double?, priceLte: kotlin.Double?, averageVolume: kotlin.Double?, averageVolumeGt: kotlin.Double?, averageVolumeGte: kotlin.Double?, averageVolumeLt: kotlin.Double?, averageVolumeLte: kotlin.Double?, marketCap: kotlin.Double?, marketCapGt: kotlin.Double?, marketCapGte: kotlin.Double?, marketCapLt: kotlin.Double?, marketCapLte: kotlin.Double?, earningsPerShare: kotlin.Double?, earningsPerShareGt: kotlin.Double?, earningsPerShareGte: kotlin.Double?, earningsPerShareLt: kotlin.Double?, earningsPerShareLte: kotlin.Double?, priceToEarnings: kotlin.Double?, priceToEarningsGt: kotlin.Double?, priceToEarningsGte: kotlin.Double?, priceToEarningsLt: kotlin.Double?, priceToEarningsLte: kotlin.Double?, priceToBook: kotlin.Double?, priceToBookGt: kotlin.Double?, priceToBookGte: kotlin.Double?, priceToBookLt: kotlin.Double?, priceToBookLte: kotlin.Double?, priceToSales: kotlin.Double?, priceToSalesGt: kotlin.Double?, priceToSalesGte: kotlin.Double?, priceToSalesLt: kotlin.Double?, priceToSalesLte: kotlin.Double?, priceToCashFlow: kotlin.Double?, priceToCashFlowGt: kotlin.Double?, priceToCashFlowGte: kotlin.Double?, priceToCashFlowLt: kotlin.Double?, priceToCashFlowLte: kotlin.Double?, priceToFreeCashFlow: kotlin.Double?, priceToFreeCashFlowGt: kotlin.Double?, priceToFreeCashFlowGte: kotlin.Double?, priceToFreeCashFlowLt: kotlin.Double?, priceToFreeCashFlowLte: kotlin.Double?, dividendYield: kotlin.Double?, dividendYieldGt: kotlin.Double?, dividendYieldGte: kotlin.Double?, dividendYieldLt: kotlin.Double?, dividendYieldLte: kotlin.Double?, returnOnAssets: kotlin.Double?, returnOnAssetsGt: kotlin.Double?, returnOnAssetsGte: kotlin.Double?, returnOnAssetsLt: kotlin.Double?, returnOnAssetsLte: kotlin.Double?, returnOnEquity: kotlin.Double?, returnOnEquityGt: kotlin.Double?, returnOnEquityGte: kotlin.Double?, returnOnEquityLt: kotlin.Double?, returnOnEquityLte: kotlin.Double?, debtToEquity: kotlin.Double?, debtToEquityGt: kotlin.Double?, debtToEquityGte: kotlin.Double?, debtToEquityLt: kotlin.Double?, debtToEquityLte: kotlin.Double?, current: kotlin.Double?, currentGt: kotlin.Double?, currentGte: kotlin.Double?, currentLt: kotlin.Double?, currentLte: kotlin.Double?, quick: kotlin.Double?, quickGt: kotlin.Double?, quickGte: kotlin.Double?, quickLt: kotlin.Double?, quickLte: kotlin.Double?, cash: kotlin.Double?, cashGt: kotlin.Double?, cashGte: kotlin.Double?, cashLt: kotlin.Double?, cashLte: kotlin.Double?, evToSales: kotlin.Double?, evToSalesGt: kotlin.Double?, evToSalesGte: kotlin.Double?, evToSalesLt: kotlin.Double?, evToSalesLte: kotlin.Double?, evToEbitda: kotlin.Double?, evToEbitdaGt: kotlin.Double?, evToEbitdaGte: kotlin.Double?, evToEbitdaLt: kotlin.Double?, evToEbitdaLte: kotlin.Double?, enterpriseValue: kotlin.Double?, enterpriseValueGt: kotlin.Double?, enterpriseValueGte: kotlin.Double?, enterpriseValueLt: kotlin.Double?, enterpriseValueLte: kotlin.Double?, freeCashFlow: kotlin.Double?, freeCashFlowGt: kotlin.Double?, freeCashFlowGte: kotlin.Double?, freeCashFlowLt: kotlin.Double?, freeCashFlowLte: kotlin.Double?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksFinancialsV1Ratios200Response?> {
        val localVariableConfig = getStocksFinancialsV1RatiosRequestConfig(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, cik = cik, cikAnyOf = cikAnyOf, cikGt = cikGt, cikGte = cikGte, cikLt = cikLt, cikLte = cikLte, price = price, priceGt = priceGt, priceGte = priceGte, priceLt = priceLt, priceLte = priceLte, averageVolume = averageVolume, averageVolumeGt = averageVolumeGt, averageVolumeGte = averageVolumeGte, averageVolumeLt = averageVolumeLt, averageVolumeLte = averageVolumeLte, marketCap = marketCap, marketCapGt = marketCapGt, marketCapGte = marketCapGte, marketCapLt = marketCapLt, marketCapLte = marketCapLte, earningsPerShare = earningsPerShare, earningsPerShareGt = earningsPerShareGt, earningsPerShareGte = earningsPerShareGte, earningsPerShareLt = earningsPerShareLt, earningsPerShareLte = earningsPerShareLte, priceToEarnings = priceToEarnings, priceToEarningsGt = priceToEarningsGt, priceToEarningsGte = priceToEarningsGte, priceToEarningsLt = priceToEarningsLt, priceToEarningsLte = priceToEarningsLte, priceToBook = priceToBook, priceToBookGt = priceToBookGt, priceToBookGte = priceToBookGte, priceToBookLt = priceToBookLt, priceToBookLte = priceToBookLte, priceToSales = priceToSales, priceToSalesGt = priceToSalesGt, priceToSalesGte = priceToSalesGte, priceToSalesLt = priceToSalesLt, priceToSalesLte = priceToSalesLte, priceToCashFlow = priceToCashFlow, priceToCashFlowGt = priceToCashFlowGt, priceToCashFlowGte = priceToCashFlowGte, priceToCashFlowLt = priceToCashFlowLt, priceToCashFlowLte = priceToCashFlowLte, priceToFreeCashFlow = priceToFreeCashFlow, priceToFreeCashFlowGt = priceToFreeCashFlowGt, priceToFreeCashFlowGte = priceToFreeCashFlowGte, priceToFreeCashFlowLt = priceToFreeCashFlowLt, priceToFreeCashFlowLte = priceToFreeCashFlowLte, dividendYield = dividendYield, dividendYieldGt = dividendYieldGt, dividendYieldGte = dividendYieldGte, dividendYieldLt = dividendYieldLt, dividendYieldLte = dividendYieldLte, returnOnAssets = returnOnAssets, returnOnAssetsGt = returnOnAssetsGt, returnOnAssetsGte = returnOnAssetsGte, returnOnAssetsLt = returnOnAssetsLt, returnOnAssetsLte = returnOnAssetsLte, returnOnEquity = returnOnEquity, returnOnEquityGt = returnOnEquityGt, returnOnEquityGte = returnOnEquityGte, returnOnEquityLt = returnOnEquityLt, returnOnEquityLte = returnOnEquityLte, debtToEquity = debtToEquity, debtToEquityGt = debtToEquityGt, debtToEquityGte = debtToEquityGte, debtToEquityLt = debtToEquityLt, debtToEquityLte = debtToEquityLte, current = current, currentGt = currentGt, currentGte = currentGte, currentLt = currentLt, currentLte = currentLte, quick = quick, quickGt = quickGt, quickGte = quickGte, quickLt = quickLt, quickLte = quickLte, cash = cash, cashGt = cashGt, cashGte = cashGte, cashLt = cashLt, cashLte = cashLte, evToSales = evToSales, evToSalesGt = evToSalesGt, evToSalesGte = evToSalesGte, evToSalesLt = evToSalesLt, evToSalesLte = evToSalesLte, evToEbitda = evToEbitda, evToEbitdaGt = evToEbitdaGt, evToEbitdaGte = evToEbitdaGte, evToEbitdaLt = evToEbitdaLt, evToEbitdaLte = evToEbitdaLte, enterpriseValue = enterpriseValue, enterpriseValueGt = enterpriseValueGt, enterpriseValueGte = enterpriseValueGte, enterpriseValueLt = enterpriseValueLt, enterpriseValueLte = enterpriseValueLte, freeCashFlow = freeCashFlow, freeCashFlowGt = freeCashFlowGt, freeCashFlowGte = freeCashFlowGte, freeCashFlowLt = freeCashFlowLt, freeCashFlowLte = freeCashFlowLte, limit = limit, sort = sort)

        return request<Unit, GetStocksFinancialsV1Ratios200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksFinancialsV1Ratios
     *
     * @param ticker Stock ticker symbol for the company. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param cik Central Index Key (CIK) number assigned by the SEC to identify the company. (optional)
     * @param cikAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param cikGt Filter greater than the value. (optional)
     * @param cikGte Filter greater than or equal to the value. (optional)
     * @param cikLt Filter less than the value. (optional)
     * @param cikLte Filter less than or equal to the value. (optional)
     * @param price Stock price used in ratio calculations, typically the closing price for the given date. Value must be a floating point number. (optional)
     * @param priceGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param averageVolume Average trading volume over the last 30 trading days, providing context for liquidity. Value must be a floating point number. (optional)
     * @param averageVolumeGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param averageVolumeGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param averageVolumeLt Filter less than the value. Value must be a floating point number. (optional)
     * @param averageVolumeLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param marketCap Market capitalization, calculated as stock price multiplied by total shares outstanding. Value must be a floating point number. (optional)
     * @param marketCapGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param marketCapGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param marketCapLt Filter less than the value. Value must be a floating point number. (optional)
     * @param marketCapLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param earningsPerShare Earnings per share, calculated as net income available to common shareholders divided by weighted shares outstanding. Value must be a floating point number. (optional)
     * @param earningsPerShareGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param earningsPerShareGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param earningsPerShareLt Filter less than the value. Value must be a floating point number. (optional)
     * @param earningsPerShareLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToEarnings Price-to-earnings ratio, calculated as stock price divided by earnings per share. Only calculated when earnings per share is positive. Value must be a floating point number. (optional)
     * @param priceToEarningsGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToEarningsGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToEarningsLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToEarningsLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToBook Price-to-book ratio, calculated as stock price divided by book value per share, comparing market value to book value. Value must be a floating point number. (optional)
     * @param priceToBookGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToBookGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToBookLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToBookLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToSales Price-to-sales ratio, calculated as stock price divided by revenue per share, measuring valuation relative to sales. Value must be a floating point number. (optional)
     * @param priceToSalesGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToSalesGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToSalesLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToSalesLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToCashFlow Price-to-cash-flow ratio, calculated as stock price divided by operating cash flow per share. Only calculated when operating cash flow per share is positive. Value must be a floating point number. (optional)
     * @param priceToCashFlowGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToCashFlowGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToCashFlowLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToCashFlowLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlow Price-to-free-cash-flow ratio, calculated as stock price divided by free cash flow per share. Only calculated when free cash flow per share is positive. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowLt Filter less than the value. Value must be a floating point number. (optional)
     * @param priceToFreeCashFlowLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param dividendYield Dividend yield, calculated as annual dividends per share divided by stock price, measuring the income return on investment. Value must be a floating point number. (optional)
     * @param dividendYieldGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param dividendYieldGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param dividendYieldLt Filter less than the value. Value must be a floating point number. (optional)
     * @param dividendYieldLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnAssets Return on assets ratio, calculated as net income divided by total assets, measuring how efficiently a company uses its assets to generate profit. Value must be a floating point number. (optional)
     * @param returnOnAssetsGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param returnOnAssetsGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnAssetsLt Filter less than the value. Value must be a floating point number. (optional)
     * @param returnOnAssetsLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnEquity Return on equity ratio, calculated as net income divided by total shareholders&#39; equity, measuring profitability relative to shareholders&#39; equity. Value must be a floating point number. (optional)
     * @param returnOnEquityGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param returnOnEquityGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param returnOnEquityLt Filter less than the value. Value must be a floating point number. (optional)
     * @param returnOnEquityLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param debtToEquity Debt-to-equity ratio, calculated as total debt (current debt plus long-term debt) divided by total shareholders&#39; equity, measuring financial leverage. Value must be a floating point number. (optional)
     * @param debtToEquityGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param debtToEquityGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param debtToEquityLt Filter less than the value. Value must be a floating point number. (optional)
     * @param debtToEquityLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param current Current ratio, calculated as total current assets divided by total current liabilities, measuring short-term liquidity. Value must be a floating point number. (optional)
     * @param currentGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param currentGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param currentLt Filter less than the value. Value must be a floating point number. (optional)
     * @param currentLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param quick Quick ratio (acid-test ratio), calculated as (current assets minus inventories) divided by current liabilities, measuring immediate liquidity. Value must be a floating point number. (optional)
     * @param quickGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param quickGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param quickLt Filter less than the value. Value must be a floating point number. (optional)
     * @param quickLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param cash Cash ratio, calculated as cash and cash equivalents divided by current liabilities, measuring the most liquid form of liquidity coverage. Value must be a floating point number. (optional)
     * @param cashGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param cashGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param cashLt Filter less than the value. Value must be a floating point number. (optional)
     * @param cashLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param evToSales Enterprise value to sales ratio, calculated as enterprise value divided by revenue, measuring company valuation relative to sales. Value must be a floating point number. (optional)
     * @param evToSalesGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param evToSalesGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param evToSalesLt Filter less than the value. Value must be a floating point number. (optional)
     * @param evToSalesLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param evToEbitda Enterprise value to EBITDA ratio, calculated as enterprise value divided by EBITDA, measuring company valuation relative to earnings before interest, taxes, depreciation, and amortization. Value must be a floating point number. (optional)
     * @param evToEbitdaGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param evToEbitdaGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param evToEbitdaLt Filter less than the value. Value must be a floating point number. (optional)
     * @param evToEbitdaLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param enterpriseValue Enterprise value, calculated as market capitalization plus total debt minus cash and cash equivalents, representing total company value. Value must be a floating point number. (optional)
     * @param enterpriseValueGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param enterpriseValueGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param enterpriseValueLt Filter less than the value. Value must be a floating point number. (optional)
     * @param enterpriseValueLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param freeCashFlow Free cash flow, calculated as operating cash flow minus capital expenditures (purchase of property, plant, and equipment). Value must be a floating point number. (optional)
     * @param freeCashFlowGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param freeCashFlowGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param freeCashFlowLt Filter less than the value. Value must be a floating point number. (optional)
     * @param freeCashFlowLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return RequestConfig
     */
    fun getStocksFinancialsV1RatiosRequestConfig(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, cik: kotlin.String?, cikAnyOf: kotlin.String?, cikGt: kotlin.String?, cikGte: kotlin.String?, cikLt: kotlin.String?, cikLte: kotlin.String?, price: kotlin.Double?, priceGt: kotlin.Double?, priceGte: kotlin.Double?, priceLt: kotlin.Double?, priceLte: kotlin.Double?, averageVolume: kotlin.Double?, averageVolumeGt: kotlin.Double?, averageVolumeGte: kotlin.Double?, averageVolumeLt: kotlin.Double?, averageVolumeLte: kotlin.Double?, marketCap: kotlin.Double?, marketCapGt: kotlin.Double?, marketCapGte: kotlin.Double?, marketCapLt: kotlin.Double?, marketCapLte: kotlin.Double?, earningsPerShare: kotlin.Double?, earningsPerShareGt: kotlin.Double?, earningsPerShareGte: kotlin.Double?, earningsPerShareLt: kotlin.Double?, earningsPerShareLte: kotlin.Double?, priceToEarnings: kotlin.Double?, priceToEarningsGt: kotlin.Double?, priceToEarningsGte: kotlin.Double?, priceToEarningsLt: kotlin.Double?, priceToEarningsLte: kotlin.Double?, priceToBook: kotlin.Double?, priceToBookGt: kotlin.Double?, priceToBookGte: kotlin.Double?, priceToBookLt: kotlin.Double?, priceToBookLte: kotlin.Double?, priceToSales: kotlin.Double?, priceToSalesGt: kotlin.Double?, priceToSalesGte: kotlin.Double?, priceToSalesLt: kotlin.Double?, priceToSalesLte: kotlin.Double?, priceToCashFlow: kotlin.Double?, priceToCashFlowGt: kotlin.Double?, priceToCashFlowGte: kotlin.Double?, priceToCashFlowLt: kotlin.Double?, priceToCashFlowLte: kotlin.Double?, priceToFreeCashFlow: kotlin.Double?, priceToFreeCashFlowGt: kotlin.Double?, priceToFreeCashFlowGte: kotlin.Double?, priceToFreeCashFlowLt: kotlin.Double?, priceToFreeCashFlowLte: kotlin.Double?, dividendYield: kotlin.Double?, dividendYieldGt: kotlin.Double?, dividendYieldGte: kotlin.Double?, dividendYieldLt: kotlin.Double?, dividendYieldLte: kotlin.Double?, returnOnAssets: kotlin.Double?, returnOnAssetsGt: kotlin.Double?, returnOnAssetsGte: kotlin.Double?, returnOnAssetsLt: kotlin.Double?, returnOnAssetsLte: kotlin.Double?, returnOnEquity: kotlin.Double?, returnOnEquityGt: kotlin.Double?, returnOnEquityGte: kotlin.Double?, returnOnEquityLt: kotlin.Double?, returnOnEquityLte: kotlin.Double?, debtToEquity: kotlin.Double?, debtToEquityGt: kotlin.Double?, debtToEquityGte: kotlin.Double?, debtToEquityLt: kotlin.Double?, debtToEquityLte: kotlin.Double?, current: kotlin.Double?, currentGt: kotlin.Double?, currentGte: kotlin.Double?, currentLt: kotlin.Double?, currentLte: kotlin.Double?, quick: kotlin.Double?, quickGt: kotlin.Double?, quickGte: kotlin.Double?, quickLt: kotlin.Double?, quickLte: kotlin.Double?, cash: kotlin.Double?, cashGt: kotlin.Double?, cashGte: kotlin.Double?, cashLt: kotlin.Double?, cashLte: kotlin.Double?, evToSales: kotlin.Double?, evToSalesGt: kotlin.Double?, evToSalesGte: kotlin.Double?, evToSalesLt: kotlin.Double?, evToSalesLte: kotlin.Double?, evToEbitda: kotlin.Double?, evToEbitdaGt: kotlin.Double?, evToEbitdaGte: kotlin.Double?, evToEbitdaLt: kotlin.Double?, evToEbitdaLte: kotlin.Double?, enterpriseValue: kotlin.Double?, enterpriseValueGt: kotlin.Double?, enterpriseValueGte: kotlin.Double?, enterpriseValueLt: kotlin.Double?, enterpriseValueLte: kotlin.Double?, freeCashFlow: kotlin.Double?, freeCashFlowGt: kotlin.Double?, freeCashFlowGte: kotlin.Double?, freeCashFlowLt: kotlin.Double?, freeCashFlowLte: kotlin.Double?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (cik != null) {
                    put("cik", listOf(cik.toString()))
                }
                if (cikAnyOf != null) {
                    put("cik.any_of", listOf(cikAnyOf.toString()))
                }
                if (cikGt != null) {
                    put("cik.gt", listOf(cikGt.toString()))
                }
                if (cikGte != null) {
                    put("cik.gte", listOf(cikGte.toString()))
                }
                if (cikLt != null) {
                    put("cik.lt", listOf(cikLt.toString()))
                }
                if (cikLte != null) {
                    put("cik.lte", listOf(cikLte.toString()))
                }
                if (price != null) {
                    put("price", listOf(price.toString()))
                }
                if (priceGt != null) {
                    put("price.gt", listOf(priceGt.toString()))
                }
                if (priceGte != null) {
                    put("price.gte", listOf(priceGte.toString()))
                }
                if (priceLt != null) {
                    put("price.lt", listOf(priceLt.toString()))
                }
                if (priceLte != null) {
                    put("price.lte", listOf(priceLte.toString()))
                }
                if (averageVolume != null) {
                    put("average_volume", listOf(averageVolume.toString()))
                }
                if (averageVolumeGt != null) {
                    put("average_volume.gt", listOf(averageVolumeGt.toString()))
                }
                if (averageVolumeGte != null) {
                    put("average_volume.gte", listOf(averageVolumeGte.toString()))
                }
                if (averageVolumeLt != null) {
                    put("average_volume.lt", listOf(averageVolumeLt.toString()))
                }
                if (averageVolumeLte != null) {
                    put("average_volume.lte", listOf(averageVolumeLte.toString()))
                }
                if (marketCap != null) {
                    put("market_cap", listOf(marketCap.toString()))
                }
                if (marketCapGt != null) {
                    put("market_cap.gt", listOf(marketCapGt.toString()))
                }
                if (marketCapGte != null) {
                    put("market_cap.gte", listOf(marketCapGte.toString()))
                }
                if (marketCapLt != null) {
                    put("market_cap.lt", listOf(marketCapLt.toString()))
                }
                if (marketCapLte != null) {
                    put("market_cap.lte", listOf(marketCapLte.toString()))
                }
                if (earningsPerShare != null) {
                    put("earnings_per_share", listOf(earningsPerShare.toString()))
                }
                if (earningsPerShareGt != null) {
                    put("earnings_per_share.gt", listOf(earningsPerShareGt.toString()))
                }
                if (earningsPerShareGte != null) {
                    put("earnings_per_share.gte", listOf(earningsPerShareGte.toString()))
                }
                if (earningsPerShareLt != null) {
                    put("earnings_per_share.lt", listOf(earningsPerShareLt.toString()))
                }
                if (earningsPerShareLte != null) {
                    put("earnings_per_share.lte", listOf(earningsPerShareLte.toString()))
                }
                if (priceToEarnings != null) {
                    put("price_to_earnings", listOf(priceToEarnings.toString()))
                }
                if (priceToEarningsGt != null) {
                    put("price_to_earnings.gt", listOf(priceToEarningsGt.toString()))
                }
                if (priceToEarningsGte != null) {
                    put("price_to_earnings.gte", listOf(priceToEarningsGte.toString()))
                }
                if (priceToEarningsLt != null) {
                    put("price_to_earnings.lt", listOf(priceToEarningsLt.toString()))
                }
                if (priceToEarningsLte != null) {
                    put("price_to_earnings.lte", listOf(priceToEarningsLte.toString()))
                }
                if (priceToBook != null) {
                    put("price_to_book", listOf(priceToBook.toString()))
                }
                if (priceToBookGt != null) {
                    put("price_to_book.gt", listOf(priceToBookGt.toString()))
                }
                if (priceToBookGte != null) {
                    put("price_to_book.gte", listOf(priceToBookGte.toString()))
                }
                if (priceToBookLt != null) {
                    put("price_to_book.lt", listOf(priceToBookLt.toString()))
                }
                if (priceToBookLte != null) {
                    put("price_to_book.lte", listOf(priceToBookLte.toString()))
                }
                if (priceToSales != null) {
                    put("price_to_sales", listOf(priceToSales.toString()))
                }
                if (priceToSalesGt != null) {
                    put("price_to_sales.gt", listOf(priceToSalesGt.toString()))
                }
                if (priceToSalesGte != null) {
                    put("price_to_sales.gte", listOf(priceToSalesGte.toString()))
                }
                if (priceToSalesLt != null) {
                    put("price_to_sales.lt", listOf(priceToSalesLt.toString()))
                }
                if (priceToSalesLte != null) {
                    put("price_to_sales.lte", listOf(priceToSalesLte.toString()))
                }
                if (priceToCashFlow != null) {
                    put("price_to_cash_flow", listOf(priceToCashFlow.toString()))
                }
                if (priceToCashFlowGt != null) {
                    put("price_to_cash_flow.gt", listOf(priceToCashFlowGt.toString()))
                }
                if (priceToCashFlowGte != null) {
                    put("price_to_cash_flow.gte", listOf(priceToCashFlowGte.toString()))
                }
                if (priceToCashFlowLt != null) {
                    put("price_to_cash_flow.lt", listOf(priceToCashFlowLt.toString()))
                }
                if (priceToCashFlowLte != null) {
                    put("price_to_cash_flow.lte", listOf(priceToCashFlowLte.toString()))
                }
                if (priceToFreeCashFlow != null) {
                    put("price_to_free_cash_flow", listOf(priceToFreeCashFlow.toString()))
                }
                if (priceToFreeCashFlowGt != null) {
                    put("price_to_free_cash_flow.gt", listOf(priceToFreeCashFlowGt.toString()))
                }
                if (priceToFreeCashFlowGte != null) {
                    put("price_to_free_cash_flow.gte", listOf(priceToFreeCashFlowGte.toString()))
                }
                if (priceToFreeCashFlowLt != null) {
                    put("price_to_free_cash_flow.lt", listOf(priceToFreeCashFlowLt.toString()))
                }
                if (priceToFreeCashFlowLte != null) {
                    put("price_to_free_cash_flow.lte", listOf(priceToFreeCashFlowLte.toString()))
                }
                if (dividendYield != null) {
                    put("dividend_yield", listOf(dividendYield.toString()))
                }
                if (dividendYieldGt != null) {
                    put("dividend_yield.gt", listOf(dividendYieldGt.toString()))
                }
                if (dividendYieldGte != null) {
                    put("dividend_yield.gte", listOf(dividendYieldGte.toString()))
                }
                if (dividendYieldLt != null) {
                    put("dividend_yield.lt", listOf(dividendYieldLt.toString()))
                }
                if (dividendYieldLte != null) {
                    put("dividend_yield.lte", listOf(dividendYieldLte.toString()))
                }
                if (returnOnAssets != null) {
                    put("return_on_assets", listOf(returnOnAssets.toString()))
                }
                if (returnOnAssetsGt != null) {
                    put("return_on_assets.gt", listOf(returnOnAssetsGt.toString()))
                }
                if (returnOnAssetsGte != null) {
                    put("return_on_assets.gte", listOf(returnOnAssetsGte.toString()))
                }
                if (returnOnAssetsLt != null) {
                    put("return_on_assets.lt", listOf(returnOnAssetsLt.toString()))
                }
                if (returnOnAssetsLte != null) {
                    put("return_on_assets.lte", listOf(returnOnAssetsLte.toString()))
                }
                if (returnOnEquity != null) {
                    put("return_on_equity", listOf(returnOnEquity.toString()))
                }
                if (returnOnEquityGt != null) {
                    put("return_on_equity.gt", listOf(returnOnEquityGt.toString()))
                }
                if (returnOnEquityGte != null) {
                    put("return_on_equity.gte", listOf(returnOnEquityGte.toString()))
                }
                if (returnOnEquityLt != null) {
                    put("return_on_equity.lt", listOf(returnOnEquityLt.toString()))
                }
                if (returnOnEquityLte != null) {
                    put("return_on_equity.lte", listOf(returnOnEquityLte.toString()))
                }
                if (debtToEquity != null) {
                    put("debt_to_equity", listOf(debtToEquity.toString()))
                }
                if (debtToEquityGt != null) {
                    put("debt_to_equity.gt", listOf(debtToEquityGt.toString()))
                }
                if (debtToEquityGte != null) {
                    put("debt_to_equity.gte", listOf(debtToEquityGte.toString()))
                }
                if (debtToEquityLt != null) {
                    put("debt_to_equity.lt", listOf(debtToEquityLt.toString()))
                }
                if (debtToEquityLte != null) {
                    put("debt_to_equity.lte", listOf(debtToEquityLte.toString()))
                }
                if (current != null) {
                    put("current", listOf(current.toString()))
                }
                if (currentGt != null) {
                    put("current.gt", listOf(currentGt.toString()))
                }
                if (currentGte != null) {
                    put("current.gte", listOf(currentGte.toString()))
                }
                if (currentLt != null) {
                    put("current.lt", listOf(currentLt.toString()))
                }
                if (currentLte != null) {
                    put("current.lte", listOf(currentLte.toString()))
                }
                if (quick != null) {
                    put("quick", listOf(quick.toString()))
                }
                if (quickGt != null) {
                    put("quick.gt", listOf(quickGt.toString()))
                }
                if (quickGte != null) {
                    put("quick.gte", listOf(quickGte.toString()))
                }
                if (quickLt != null) {
                    put("quick.lt", listOf(quickLt.toString()))
                }
                if (quickLte != null) {
                    put("quick.lte", listOf(quickLte.toString()))
                }
                if (cash != null) {
                    put("cash", listOf(cash.toString()))
                }
                if (cashGt != null) {
                    put("cash.gt", listOf(cashGt.toString()))
                }
                if (cashGte != null) {
                    put("cash.gte", listOf(cashGte.toString()))
                }
                if (cashLt != null) {
                    put("cash.lt", listOf(cashLt.toString()))
                }
                if (cashLte != null) {
                    put("cash.lte", listOf(cashLte.toString()))
                }
                if (evToSales != null) {
                    put("ev_to_sales", listOf(evToSales.toString()))
                }
                if (evToSalesGt != null) {
                    put("ev_to_sales.gt", listOf(evToSalesGt.toString()))
                }
                if (evToSalesGte != null) {
                    put("ev_to_sales.gte", listOf(evToSalesGte.toString()))
                }
                if (evToSalesLt != null) {
                    put("ev_to_sales.lt", listOf(evToSalesLt.toString()))
                }
                if (evToSalesLte != null) {
                    put("ev_to_sales.lte", listOf(evToSalesLte.toString()))
                }
                if (evToEbitda != null) {
                    put("ev_to_ebitda", listOf(evToEbitda.toString()))
                }
                if (evToEbitdaGt != null) {
                    put("ev_to_ebitda.gt", listOf(evToEbitdaGt.toString()))
                }
                if (evToEbitdaGte != null) {
                    put("ev_to_ebitda.gte", listOf(evToEbitdaGte.toString()))
                }
                if (evToEbitdaLt != null) {
                    put("ev_to_ebitda.lt", listOf(evToEbitdaLt.toString()))
                }
                if (evToEbitdaLte != null) {
                    put("ev_to_ebitda.lte", listOf(evToEbitdaLte.toString()))
                }
                if (enterpriseValue != null) {
                    put("enterprise_value", listOf(enterpriseValue.toString()))
                }
                if (enterpriseValueGt != null) {
                    put("enterprise_value.gt", listOf(enterpriseValueGt.toString()))
                }
                if (enterpriseValueGte != null) {
                    put("enterprise_value.gte", listOf(enterpriseValueGte.toString()))
                }
                if (enterpriseValueLt != null) {
                    put("enterprise_value.lt", listOf(enterpriseValueLt.toString()))
                }
                if (enterpriseValueLte != null) {
                    put("enterprise_value.lte", listOf(enterpriseValueLte.toString()))
                }
                if (freeCashFlow != null) {
                    put("free_cash_flow", listOf(freeCashFlow.toString()))
                }
                if (freeCashFlowGt != null) {
                    put("free_cash_flow.gt", listOf(freeCashFlowGt.toString()))
                }
                if (freeCashFlowGte != null) {
                    put("free_cash_flow.gte", listOf(freeCashFlowGte.toString()))
                }
                if (freeCashFlowLt != null) {
                    put("free_cash_flow.lt", listOf(freeCashFlowLt.toString()))
                }
                if (freeCashFlowLte != null) {
                    put("free_cash_flow.lte", listOf(freeCashFlowLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/financials/v1/ratios",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetStocksMACD(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetStocksMACD(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksMACD(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/macd/{stockTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetStocksMACD200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksMACD(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetStocksMACD? = TimespanGetStocksMACD.day, adjusted: kotlin.Boolean? = true, shortWindow: kotlin.Int? = 12, longWindow: kotlin.Int? = 26, signalWindow: kotlin.Int? = 9, seriesType: SeriesTypeGetStocksMACD? = SeriesTypeGetStocksMACD.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetStocksMACD? = OrderGetStocksMACD.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetStocksMACD200Response {
        val localVarResponse = getStocksMACDWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksMACD200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/macd/{stockTicker}
     * Moving Average Convergence/Divergence (MACD)
     * Get moving average convergence/divergence (MACD) data for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetStocksMACD200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksMACDWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksMACD?, adjusted: kotlin.Boolean?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetStocksMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetStocksMACD200Response?> {
        val localVariableConfig = getStocksMACDRequestConfig(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, shortWindow = shortWindow, longWindow = longWindow, signalWindow = signalWindow, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetStocksMACD200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksMACD
     *
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get moving average convergence/divergence (MACD) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the MACD are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param shortWindow The short window size used to calculate MACD data. (optional, default to 12)
     * @param longWindow The long window size used to calculate MACD data. (optional, default to 26)
     * @param signalWindow The window size used to calculate the MACD signal line. (optional, default to 9)
     * @param seriesType The price in the aggregate which will be used to calculate the MACD. i.e. &#39;close&#39; will result in using close prices to  calculate the MACD. (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getStocksMACDRequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksMACD?, adjusted: kotlin.Boolean?, shortWindow: kotlin.Int?, longWindow: kotlin.Int?, signalWindow: kotlin.Int?, seriesType: SeriesTypeGetStocksMACD?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksMACD?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (shortWindow != null) {
                    put("short_window", listOf(shortWindow.toString()))
                }
                if (longWindow != null) {
                    put("long_window", listOf(longWindow.toString()))
                }
                if (signalWindow != null) {
                    put("signal_window", listOf(signalWindow.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/macd/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v1/open-close/{stocksTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours prices of a stock symbol on a certain date. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return GetOptionsOpenClose200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksOpenClose(stocksTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean? = null) : GetOptionsOpenClose200Response {
        val localVarResponse = getStocksOpenCloseWithHttpInfo(stocksTicker = stocksTicker, date = date, adjusted = adjusted)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetOptionsOpenClose200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/open-close/{stocksTicker}/{date}
     * Daily Open/Close
     * Get the open, close and afterhours prices of a stock symbol on a certain date. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return ApiResponse<GetOptionsOpenClose200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksOpenCloseWithHttpInfo(stocksTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : ApiResponse<GetOptionsOpenClose200Response?> {
        val localVariableConfig = getStocksOpenCloseRequestConfig(stocksTicker = stocksTicker, date = date, adjusted = adjusted)

        return request<Unit, GetOptionsOpenClose200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksOpenClose
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param date The date of the requested open/close in the format YYYY-MM-DD.
     * @param adjusted Whether or not the results are adjusted for splits.  By default, results are adjusted. Set this to false to get results that are NOT adjusted for splits.  (optional)
     * @return RequestConfig
     */
    fun getStocksOpenCloseRequestConfig(stocksTicker: kotlin.String, date: java.time.LocalDate, adjusted: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/open-close/{stocksTicker}/{date}".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())).replace("{"+"date"+"}", encodeURIComponent(date.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksQuotes(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetStocksQuotes(val value: kotlin.String) {
         @Json(name = "timestamp") timestamp("timestamp");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/quotes/{stockTicker}
     * Quotes (NBBO)
     * Get NBBO quotes for a ticker symbol in a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return GetStocksQuotes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksQuotes(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null, order: OrderGetStocksQuotes? = OrderGetStocksQuotes.desc, limit: kotlin.Int? = 1000, sort: SortGetStocksQuotes? = SortGetStocksQuotes.timestamp) : GetStocksQuotes200Response {
        val localVarResponse = getStocksQuotesWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksQuotes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/quotes/{stockTicker}
     * Quotes (NBBO)
     * Get NBBO quotes for a ticker symbol in a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return ApiResponse<GetStocksQuotes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksQuotesWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetStocksQuotes?, limit: kotlin.Int?, sort: SortGetStocksQuotes?) : ApiResponse<GetStocksQuotes200Response?> {
        val localVariableConfig = getStocksQuotesRequestConfig(stockTicker = stockTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetStocksQuotes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksQuotes
     *
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return RequestConfig
     */
    fun getStocksQuotesRequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetStocksQuotes?, limit: kotlin.Int?, sort: SortGetStocksQuotes?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/quotes/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetStocksRSI(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetStocksRSI(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksRSI(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/rsi/{stockTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetStocksRSI200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksRSI(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetStocksRSI? = TimespanGetStocksRSI.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 14, seriesType: SeriesTypeGetStocksRSI? = SeriesTypeGetStocksRSI.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetStocksRSI? = OrderGetStocksRSI.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetStocksRSI200Response {
        val localVarResponse = getStocksRSIWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksRSI200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/rsi/{stockTicker}
     * Relative Strength Index (RSI)
     * Get the relative strength index (RSI) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetStocksRSI200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksRSIWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksRSI?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetStocksRSI200Response?> {
        val localVariableConfig = getStocksRSIRequestConfig(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetStocksRSI200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksRSI
     *
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get relative strength index (RSI) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the relative strength index are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the relative strength index (RSI). (optional, default to 14)
     * @param seriesType The price in the aggregate which will be used to calculate the relative strength index. i.e. &#39;close&#39; will result in using close prices to  calculate the relative strength index (RSI). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getStocksRSIRequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksRSI?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksRSI?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksRSI?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/rsi/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timespan
     */
     enum class TimespanGetStocksSMA(val value: kotlin.String) {
         @Json(name = "minute") minute("minute"),
         @Json(name = "hour") hour("hour"),
         @Json(name = "day") day("day"),
         @Json(name = "week") week("week"),
         @Json(name = "month") month("month"),
         @Json(name = "quarter") quarter("quarter"),
         @Json(name = "year") year("year");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter seriesType
     */
     enum class SeriesTypeGetStocksSMA(val value: kotlin.String) {
         @Json(name = "open") `open`("open"),
         @Json(name = "high") high("high"),
         @Json(name = "low") low("low"),
         @Json(name = "close") close("close");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksSMA(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v1/indicators/sma/{stockTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return GetStocksSMA200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksSMA(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timespan: TimespanGetStocksSMA? = TimespanGetStocksSMA.day, adjusted: kotlin.Boolean? = true, window: kotlin.Int? = 50, seriesType: SeriesTypeGetStocksSMA? = SeriesTypeGetStocksSMA.close, expandUnderlying: kotlin.Boolean? = false, order: OrderGetStocksSMA? = OrderGetStocksSMA.desc, limit: kotlin.Int? = 10, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null) : GetStocksSMA200Response {
        val localVarResponse = getStocksSMAWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksSMA200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v1/indicators/sma/{stockTicker}
     * Simple Moving Average (SMA)
     * Get the simple moving average (SMA) for a ticker symbol over a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return ApiResponse<GetStocksSMA200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksSMAWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksSMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : ApiResponse<GetStocksSMA200Response?> {
        val localVariableConfig = getStocksSMARequestConfig(stockTicker = stockTicker, timestamp = timestamp, timespan = timespan, adjusted = adjusted, window = window, seriesType = seriesType, expandUnderlying = expandUnderlying, order = order, limit = limit, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt)

        return request<Unit, GetStocksSMA200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksSMA
     *
     * @param stockTicker Specify a case-sensitive ticker symbol for which to get simple moving average (SMA) data. For example, AAPL represents Apple Inc.
     * @param timestamp Query by timestamp. Either a date with the format YYYY-MM-DD or a millisecond timestamp. (optional)
     * @param timespan The size of the aggregate time window. (optional, default to day)
     * @param adjusted Whether or not the aggregates used to calculate the simple moving average are adjusted for splits. By default, aggregates are adjusted. Set this to false to get results that are NOT adjusted for splits. (optional, default to true)
     * @param window The window size used to calculate the simple moving average (SMA). i.e. a window size of 10 with daily aggregates would result in a 10 day moving average. (optional, default to 50)
     * @param seriesType The price in the aggregate which will be used to calculate the simple moving average. i.e. &#39;close&#39; will result in using close prices to  calculate the simple moving average (SMA). (optional, default to close)
     * @param expandUnderlying Whether or not to include the aggregates used to calculate this indicator in the response. (optional, default to false)
     * @param order The order in which to return the results, ordered by timestamp. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 5000 (optional, default to 10)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @return RequestConfig
     */
    fun getStocksSMARequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timespan: TimespanGetStocksSMA?, adjusted: kotlin.Boolean?, window: kotlin.Int?, seriesType: SeriesTypeGetStocksSMA?, expandUnderlying: kotlin.Boolean?, order: OrderGetStocksSMA?, limit: kotlin.Int?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timespan != null) {
                    put("timespan", listOf(timespan.value))
                }
                if (adjusted != null) {
                    put("adjusted", listOf(adjusted.toString()))
                }
                if (window != null) {
                    put("window", listOf(window.toString()))
                }
                if (seriesType != null) {
                    put("series_type", listOf(seriesType.value))
                }
                if (expandUnderlying != null) {
                    put("expand_underlying", listOf(expandUnderlying.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v1/indicators/sma/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter direction
     */
     enum class DirectionGetStocksSnapshotDirection(val value: kotlin.String) {
         @Json(name = "gainers") gainers("gainers"),
         @Json(name = "losers") losers("losers");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/{direction}
     * Gainers/Losers
     * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. This output will only include tickers with a trading volume of 10,000 or more. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return GetStocksSnapshotDirection200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksSnapshotDirection(direction: DirectionGetStocksSnapshotDirection, includeOtc: kotlin.Boolean? = null) : GetStocksSnapshotDirection200Response {
        val localVarResponse = getStocksSnapshotDirectionWithHttpInfo(direction = direction, includeOtc = includeOtc)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksSnapshotDirection200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/{direction}
     * Gainers/Losers
     * Get the most up-to-date market data for the current top 20 gainers or losers of the day in the stocks/equities markets. &lt;br /&gt; &lt;br /&gt; Top gainers are those tickers whose price has increased by the highest percentage since the previous day&#39;s close. Top losers are those tickers whose price has decreased by the highest percentage since the previous day&#39;s close. This output will only include tickers with a trading volume of 10,000 or more. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. 
     * @param direction The direction of the snapshot results to return. 
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return ApiResponse<GetStocksSnapshotDirection200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksSnapshotDirectionWithHttpInfo(direction: DirectionGetStocksSnapshotDirection, includeOtc: kotlin.Boolean?) : ApiResponse<GetStocksSnapshotDirection200Response?> {
        val localVariableConfig = getStocksSnapshotDirectionRequestConfig(direction = direction, includeOtc = includeOtc)

        return request<Unit, GetStocksSnapshotDirection200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksSnapshotDirection
     *
     * @param direction The direction of the snapshot results to return. 
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return RequestConfig
     */
    fun getStocksSnapshotDirectionRequestConfig(direction: DirectionGetStocksSnapshotDirection, includeOtc: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (includeOtc != null) {
                    put("include_otc", listOf(includeOtc.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/us/markets/stocks/{direction}".replace("{"+"direction"+"}", encodeURIComponent(direction.value.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/tickers/{stocksTicker}
     * Ticker
     * Get the most up-to-date market data for a single traded stock ticker. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return GetStocksSnapshotTicker200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksSnapshotTicker(stocksTicker: kotlin.String) : GetStocksSnapshotTicker200Response {
        val localVarResponse = getStocksSnapshotTickerWithHttpInfo(stocksTicker = stocksTicker)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksSnapshotTicker200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/tickers/{stocksTicker}
     * Ticker
     * Get the most up-to-date market data for a single traded stock ticker. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return ApiResponse<GetStocksSnapshotTicker200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksSnapshotTickerWithHttpInfo(stocksTicker: kotlin.String) : ApiResponse<GetStocksSnapshotTicker200Response?> {
        val localVariableConfig = getStocksSnapshotTickerRequestConfig(stocksTicker = stocksTicker)

        return request<Unit, GetStocksSnapshotTicker200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksSnapshotTicker
     *
     * @param stocksTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @return RequestConfig
     */
    fun getStocksSnapshotTickerRequestConfig(stocksTicker: kotlin.String) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf()
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/us/markets/stocks/tickers/{stocksTicker}".replace("{"+"stocksTicker"+"}", encodeURIComponent(stocksTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/tickers
     * All Tickers
     * Get the most up-to-date market data for all traded stock symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers. (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return GetStocksSnapshotTickers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksSnapshotTickers(tickers: kotlin.collections.List<kotlin.String>? = null, includeOtc: kotlin.Boolean? = null) : GetStocksSnapshotTickers200Response {
        val localVarResponse = getStocksSnapshotTickersWithHttpInfo(tickers = tickers, includeOtc = includeOtc)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksSnapshotTickers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/snapshot/locale/us/markets/stocks/tickers
     * All Tickers
     * Get the most up-to-date market data for all traded stock symbols. &lt;br /&gt; &lt;br /&gt; Note: Snapshot data is cleared at 3:30am EST and gets populated as data is received from the exchanges. This can happen as early as 4am EST. 
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers. (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return ApiResponse<GetStocksSnapshotTickers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksSnapshotTickersWithHttpInfo(tickers: kotlin.collections.List<kotlin.String>?, includeOtc: kotlin.Boolean?) : ApiResponse<GetStocksSnapshotTickers200Response?> {
        val localVariableConfig = getStocksSnapshotTickersRequestConfig(tickers = tickers, includeOtc = includeOtc)

        return request<Unit, GetStocksSnapshotTickers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksSnapshotTickers
     *
     * @param tickers A case-sensitive comma separated list of tickers to get snapshots for. For example, AAPL,TSLA,GOOG. Empty string defaults to querying all tickers. (optional)
     * @param includeOtc Include OTC securities in the response. Default is false (don&#39;t include OTC securities).  (optional)
     * @return RequestConfig
     */
    fun getStocksSnapshotTickersRequestConfig(tickers: kotlin.collections.List<kotlin.String>?, includeOtc: kotlin.Boolean?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (tickers != null) {
                    put("tickers", toMultiValue(tickers.toList(), "multi"))
                }
                if (includeOtc != null) {
                    put("include_otc", listOf(includeOtc.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/snapshot/locale/us/markets/stocks/tickers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /stocks/taxonomies/vX/risk-factors
     * 
     * The complete list of risk factor classifications used in the risk factors endpoint.
     * @param taxonomy Version identifier (e.g., &#39;1.0&#39;, &#39;1.1&#39;) for the taxonomy Value must be a floating point number. (optional)
     * @param taxonomyGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param taxonomyGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param taxonomyLt Filter less than the value. Value must be a floating point number. (optional)
     * @param taxonomyLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param primaryCategory Top-level risk category (optional)
     * @param primaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param primaryCategoryGt Filter greater than the value. (optional)
     * @param primaryCategoryGte Filter greater than or equal to the value. (optional)
     * @param primaryCategoryLt Filter less than the value. (optional)
     * @param primaryCategoryLte Filter less than or equal to the value. (optional)
     * @param secondaryCategory Mid-level risk category (optional)
     * @param secondaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param secondaryCategoryGt Filter greater than the value. (optional)
     * @param secondaryCategoryGte Filter greater than or equal to the value. (optional)
     * @param secondaryCategoryLt Filter less than the value. (optional)
     * @param secondaryCategoryLte Filter less than or equal to the value. (optional)
     * @param tertiaryCategory Most specific risk classification (optional)
     * @param tertiaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tertiaryCategoryGt Filter greater than the value. (optional)
     * @param tertiaryCategoryGte Filter greater than or equal to the value. (optional)
     * @param tertiaryCategoryLt Filter less than the value. (optional)
     * @param tertiaryCategoryLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;200&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 200)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;taxonomy&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "taxonomy.desc")
     * @return GetStocksTaxonomiesVXRiskFactors200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksTaxonomiesVXRiskFactors(taxonomy: kotlin.Double? = null, taxonomyGt: kotlin.Double? = null, taxonomyGte: kotlin.Double? = null, taxonomyLt: kotlin.Double? = null, taxonomyLte: kotlin.Double? = null, primaryCategory: kotlin.String? = null, primaryCategoryAnyOf: kotlin.String? = null, primaryCategoryGt: kotlin.String? = null, primaryCategoryGte: kotlin.String? = null, primaryCategoryLt: kotlin.String? = null, primaryCategoryLte: kotlin.String? = null, secondaryCategory: kotlin.String? = null, secondaryCategoryAnyOf: kotlin.String? = null, secondaryCategoryGt: kotlin.String? = null, secondaryCategoryGte: kotlin.String? = null, secondaryCategoryLt: kotlin.String? = null, secondaryCategoryLte: kotlin.String? = null, tertiaryCategory: kotlin.String? = null, tertiaryCategoryAnyOf: kotlin.String? = null, tertiaryCategoryGt: kotlin.String? = null, tertiaryCategoryGte: kotlin.String? = null, tertiaryCategoryLt: kotlin.String? = null, tertiaryCategoryLte: kotlin.String? = null, limit: kotlin.Int? = 200, sort: kotlin.String? = "taxonomy.desc") : GetStocksTaxonomiesVXRiskFactors200Response {
        val localVarResponse = getStocksTaxonomiesVXRiskFactorsWithHttpInfo(taxonomy = taxonomy, taxonomyGt = taxonomyGt, taxonomyGte = taxonomyGte, taxonomyLt = taxonomyLt, taxonomyLte = taxonomyLte, primaryCategory = primaryCategory, primaryCategoryAnyOf = primaryCategoryAnyOf, primaryCategoryGt = primaryCategoryGt, primaryCategoryGte = primaryCategoryGte, primaryCategoryLt = primaryCategoryLt, primaryCategoryLte = primaryCategoryLte, secondaryCategory = secondaryCategory, secondaryCategoryAnyOf = secondaryCategoryAnyOf, secondaryCategoryGt = secondaryCategoryGt, secondaryCategoryGte = secondaryCategoryGte, secondaryCategoryLt = secondaryCategoryLt, secondaryCategoryLte = secondaryCategoryLte, tertiaryCategory = tertiaryCategory, tertiaryCategoryAnyOf = tertiaryCategoryAnyOf, tertiaryCategoryGt = tertiaryCategoryGt, tertiaryCategoryGte = tertiaryCategoryGte, tertiaryCategoryLt = tertiaryCategoryLt, tertiaryCategoryLte = tertiaryCategoryLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksTaxonomiesVXRiskFactors200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/taxonomies/vX/risk-factors
     * 
     * The complete list of risk factor classifications used in the risk factors endpoint.
     * @param taxonomy Version identifier (e.g., &#39;1.0&#39;, &#39;1.1&#39;) for the taxonomy Value must be a floating point number. (optional)
     * @param taxonomyGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param taxonomyGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param taxonomyLt Filter less than the value. Value must be a floating point number. (optional)
     * @param taxonomyLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param primaryCategory Top-level risk category (optional)
     * @param primaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param primaryCategoryGt Filter greater than the value. (optional)
     * @param primaryCategoryGte Filter greater than or equal to the value. (optional)
     * @param primaryCategoryLt Filter less than the value. (optional)
     * @param primaryCategoryLte Filter less than or equal to the value. (optional)
     * @param secondaryCategory Mid-level risk category (optional)
     * @param secondaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param secondaryCategoryGt Filter greater than the value. (optional)
     * @param secondaryCategoryGte Filter greater than or equal to the value. (optional)
     * @param secondaryCategoryLt Filter less than the value. (optional)
     * @param secondaryCategoryLte Filter less than or equal to the value. (optional)
     * @param tertiaryCategory Most specific risk classification (optional)
     * @param tertiaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tertiaryCategoryGt Filter greater than the value. (optional)
     * @param tertiaryCategoryGte Filter greater than or equal to the value. (optional)
     * @param tertiaryCategoryLt Filter less than the value. (optional)
     * @param tertiaryCategoryLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;200&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 200)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;taxonomy&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "taxonomy.desc")
     * @return ApiResponse<GetStocksTaxonomiesVXRiskFactors200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksTaxonomiesVXRiskFactorsWithHttpInfo(taxonomy: kotlin.Double?, taxonomyGt: kotlin.Double?, taxonomyGte: kotlin.Double?, taxonomyLt: kotlin.Double?, taxonomyLte: kotlin.Double?, primaryCategory: kotlin.String?, primaryCategoryAnyOf: kotlin.String?, primaryCategoryGt: kotlin.String?, primaryCategoryGte: kotlin.String?, primaryCategoryLt: kotlin.String?, primaryCategoryLte: kotlin.String?, secondaryCategory: kotlin.String?, secondaryCategoryAnyOf: kotlin.String?, secondaryCategoryGt: kotlin.String?, secondaryCategoryGte: kotlin.String?, secondaryCategoryLt: kotlin.String?, secondaryCategoryLte: kotlin.String?, tertiaryCategory: kotlin.String?, tertiaryCategoryAnyOf: kotlin.String?, tertiaryCategoryGt: kotlin.String?, tertiaryCategoryGte: kotlin.String?, tertiaryCategoryLt: kotlin.String?, tertiaryCategoryLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksTaxonomiesVXRiskFactors200Response?> {
        val localVariableConfig = getStocksTaxonomiesVXRiskFactorsRequestConfig(taxonomy = taxonomy, taxonomyGt = taxonomyGt, taxonomyGte = taxonomyGte, taxonomyLt = taxonomyLt, taxonomyLte = taxonomyLte, primaryCategory = primaryCategory, primaryCategoryAnyOf = primaryCategoryAnyOf, primaryCategoryGt = primaryCategoryGt, primaryCategoryGte = primaryCategoryGte, primaryCategoryLt = primaryCategoryLt, primaryCategoryLte = primaryCategoryLte, secondaryCategory = secondaryCategory, secondaryCategoryAnyOf = secondaryCategoryAnyOf, secondaryCategoryGt = secondaryCategoryGt, secondaryCategoryGte = secondaryCategoryGte, secondaryCategoryLt = secondaryCategoryLt, secondaryCategoryLte = secondaryCategoryLte, tertiaryCategory = tertiaryCategory, tertiaryCategoryAnyOf = tertiaryCategoryAnyOf, tertiaryCategoryGt = tertiaryCategoryGt, tertiaryCategoryGte = tertiaryCategoryGte, tertiaryCategoryLt = tertiaryCategoryLt, tertiaryCategoryLte = tertiaryCategoryLte, limit = limit, sort = sort)

        return request<Unit, GetStocksTaxonomiesVXRiskFactors200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksTaxonomiesVXRiskFactors
     *
     * @param taxonomy Version identifier (e.g., &#39;1.0&#39;, &#39;1.1&#39;) for the taxonomy Value must be a floating point number. (optional)
     * @param taxonomyGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param taxonomyGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param taxonomyLt Filter less than the value. Value must be a floating point number. (optional)
     * @param taxonomyLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param primaryCategory Top-level risk category (optional)
     * @param primaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param primaryCategoryGt Filter greater than the value. (optional)
     * @param primaryCategoryGte Filter greater than or equal to the value. (optional)
     * @param primaryCategoryLt Filter less than the value. (optional)
     * @param primaryCategoryLte Filter less than or equal to the value. (optional)
     * @param secondaryCategory Mid-level risk category (optional)
     * @param secondaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param secondaryCategoryGt Filter greater than the value. (optional)
     * @param secondaryCategoryGte Filter greater than or equal to the value. (optional)
     * @param secondaryCategoryLt Filter less than the value. (optional)
     * @param secondaryCategoryLte Filter less than or equal to the value. (optional)
     * @param tertiaryCategory Most specific risk classification (optional)
     * @param tertiaryCategoryAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tertiaryCategoryGt Filter greater than the value. (optional)
     * @param tertiaryCategoryGte Filter greater than or equal to the value. (optional)
     * @param tertiaryCategoryLt Filter less than the value. (optional)
     * @param tertiaryCategoryLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;200&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 200)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;taxonomy&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "taxonomy.desc")
     * @return RequestConfig
     */
    fun getStocksTaxonomiesVXRiskFactorsRequestConfig(taxonomy: kotlin.Double?, taxonomyGt: kotlin.Double?, taxonomyGte: kotlin.Double?, taxonomyLt: kotlin.Double?, taxonomyLte: kotlin.Double?, primaryCategory: kotlin.String?, primaryCategoryAnyOf: kotlin.String?, primaryCategoryGt: kotlin.String?, primaryCategoryGte: kotlin.String?, primaryCategoryLt: kotlin.String?, primaryCategoryLte: kotlin.String?, secondaryCategory: kotlin.String?, secondaryCategoryAnyOf: kotlin.String?, secondaryCategoryGt: kotlin.String?, secondaryCategoryGte: kotlin.String?, secondaryCategoryLt: kotlin.String?, secondaryCategoryLte: kotlin.String?, tertiaryCategory: kotlin.String?, tertiaryCategoryAnyOf: kotlin.String?, tertiaryCategoryGt: kotlin.String?, tertiaryCategoryGte: kotlin.String?, tertiaryCategoryLt: kotlin.String?, tertiaryCategoryLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (taxonomy != null) {
                    put("taxonomy", listOf(taxonomy.toString()))
                }
                if (taxonomyGt != null) {
                    put("taxonomy.gt", listOf(taxonomyGt.toString()))
                }
                if (taxonomyGte != null) {
                    put("taxonomy.gte", listOf(taxonomyGte.toString()))
                }
                if (taxonomyLt != null) {
                    put("taxonomy.lt", listOf(taxonomyLt.toString()))
                }
                if (taxonomyLte != null) {
                    put("taxonomy.lte", listOf(taxonomyLte.toString()))
                }
                if (primaryCategory != null) {
                    put("primary_category", listOf(primaryCategory.toString()))
                }
                if (primaryCategoryAnyOf != null) {
                    put("primary_category.any_of", listOf(primaryCategoryAnyOf.toString()))
                }
                if (primaryCategoryGt != null) {
                    put("primary_category.gt", listOf(primaryCategoryGt.toString()))
                }
                if (primaryCategoryGte != null) {
                    put("primary_category.gte", listOf(primaryCategoryGte.toString()))
                }
                if (primaryCategoryLt != null) {
                    put("primary_category.lt", listOf(primaryCategoryLt.toString()))
                }
                if (primaryCategoryLte != null) {
                    put("primary_category.lte", listOf(primaryCategoryLte.toString()))
                }
                if (secondaryCategory != null) {
                    put("secondary_category", listOf(secondaryCategory.toString()))
                }
                if (secondaryCategoryAnyOf != null) {
                    put("secondary_category.any_of", listOf(secondaryCategoryAnyOf.toString()))
                }
                if (secondaryCategoryGt != null) {
                    put("secondary_category.gt", listOf(secondaryCategoryGt.toString()))
                }
                if (secondaryCategoryGte != null) {
                    put("secondary_category.gte", listOf(secondaryCategoryGte.toString()))
                }
                if (secondaryCategoryLt != null) {
                    put("secondary_category.lt", listOf(secondaryCategoryLt.toString()))
                }
                if (secondaryCategoryLte != null) {
                    put("secondary_category.lte", listOf(secondaryCategoryLte.toString()))
                }
                if (tertiaryCategory != null) {
                    put("tertiary_category", listOf(tertiaryCategory.toString()))
                }
                if (tertiaryCategoryAnyOf != null) {
                    put("tertiary_category.any_of", listOf(tertiaryCategoryAnyOf.toString()))
                }
                if (tertiaryCategoryGt != null) {
                    put("tertiary_category.gt", listOf(tertiaryCategoryGt.toString()))
                }
                if (tertiaryCategoryGte != null) {
                    put("tertiary_category.gte", listOf(tertiaryCategoryGte.toString()))
                }
                if (tertiaryCategoryLt != null) {
                    put("tertiary_category.lt", listOf(tertiaryCategoryLt.toString()))
                }
                if (tertiaryCategoryLte != null) {
                    put("tertiary_category.lte", listOf(tertiaryCategoryLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/taxonomies/vX/risk-factors",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderGetStocksTrades(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortGetStocksTrades(val value: kotlin.String) {
         @Json(name = "timestamp") timestamp("timestamp");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/trades/{stockTicker}
     * Trades
     * Get trades for a ticker symbol in a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return GetStocksTrades200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksTrades(stockTicker: kotlin.String, timestamp: kotlin.String? = null, timestampGte: kotlin.String? = null, timestampGt: kotlin.String? = null, timestampLte: kotlin.String? = null, timestampLt: kotlin.String? = null, order: OrderGetStocksTrades? = OrderGetStocksTrades.desc, limit: kotlin.Int? = 1000, sort: SortGetStocksTrades? = SortGetStocksTrades.timestamp) : GetStocksTrades200Response {
        val localVarResponse = getStocksTradesWithHttpInfo(stockTicker = stockTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksTrades200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/trades/{stockTicker}
     * Trades
     * Get trades for a ticker symbol in a given time range.
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return ApiResponse<GetStocksTrades200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksTradesWithHttpInfo(stockTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetStocksTrades?, limit: kotlin.Int?, sort: SortGetStocksTrades?) : ApiResponse<GetStocksTrades200Response?> {
        val localVariableConfig = getStocksTradesRequestConfig(stockTicker = stockTicker, timestamp = timestamp, timestampGte = timestampGte, timestampGt = timestampGt, timestampLte = timestampLte, timestampLt = timestampLt, order = order, limit = limit, sort = sort)

        return request<Unit, GetStocksTrades200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksTrades
     *
     * @param stockTicker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param timestamp Query by trade timestamp. Either a date with the format YYYY-MM-DD or a nanosecond timestamp. (optional)
     * @param timestampGte Range by timestamp. (optional)
     * @param timestampGt Range by timestamp. (optional)
     * @param timestampLte Range by timestamp. (optional)
     * @param timestampLt Range by timestamp. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 1000 and max is 50000. (optional, default to 1000)
     * @param sort Sort field used for ordering. (optional, default to timestamp)
     * @return RequestConfig
     */
    fun getStocksTradesRequestConfig(stockTicker: kotlin.String, timestamp: kotlin.String?, timestampGte: kotlin.String?, timestampGt: kotlin.String?, timestampLte: kotlin.String?, timestampLt: kotlin.String?, order: OrderGetStocksTrades?, limit: kotlin.Int?, sort: SortGetStocksTrades?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (timestamp != null) {
                    put("timestamp", listOf(timestamp.toString()))
                }
                if (timestampGte != null) {
                    put("timestamp.gte", listOf(timestampGte.toString()))
                }
                if (timestampGt != null) {
                    put("timestamp.gt", listOf(timestampGt.toString()))
                }
                if (timestampLte != null) {
                    put("timestamp.lte", listOf(timestampLte.toString()))
                }
                if (timestampLt != null) {
                    put("timestamp.lt", listOf(timestampLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/trades/{stockTicker}".replace("{"+"stockTicker"+"}", encodeURIComponent(stockTicker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter distributionType
     */
     enum class DistributionTypeGetStocksV1Dividends(val value: kotlin.String) {
         @Json(name = "recurring") recurring("recurring"),
         @Json(name = "special") special("special"),
         @Json(name = "supplemental") supplemental("supplemental"),
         @Json(name = "irregular") irregular("irregular"),
         @Json(name = "unknown") unknown("unknown");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter distributionTypeAnyOf
     */
     enum class DistributionTypeAnyOfGetStocksV1Dividends(val value: kotlin.String) {
         @Json(name = "recurring") recurring("recurring"),
         @Json(name = "special") special("special"),
         @Json(name = "supplemental") supplemental("supplemental"),
         @Json(name = "irregular") irregular("irregular"),
         @Json(name = "unknown") unknown("unknown");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /stocks/v1/dividends
     * 
     * Contains historical dividend payment records for US stocks with split-adjusted amounts and historical adjustment factors for price normalization.
     * @param ticker Stock symbol for the company issuing the dividend (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param exDividendDate Date when the stock begins trading without the dividend value Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param frequency How many times per year this dividend is expected to occur. A value of 0 means the distribution is non-recurring or irregular (e.g., special, supplemental, or a one-off dividend). Other possible values include 1 (annual), 2 (semi-annual), 3 (trimester), 4 (quarterly), 12 (monthly), 24 (bi-monthly), 26 (bi-weekly), 52 (weekly), and 365 (daily) depending on the issuer&#39;s declared or inferred payout cadence. Value must be an integer. (optional)
     * @param frequencyGt Filter greater than the value. Value must be an integer. (optional)
     * @param frequencyGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param frequencyLt Filter less than the value. Value must be an integer. (optional)
     * @param frequencyLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param distributionType Classification describing the nature of this dividend&#39;s recurrence pattern: recurring (paid on a regular schedule), special (one-time or commemorative), supplemental (extra beyond the regular schedule), irregular (unpredictable or non-recurring), unknown (cannot be classified from available data) (optional)
     * @param distributionTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return GetStocksV1Dividends200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksV1Dividends(ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, exDividendDate: kotlin.String? = null, exDividendDateGt: kotlin.String? = null, exDividendDateGte: kotlin.String? = null, exDividendDateLt: kotlin.String? = null, exDividendDateLte: kotlin.String? = null, frequency: kotlin.Long? = null, frequencyGt: kotlin.Long? = null, frequencyGte: kotlin.Long? = null, frequencyLt: kotlin.Long? = null, frequencyLte: kotlin.Long? = null, distributionType: DistributionTypeGetStocksV1Dividends? = null, distributionTypeAnyOf: DistributionTypeAnyOfGetStocksV1Dividends? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "ticker.asc") : GetStocksV1Dividends200Response {
        val localVarResponse = getStocksV1DividendsWithHttpInfo(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, exDividendDate = exDividendDate, exDividendDateGt = exDividendDateGt, exDividendDateGte = exDividendDateGte, exDividendDateLt = exDividendDateLt, exDividendDateLte = exDividendDateLte, frequency = frequency, frequencyGt = frequencyGt, frequencyGte = frequencyGte, frequencyLt = frequencyLt, frequencyLte = frequencyLte, distributionType = distributionType, distributionTypeAnyOf = distributionTypeAnyOf, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksV1Dividends200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/v1/dividends
     * 
     * Contains historical dividend payment records for US stocks with split-adjusted amounts and historical adjustment factors for price normalization.
     * @param ticker Stock symbol for the company issuing the dividend (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param exDividendDate Date when the stock begins trading without the dividend value Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param frequency How many times per year this dividend is expected to occur. A value of 0 means the distribution is non-recurring or irregular (e.g., special, supplemental, or a one-off dividend). Other possible values include 1 (annual), 2 (semi-annual), 3 (trimester), 4 (quarterly), 12 (monthly), 24 (bi-monthly), 26 (bi-weekly), 52 (weekly), and 365 (daily) depending on the issuer&#39;s declared or inferred payout cadence. Value must be an integer. (optional)
     * @param frequencyGt Filter greater than the value. Value must be an integer. (optional)
     * @param frequencyGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param frequencyLt Filter less than the value. Value must be an integer. (optional)
     * @param frequencyLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param distributionType Classification describing the nature of this dividend&#39;s recurrence pattern: recurring (paid on a regular schedule), special (one-time or commemorative), supplemental (extra beyond the regular schedule), irregular (unpredictable or non-recurring), unknown (cannot be classified from available data) (optional)
     * @param distributionTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return ApiResponse<GetStocksV1Dividends200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksV1DividendsWithHttpInfo(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, exDividendDate: kotlin.String?, exDividendDateGt: kotlin.String?, exDividendDateGte: kotlin.String?, exDividendDateLt: kotlin.String?, exDividendDateLte: kotlin.String?, frequency: kotlin.Long?, frequencyGt: kotlin.Long?, frequencyGte: kotlin.Long?, frequencyLt: kotlin.Long?, frequencyLte: kotlin.Long?, distributionType: DistributionTypeGetStocksV1Dividends?, distributionTypeAnyOf: DistributionTypeAnyOfGetStocksV1Dividends?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksV1Dividends200Response?> {
        val localVariableConfig = getStocksV1DividendsRequestConfig(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, exDividendDate = exDividendDate, exDividendDateGt = exDividendDateGt, exDividendDateGte = exDividendDateGte, exDividendDateLt = exDividendDateLt, exDividendDateLte = exDividendDateLte, frequency = frequency, frequencyGt = frequencyGt, frequencyGte = frequencyGte, frequencyLt = frequencyLt, frequencyLte = frequencyLte, distributionType = distributionType, distributionTypeAnyOf = distributionTypeAnyOf, limit = limit, sort = sort)

        return request<Unit, GetStocksV1Dividends200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksV1Dividends
     *
     * @param ticker Stock symbol for the company issuing the dividend (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param exDividendDate Date when the stock begins trading without the dividend value Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param exDividendDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param frequency How many times per year this dividend is expected to occur. A value of 0 means the distribution is non-recurring or irregular (e.g., special, supplemental, or a one-off dividend). Other possible values include 1 (annual), 2 (semi-annual), 3 (trimester), 4 (quarterly), 12 (monthly), 24 (bi-monthly), 26 (bi-weekly), 52 (weekly), and 365 (daily) depending on the issuer&#39;s declared or inferred payout cadence. Value must be an integer. (optional)
     * @param frequencyGt Filter greater than the value. Value must be an integer. (optional)
     * @param frequencyGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param frequencyLt Filter less than the value. Value must be an integer. (optional)
     * @param frequencyLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param distributionType Classification describing the nature of this dividend&#39;s recurrence pattern: recurring (paid on a regular schedule), special (one-time or commemorative), supplemental (extra beyond the regular schedule), irregular (unpredictable or non-recurring), unknown (cannot be classified from available data) (optional)
     * @param distributionTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return RequestConfig
     */
    fun getStocksV1DividendsRequestConfig(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, exDividendDate: kotlin.String?, exDividendDateGt: kotlin.String?, exDividendDateGte: kotlin.String?, exDividendDateLt: kotlin.String?, exDividendDateLte: kotlin.String?, frequency: kotlin.Long?, frequencyGt: kotlin.Long?, frequencyGte: kotlin.Long?, frequencyLt: kotlin.Long?, frequencyLte: kotlin.Long?, distributionType: DistributionTypeGetStocksV1Dividends?, distributionTypeAnyOf: DistributionTypeAnyOfGetStocksV1Dividends?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (exDividendDate != null) {
                    put("ex_dividend_date", listOf(exDividendDate.toString()))
                }
                if (exDividendDateGt != null) {
                    put("ex_dividend_date.gt", listOf(exDividendDateGt.toString()))
                }
                if (exDividendDateGte != null) {
                    put("ex_dividend_date.gte", listOf(exDividendDateGte.toString()))
                }
                if (exDividendDateLt != null) {
                    put("ex_dividend_date.lt", listOf(exDividendDateLt.toString()))
                }
                if (exDividendDateLte != null) {
                    put("ex_dividend_date.lte", listOf(exDividendDateLte.toString()))
                }
                if (frequency != null) {
                    put("frequency", listOf(frequency.toString()))
                }
                if (frequencyGt != null) {
                    put("frequency.gt", listOf(frequencyGt.toString()))
                }
                if (frequencyGte != null) {
                    put("frequency.gte", listOf(frequencyGte.toString()))
                }
                if (frequencyLt != null) {
                    put("frequency.lt", listOf(frequencyLt.toString()))
                }
                if (frequencyLte != null) {
                    put("frequency.lte", listOf(frequencyLte.toString()))
                }
                if (distributionType != null) {
                    put("distribution_type", listOf(distributionType.value))
                }
                if (distributionTypeAnyOf != null) {
                    put("distribution_type.any_of", listOf(distributionTypeAnyOf.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/v1/dividends",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /stocks/v1/exchanges
     * 
     * US stock exchanges, trading venues, and reporting facilities including exchanges (NYSE, Nasdaq), Trade Reporting Facilities (TRF), Securities Information Processors (SIP), and OTC Reporting Facilities (ORF) for equity trading.
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return GetStocksV1Exchanges200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksV1Exchanges(limit: kotlin.Int? = 100) : GetStocksV1Exchanges200Response {
        val localVarResponse = getStocksV1ExchangesWithHttpInfo(limit = limit)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksV1Exchanges200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/v1/exchanges
     * 
     * US stock exchanges, trading venues, and reporting facilities including exchanges (NYSE, Nasdaq), Trade Reporting Facilities (TRF), Securities Information Processors (SIP), and OTC Reporting Facilities (ORF) for equity trading.
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return ApiResponse<GetStocksV1Exchanges200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksV1ExchangesWithHttpInfo(limit: kotlin.Int?) : ApiResponse<GetStocksV1Exchanges200Response?> {
        val localVariableConfig = getStocksV1ExchangesRequestConfig(limit = limit)

        return request<Unit, GetStocksV1Exchanges200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksV1Exchanges
     *
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;999&#39;. (optional, default to 100)
     * @return RequestConfig
     */
    fun getStocksV1ExchangesRequestConfig(limit: kotlin.Int?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/v1/exchanges",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /stocks/v1/short-interest
     * 
     * Comprehensive FINRA short interest data that tracks the short selling metrics for securities on a specific settlement date.
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param daysToCover Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number. (optional)
     * @param daysToCoverAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param daysToCoverGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param daysToCoverGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param daysToCoverLt Filter less than the value. Value must be a floating point number. (optional)
     * @param daysToCoverLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param settlementDate The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules. (optional)
     * @param settlementDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param settlementDateGt Filter greater than the value. (optional)
     * @param settlementDateGte Filter greater than or equal to the value. (optional)
     * @param settlementDateLt Filter less than the value. (optional)
     * @param settlementDateLte Filter less than or equal to the value. (optional)
     * @param avgDailyVolume The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer. (optional)
     * @param avgDailyVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param avgDailyVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return GetStocksV1ShortInterest200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksV1ShortInterest(ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, daysToCover: kotlin.Double? = null, daysToCoverAnyOf: kotlin.String? = null, daysToCoverGt: kotlin.Double? = null, daysToCoverGte: kotlin.Double? = null, daysToCoverLt: kotlin.Double? = null, daysToCoverLte: kotlin.Double? = null, settlementDate: kotlin.String? = null, settlementDateAnyOf: kotlin.String? = null, settlementDateGt: kotlin.String? = null, settlementDateGte: kotlin.String? = null, settlementDateLt: kotlin.String? = null, settlementDateLte: kotlin.String? = null, avgDailyVolume: kotlin.Long? = null, avgDailyVolumeAnyOf: kotlin.String? = null, avgDailyVolumeGt: kotlin.Long? = null, avgDailyVolumeGte: kotlin.Long? = null, avgDailyVolumeLt: kotlin.Long? = null, avgDailyVolumeLte: kotlin.Long? = null, limit: kotlin.Int? = 10, sort: kotlin.String? = "ticker.asc") : GetStocksV1ShortInterest200Response {
        val localVarResponse = getStocksV1ShortInterestWithHttpInfo(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, daysToCover = daysToCover, daysToCoverAnyOf = daysToCoverAnyOf, daysToCoverGt = daysToCoverGt, daysToCoverGte = daysToCoverGte, daysToCoverLt = daysToCoverLt, daysToCoverLte = daysToCoverLte, settlementDate = settlementDate, settlementDateAnyOf = settlementDateAnyOf, settlementDateGt = settlementDateGt, settlementDateGte = settlementDateGte, settlementDateLt = settlementDateLt, settlementDateLte = settlementDateLte, avgDailyVolume = avgDailyVolume, avgDailyVolumeAnyOf = avgDailyVolumeAnyOf, avgDailyVolumeGt = avgDailyVolumeGt, avgDailyVolumeGte = avgDailyVolumeGte, avgDailyVolumeLt = avgDailyVolumeLt, avgDailyVolumeLte = avgDailyVolumeLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksV1ShortInterest200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/v1/short-interest
     * 
     * Comprehensive FINRA short interest data that tracks the short selling metrics for securities on a specific settlement date.
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param daysToCover Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number. (optional)
     * @param daysToCoverAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param daysToCoverGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param daysToCoverGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param daysToCoverLt Filter less than the value. Value must be a floating point number. (optional)
     * @param daysToCoverLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param settlementDate The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules. (optional)
     * @param settlementDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param settlementDateGt Filter greater than the value. (optional)
     * @param settlementDateGte Filter greater than or equal to the value. (optional)
     * @param settlementDateLt Filter less than the value. (optional)
     * @param settlementDateLte Filter less than or equal to the value. (optional)
     * @param avgDailyVolume The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer. (optional)
     * @param avgDailyVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param avgDailyVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return ApiResponse<GetStocksV1ShortInterest200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksV1ShortInterestWithHttpInfo(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, daysToCover: kotlin.Double?, daysToCoverAnyOf: kotlin.String?, daysToCoverGt: kotlin.Double?, daysToCoverGte: kotlin.Double?, daysToCoverLt: kotlin.Double?, daysToCoverLte: kotlin.Double?, settlementDate: kotlin.String?, settlementDateAnyOf: kotlin.String?, settlementDateGt: kotlin.String?, settlementDateGte: kotlin.String?, settlementDateLt: kotlin.String?, settlementDateLte: kotlin.String?, avgDailyVolume: kotlin.Long?, avgDailyVolumeAnyOf: kotlin.String?, avgDailyVolumeGt: kotlin.Long?, avgDailyVolumeGte: kotlin.Long?, avgDailyVolumeLt: kotlin.Long?, avgDailyVolumeLte: kotlin.Long?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksV1ShortInterest200Response?> {
        val localVariableConfig = getStocksV1ShortInterestRequestConfig(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, daysToCover = daysToCover, daysToCoverAnyOf = daysToCoverAnyOf, daysToCoverGt = daysToCoverGt, daysToCoverGte = daysToCoverGte, daysToCoverLt = daysToCoverLt, daysToCoverLte = daysToCoverLte, settlementDate = settlementDate, settlementDateAnyOf = settlementDateAnyOf, settlementDateGt = settlementDateGt, settlementDateGte = settlementDateGte, settlementDateLt = settlementDateLt, settlementDateLte = settlementDateLte, avgDailyVolume = avgDailyVolume, avgDailyVolumeAnyOf = avgDailyVolumeAnyOf, avgDailyVolumeGt = avgDailyVolumeGt, avgDailyVolumeGte = avgDailyVolumeGte, avgDailyVolumeLt = avgDailyVolumeLt, avgDailyVolumeLte = avgDailyVolumeLte, limit = limit, sort = sort)

        return request<Unit, GetStocksV1ShortInterest200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksV1ShortInterest
     *
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param daysToCover Calculated as short_interest divided by avg_daily_volume, representing the estimated number of days it would take to cover all short positions based on average trading volume. Value must be a floating point number. (optional)
     * @param daysToCoverAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param daysToCoverGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param daysToCoverGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param daysToCoverLt Filter less than the value. Value must be a floating point number. (optional)
     * @param daysToCoverLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param settlementDate The date (formatted as YYYY-MM-DD) on which the short interest data is considered settled, typically based on exchange reporting schedules. (optional)
     * @param settlementDateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param settlementDateGt Filter greater than the value. (optional)
     * @param settlementDateGte Filter greater than or equal to the value. (optional)
     * @param settlementDateLt Filter less than the value. (optional)
     * @param settlementDateLte Filter less than or equal to the value. (optional)
     * @param avgDailyVolume The average daily trading volume for the stock over a specified period, typically used to contextualize short interest. Value must be an integer. (optional)
     * @param avgDailyVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param avgDailyVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param avgDailyVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return RequestConfig
     */
    fun getStocksV1ShortInterestRequestConfig(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, daysToCover: kotlin.Double?, daysToCoverAnyOf: kotlin.String?, daysToCoverGt: kotlin.Double?, daysToCoverGte: kotlin.Double?, daysToCoverLt: kotlin.Double?, daysToCoverLte: kotlin.Double?, settlementDate: kotlin.String?, settlementDateAnyOf: kotlin.String?, settlementDateGt: kotlin.String?, settlementDateGte: kotlin.String?, settlementDateLt: kotlin.String?, settlementDateLte: kotlin.String?, avgDailyVolume: kotlin.Long?, avgDailyVolumeAnyOf: kotlin.String?, avgDailyVolumeGt: kotlin.Long?, avgDailyVolumeGte: kotlin.Long?, avgDailyVolumeLt: kotlin.Long?, avgDailyVolumeLte: kotlin.Long?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (daysToCover != null) {
                    put("days_to_cover", listOf(daysToCover.toString()))
                }
                if (daysToCoverAnyOf != null) {
                    put("days_to_cover.any_of", listOf(daysToCoverAnyOf.toString()))
                }
                if (daysToCoverGt != null) {
                    put("days_to_cover.gt", listOf(daysToCoverGt.toString()))
                }
                if (daysToCoverGte != null) {
                    put("days_to_cover.gte", listOf(daysToCoverGte.toString()))
                }
                if (daysToCoverLt != null) {
                    put("days_to_cover.lt", listOf(daysToCoverLt.toString()))
                }
                if (daysToCoverLte != null) {
                    put("days_to_cover.lte", listOf(daysToCoverLte.toString()))
                }
                if (settlementDate != null) {
                    put("settlement_date", listOf(settlementDate.toString()))
                }
                if (settlementDateAnyOf != null) {
                    put("settlement_date.any_of", listOf(settlementDateAnyOf.toString()))
                }
                if (settlementDateGt != null) {
                    put("settlement_date.gt", listOf(settlementDateGt.toString()))
                }
                if (settlementDateGte != null) {
                    put("settlement_date.gte", listOf(settlementDateGte.toString()))
                }
                if (settlementDateLt != null) {
                    put("settlement_date.lt", listOf(settlementDateLt.toString()))
                }
                if (settlementDateLte != null) {
                    put("settlement_date.lte", listOf(settlementDateLte.toString()))
                }
                if (avgDailyVolume != null) {
                    put("avg_daily_volume", listOf(avgDailyVolume.toString()))
                }
                if (avgDailyVolumeAnyOf != null) {
                    put("avg_daily_volume.any_of", listOf(avgDailyVolumeAnyOf.toString()))
                }
                if (avgDailyVolumeGt != null) {
                    put("avg_daily_volume.gt", listOf(avgDailyVolumeGt.toString()))
                }
                if (avgDailyVolumeGte != null) {
                    put("avg_daily_volume.gte", listOf(avgDailyVolumeGte.toString()))
                }
                if (avgDailyVolumeLt != null) {
                    put("avg_daily_volume.lt", listOf(avgDailyVolumeLt.toString()))
                }
                if (avgDailyVolumeLte != null) {
                    put("avg_daily_volume.lte", listOf(avgDailyVolumeLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/v1/short-interest",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /stocks/v1/short-volume
     * 
     * Contains short selling volume for different stock tickers, capturing total trading volume, short sale details, and breakdown by different trading platforms.
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param date The date of trade activity reported in the format YYYY-MM-DD (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param shortVolumeRatio The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number. (optional)
     * @param shortVolumeRatioAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLt Filter less than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param totalVolume Total reported volume across all venues for the ticker on the given date. Value must be an integer. (optional)
     * @param totalVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param totalVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param totalVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param totalVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param totalVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return GetStocksV1ShortVolume200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksV1ShortVolume(ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, shortVolumeRatio: kotlin.Double? = null, shortVolumeRatioAnyOf: kotlin.String? = null, shortVolumeRatioGt: kotlin.Double? = null, shortVolumeRatioGte: kotlin.Double? = null, shortVolumeRatioLt: kotlin.Double? = null, shortVolumeRatioLte: kotlin.Double? = null, totalVolume: kotlin.Long? = null, totalVolumeAnyOf: kotlin.String? = null, totalVolumeGt: kotlin.Long? = null, totalVolumeGte: kotlin.Long? = null, totalVolumeLt: kotlin.Long? = null, totalVolumeLte: kotlin.Long? = null, limit: kotlin.Int? = 10, sort: kotlin.String? = "ticker.asc") : GetStocksV1ShortVolume200Response {
        val localVarResponse = getStocksV1ShortVolumeWithHttpInfo(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, shortVolumeRatio = shortVolumeRatio, shortVolumeRatioAnyOf = shortVolumeRatioAnyOf, shortVolumeRatioGt = shortVolumeRatioGt, shortVolumeRatioGte = shortVolumeRatioGte, shortVolumeRatioLt = shortVolumeRatioLt, shortVolumeRatioLte = shortVolumeRatioLte, totalVolume = totalVolume, totalVolumeAnyOf = totalVolumeAnyOf, totalVolumeGt = totalVolumeGt, totalVolumeGte = totalVolumeGte, totalVolumeLt = totalVolumeLt, totalVolumeLte = totalVolumeLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksV1ShortVolume200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/v1/short-volume
     * 
     * Contains short selling volume for different stock tickers, capturing total trading volume, short sale details, and breakdown by different trading platforms.
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param date The date of trade activity reported in the format YYYY-MM-DD (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param shortVolumeRatio The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number. (optional)
     * @param shortVolumeRatioAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLt Filter less than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param totalVolume Total reported volume across all venues for the ticker on the given date. Value must be an integer. (optional)
     * @param totalVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param totalVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param totalVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param totalVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param totalVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return ApiResponse<GetStocksV1ShortVolume200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksV1ShortVolumeWithHttpInfo(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, shortVolumeRatio: kotlin.Double?, shortVolumeRatioAnyOf: kotlin.String?, shortVolumeRatioGt: kotlin.Double?, shortVolumeRatioGte: kotlin.Double?, shortVolumeRatioLt: kotlin.Double?, shortVolumeRatioLte: kotlin.Double?, totalVolume: kotlin.Long?, totalVolumeAnyOf: kotlin.String?, totalVolumeGt: kotlin.Long?, totalVolumeGte: kotlin.Long?, totalVolumeLt: kotlin.Long?, totalVolumeLte: kotlin.Long?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksV1ShortVolume200Response?> {
        val localVariableConfig = getStocksV1ShortVolumeRequestConfig(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, shortVolumeRatio = shortVolumeRatio, shortVolumeRatioAnyOf = shortVolumeRatioAnyOf, shortVolumeRatioGt = shortVolumeRatioGt, shortVolumeRatioGte = shortVolumeRatioGte, shortVolumeRatioLt = shortVolumeRatioLt, shortVolumeRatioLte = shortVolumeRatioLte, totalVolume = totalVolume, totalVolumeAnyOf = totalVolumeAnyOf, totalVolumeGt = totalVolumeGt, totalVolumeGte = totalVolumeGte, totalVolumeLt = totalVolumeLt, totalVolumeLte = totalVolumeLte, limit = limit, sort = sort)

        return request<Unit, GetStocksV1ShortVolume200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksV1ShortVolume
     *
     * @param ticker The primary ticker symbol for the stock. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param date The date of trade activity reported in the format YYYY-MM-DD (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param shortVolumeRatio The percentage of total volume that was sold short. Calculated as (short_volume / total_volume) * 100. Value must be a floating point number. (optional)
     * @param shortVolumeRatioAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGt Filter greater than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioGte Filter greater than or equal to the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLt Filter less than the value. Value must be a floating point number. (optional)
     * @param shortVolumeRatioLte Filter less than or equal to the value. Value must be a floating point number. (optional)
     * @param totalVolume Total reported volume across all venues for the ticker on the given date. Value must be an integer. (optional)
     * @param totalVolumeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. Value must be an integer. (optional)
     * @param totalVolumeGt Filter greater than the value. Value must be an integer. (optional)
     * @param totalVolumeGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param totalVolumeLt Filter less than the value. Value must be an integer. (optional)
     * @param totalVolumeLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;10&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 10)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;ticker&#39; if not specified. The sort order defaults to &#39;asc&#39; if not specified. (optional, default to "ticker.asc")
     * @return RequestConfig
     */
    fun getStocksV1ShortVolumeRequestConfig(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, shortVolumeRatio: kotlin.Double?, shortVolumeRatioAnyOf: kotlin.String?, shortVolumeRatioGt: kotlin.Double?, shortVolumeRatioGte: kotlin.Double?, shortVolumeRatioLt: kotlin.Double?, shortVolumeRatioLte: kotlin.Double?, totalVolume: kotlin.Long?, totalVolumeAnyOf: kotlin.String?, totalVolumeGt: kotlin.Long?, totalVolumeGte: kotlin.Long?, totalVolumeLt: kotlin.Long?, totalVolumeLte: kotlin.Long?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (shortVolumeRatio != null) {
                    put("short_volume_ratio", listOf(shortVolumeRatio.toString()))
                }
                if (shortVolumeRatioAnyOf != null) {
                    put("short_volume_ratio.any_of", listOf(shortVolumeRatioAnyOf.toString()))
                }
                if (shortVolumeRatioGt != null) {
                    put("short_volume_ratio.gt", listOf(shortVolumeRatioGt.toString()))
                }
                if (shortVolumeRatioGte != null) {
                    put("short_volume_ratio.gte", listOf(shortVolumeRatioGte.toString()))
                }
                if (shortVolumeRatioLt != null) {
                    put("short_volume_ratio.lt", listOf(shortVolumeRatioLt.toString()))
                }
                if (shortVolumeRatioLte != null) {
                    put("short_volume_ratio.lte", listOf(shortVolumeRatioLte.toString()))
                }
                if (totalVolume != null) {
                    put("total_volume", listOf(totalVolume.toString()))
                }
                if (totalVolumeAnyOf != null) {
                    put("total_volume.any_of", listOf(totalVolumeAnyOf.toString()))
                }
                if (totalVolumeGt != null) {
                    put("total_volume.gt", listOf(totalVolumeGt.toString()))
                }
                if (totalVolumeGte != null) {
                    put("total_volume.gte", listOf(totalVolumeGte.toString()))
                }
                if (totalVolumeLt != null) {
                    put("total_volume.lt", listOf(totalVolumeLt.toString()))
                }
                if (totalVolumeLte != null) {
                    put("total_volume.lte", listOf(totalVolumeLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/v1/short-volume",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter adjustmentType
     */
     enum class AdjustmentTypeGetStocksV1Splits(val value: kotlin.String) {
         @Json(name = "forward_split") forwardSplit("forward_split"),
         @Json(name = "reverse_split") reverseSplit("reverse_split"),
         @Json(name = "stock_dividend") stockDividend("stock_dividend");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter adjustmentTypeAnyOf
     */
     enum class AdjustmentTypeAnyOfGetStocksV1Splits(val value: kotlin.String) {
         @Json(name = "forward_split") forwardSplit("forward_split"),
         @Json(name = "reverse_split") reverseSplit("reverse_split"),
         @Json(name = "stock_dividend") stockDividend("stock_dividend");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /stocks/v1/splits
     * 
     * Contains historical stock split and reverse split events for US equities with historical adjustment factors for price normalization.
     * @param ticker Stock symbol for the company that executed the split (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param executionDate Date when the stock split was applied and shares adjusted Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param adjustmentType Classification of the share-change event. Possible values include: forward_split (share count increases), reverse_split (share count decreases), stock_dividend (shares issued as a dividend) (optional)
     * @param adjustmentTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;execution_date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "execution_date.desc")
     * @return GetStocksV1Splits200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getStocksV1Splits(ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, executionDate: kotlin.String? = null, executionDateGt: kotlin.String? = null, executionDateGte: kotlin.String? = null, executionDateLt: kotlin.String? = null, executionDateLte: kotlin.String? = null, adjustmentType: AdjustmentTypeGetStocksV1Splits? = null, adjustmentTypeAnyOf: AdjustmentTypeAnyOfGetStocksV1Splits? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "execution_date.desc") : GetStocksV1Splits200Response {
        val localVarResponse = getStocksV1SplitsWithHttpInfo(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, executionDate = executionDate, executionDateGt = executionDateGt, executionDateGte = executionDateGte, executionDateLt = executionDateLt, executionDateLte = executionDateLte, adjustmentType = adjustmentType, adjustmentTypeAnyOf = adjustmentTypeAnyOf, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetStocksV1Splits200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /stocks/v1/splits
     * 
     * Contains historical stock split and reverse split events for US equities with historical adjustment factors for price normalization.
     * @param ticker Stock symbol for the company that executed the split (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param executionDate Date when the stock split was applied and shares adjusted Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param adjustmentType Classification of the share-change event. Possible values include: forward_split (share count increases), reverse_split (share count decreases), stock_dividend (shares issued as a dividend) (optional)
     * @param adjustmentTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;execution_date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "execution_date.desc")
     * @return ApiResponse<GetStocksV1Splits200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getStocksV1SplitsWithHttpInfo(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, executionDate: kotlin.String?, executionDateGt: kotlin.String?, executionDateGte: kotlin.String?, executionDateLt: kotlin.String?, executionDateLte: kotlin.String?, adjustmentType: AdjustmentTypeGetStocksV1Splits?, adjustmentTypeAnyOf: AdjustmentTypeAnyOfGetStocksV1Splits?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetStocksV1Splits200Response?> {
        val localVariableConfig = getStocksV1SplitsRequestConfig(ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, executionDate = executionDate, executionDateGt = executionDateGt, executionDateGte = executionDateGte, executionDateLt = executionDateLt, executionDateLte = executionDateLte, adjustmentType = adjustmentType, adjustmentTypeAnyOf = adjustmentTypeAnyOf, limit = limit, sort = sort)

        return request<Unit, GetStocksV1Splits200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getStocksV1Splits
     *
     * @param ticker Stock symbol for the company that executed the split (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param executionDate Date when the stock split was applied and shares adjusted Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateGt Filter greater than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateGte Filter greater than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateLt Filter less than the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param executionDateLte Filter less than or equal to the value. Value must be formatted &#39;yyyy-mm-dd&#39;. (optional)
     * @param adjustmentType Classification of the share-change event. Possible values include: forward_split (share count increases), reverse_split (share count decreases), stock_dividend (shares issued as a dividend) (optional)
     * @param adjustmentTypeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;5000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;execution_date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "execution_date.desc")
     * @return RequestConfig
     */
    fun getStocksV1SplitsRequestConfig(ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, executionDate: kotlin.String?, executionDateGt: kotlin.String?, executionDateGte: kotlin.String?, executionDateLt: kotlin.String?, executionDateLte: kotlin.String?, adjustmentType: AdjustmentTypeGetStocksV1Splits?, adjustmentTypeAnyOf: AdjustmentTypeAnyOfGetStocksV1Splits?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (executionDate != null) {
                    put("execution_date", listOf(executionDate.toString()))
                }
                if (executionDateGt != null) {
                    put("execution_date.gt", listOf(executionDateGt.toString()))
                }
                if (executionDateGte != null) {
                    put("execution_date.gte", listOf(executionDateGte.toString()))
                }
                if (executionDateLt != null) {
                    put("execution_date.lt", listOf(executionDateLt.toString()))
                }
                if (executionDateLte != null) {
                    put("execution_date.lte", listOf(executionDateLte.toString()))
                }
                if (adjustmentType != null) {
                    put("adjustment_type", listOf(adjustmentType.value))
                }
                if (adjustmentTypeAnyOf != null) {
                    put("adjustment_type.any_of", listOf(adjustmentTypeAnyOf.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/stocks/v1/splits",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /v3/reference/tickers/{ticker}
     * Ticker Details v3
     * Get a single ticker supported by Massive. This response will have detailed information about the ticker and the company behind it.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param date Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date. (optional)
     * @return GetTicker200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTicker(ticker: kotlin.String, date: java.time.LocalDate? = null) : GetTicker200Response {
        val localVarResponse = getTickerWithHttpInfo(ticker = ticker, date = date)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetTicker200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/tickers/{ticker}
     * Ticker Details v3
     * Get a single ticker supported by Massive. This response will have detailed information about the ticker and the company behind it.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param date Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date. (optional)
     * @return ApiResponse<GetTicker200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTickerWithHttpInfo(ticker: kotlin.String, date: java.time.LocalDate?) : ApiResponse<GetTicker200Response?> {
        val localVariableConfig = getTickerRequestConfig(ticker = ticker, date = date)

        return request<Unit, GetTicker200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTicker
     *
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc.
     * @param date Specify a point in time to get information about the ticker available on that date. When retrieving information from SEC filings, we compare this date with the period of report date on the SEC filing.  For example, consider an SEC filing submitted by AAPL on 2019-07-31, with a period of report date ending on 2019-06-29. That means that the filing was submitted on 2019-07-31, but the filing was created based on information from 2019-06-29. If you were to query for AAPL details on 2019-06-29, the ticker details would include information from the SEC filing.  Defaults to the most recent available date. (optional)
     * @return RequestConfig
     */
    fun getTickerRequestConfig(ticker: kotlin.String, date: java.time.LocalDate?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(parseDateToQueryString(date)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/tickers/{ticker}".replace("{"+"ticker"+"}", encodeURIComponent(ticker.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * GET /tmx/v1/corporate-events
     * 
     * Contains corporate events and announcements for publicly traded companies, including earnings releases, conferences, dividends, and business updates sourced from TMX.
     * @param date Scheduled date of the corporate event, formatted as YYYY-MM-DD. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param type The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param status The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed. (optional)
     * @param statusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param statusGt Filter greater than the value. (optional)
     * @param statusGte Filter greater than or equal to the value. (optional)
     * @param statusLt Filter less than the value. (optional)
     * @param statusLte Filter less than or equal to the value. (optional)
     * @param ticker The company&#39;s stock symbol. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param isin Standard international identifier for the company&#39;s common stock. (optional)
     * @param isinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param isinGt Filter greater than the value. (optional)
     * @param isinGte Filter greater than or equal to the value. (optional)
     * @param isinLt Filter less than the value. (optional)
     * @param isinLte Filter less than or equal to the value. (optional)
     * @param tradingVenue MIC (Market Identifier Code) of the exchange where the company&#39;s stock is listed. (optional)
     * @param tradingVenueAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tradingVenueGt Filter greater than the value. (optional)
     * @param tradingVenueGte Filter greater than or equal to the value. (optional)
     * @param tradingVenueLt Filter less than the value. (optional)
     * @param tradingVenueLte Filter less than or equal to the value. (optional)
     * @param tmxCompanyId Unique numeric identifier for the company used by TMX. Value must be an integer. (optional)
     * @param tmxCompanyIdGt Filter greater than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLt Filter less than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param tmxRecordId The unique alphanumeric identifier for the event record used by TMX. (optional)
     * @param tmxRecordIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tmxRecordIdGt Filter greater than the value. (optional)
     * @param tmxRecordIdGte Filter greater than or equal to the value. (optional)
     * @param tmxRecordIdLt Filter less than the value. (optional)
     * @param tmxRecordIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return GetTmxV1CorporateEvents200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun getTmxV1CorporateEvents(date: kotlin.String? = null, dateAnyOf: kotlin.String? = null, dateGt: kotlin.String? = null, dateGte: kotlin.String? = null, dateLt: kotlin.String? = null, dateLte: kotlin.String? = null, type: kotlin.String? = null, typeAnyOf: kotlin.String? = null, typeGt: kotlin.String? = null, typeGte: kotlin.String? = null, typeLt: kotlin.String? = null, typeLte: kotlin.String? = null, status: kotlin.String? = null, statusAnyOf: kotlin.String? = null, statusGt: kotlin.String? = null, statusGte: kotlin.String? = null, statusLt: kotlin.String? = null, statusLte: kotlin.String? = null, ticker: kotlin.String? = null, tickerAnyOf: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerGte: kotlin.String? = null, tickerLt: kotlin.String? = null, tickerLte: kotlin.String? = null, isin: kotlin.String? = null, isinAnyOf: kotlin.String? = null, isinGt: kotlin.String? = null, isinGte: kotlin.String? = null, isinLt: kotlin.String? = null, isinLte: kotlin.String? = null, tradingVenue: kotlin.String? = null, tradingVenueAnyOf: kotlin.String? = null, tradingVenueGt: kotlin.String? = null, tradingVenueGte: kotlin.String? = null, tradingVenueLt: kotlin.String? = null, tradingVenueLte: kotlin.String? = null, tmxCompanyId: kotlin.Long? = null, tmxCompanyIdGt: kotlin.Long? = null, tmxCompanyIdGte: kotlin.Long? = null, tmxCompanyIdLt: kotlin.Long? = null, tmxCompanyIdLte: kotlin.Long? = null, tmxRecordId: kotlin.String? = null, tmxRecordIdAnyOf: kotlin.String? = null, tmxRecordIdGt: kotlin.String? = null, tmxRecordIdGte: kotlin.String? = null, tmxRecordIdLt: kotlin.String? = null, tmxRecordIdLte: kotlin.String? = null, limit: kotlin.Int? = 100, sort: kotlin.String? = "date.desc") : GetTmxV1CorporateEvents200Response {
        val localVarResponse = getTmxV1CorporateEventsWithHttpInfo(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, type = type, typeAnyOf = typeAnyOf, typeGt = typeGt, typeGte = typeGte, typeLt = typeLt, typeLte = typeLte, status = status, statusAnyOf = statusAnyOf, statusGt = statusGt, statusGte = statusGte, statusLt = statusLt, statusLte = statusLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, isin = isin, isinAnyOf = isinAnyOf, isinGt = isinGt, isinGte = isinGte, isinLt = isinLt, isinLte = isinLte, tradingVenue = tradingVenue, tradingVenueAnyOf = tradingVenueAnyOf, tradingVenueGt = tradingVenueGt, tradingVenueGte = tradingVenueGte, tradingVenueLt = tradingVenueLt, tradingVenueLte = tradingVenueLte, tmxCompanyId = tmxCompanyId, tmxCompanyIdGt = tmxCompanyIdGt, tmxCompanyIdGte = tmxCompanyIdGte, tmxCompanyIdLt = tmxCompanyIdLt, tmxCompanyIdLte = tmxCompanyIdLte, tmxRecordId = tmxRecordId, tmxRecordIdAnyOf = tmxRecordIdAnyOf, tmxRecordIdGt = tmxRecordIdGt, tmxRecordIdGte = tmxRecordIdGte, tmxRecordIdLt = tmxRecordIdLt, tmxRecordIdLte = tmxRecordIdLte, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as GetTmxV1CorporateEvents200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /tmx/v1/corporate-events
     * 
     * Contains corporate events and announcements for publicly traded companies, including earnings releases, conferences, dividends, and business updates sourced from TMX.
     * @param date Scheduled date of the corporate event, formatted as YYYY-MM-DD. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param type The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param status The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed. (optional)
     * @param statusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param statusGt Filter greater than the value. (optional)
     * @param statusGte Filter greater than or equal to the value. (optional)
     * @param statusLt Filter less than the value. (optional)
     * @param statusLte Filter less than or equal to the value. (optional)
     * @param ticker The company&#39;s stock symbol. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param isin Standard international identifier for the company&#39;s common stock. (optional)
     * @param isinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param isinGt Filter greater than the value. (optional)
     * @param isinGte Filter greater than or equal to the value. (optional)
     * @param isinLt Filter less than the value. (optional)
     * @param isinLte Filter less than or equal to the value. (optional)
     * @param tradingVenue MIC (Market Identifier Code) of the exchange where the company&#39;s stock is listed. (optional)
     * @param tradingVenueAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tradingVenueGt Filter greater than the value. (optional)
     * @param tradingVenueGte Filter greater than or equal to the value. (optional)
     * @param tradingVenueLt Filter less than the value. (optional)
     * @param tradingVenueLte Filter less than or equal to the value. (optional)
     * @param tmxCompanyId Unique numeric identifier for the company used by TMX. Value must be an integer. (optional)
     * @param tmxCompanyIdGt Filter greater than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLt Filter less than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param tmxRecordId The unique alphanumeric identifier for the event record used by TMX. (optional)
     * @param tmxRecordIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tmxRecordIdGt Filter greater than the value. (optional)
     * @param tmxRecordIdGte Filter greater than or equal to the value. (optional)
     * @param tmxRecordIdLt Filter less than the value. (optional)
     * @param tmxRecordIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return ApiResponse<GetTmxV1CorporateEvents200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun getTmxV1CorporateEventsWithHttpInfo(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, type: kotlin.String?, typeAnyOf: kotlin.String?, typeGt: kotlin.String?, typeGte: kotlin.String?, typeLt: kotlin.String?, typeLte: kotlin.String?, status: kotlin.String?, statusAnyOf: kotlin.String?, statusGt: kotlin.String?, statusGte: kotlin.String?, statusLt: kotlin.String?, statusLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, isin: kotlin.String?, isinAnyOf: kotlin.String?, isinGt: kotlin.String?, isinGte: kotlin.String?, isinLt: kotlin.String?, isinLte: kotlin.String?, tradingVenue: kotlin.String?, tradingVenueAnyOf: kotlin.String?, tradingVenueGt: kotlin.String?, tradingVenueGte: kotlin.String?, tradingVenueLt: kotlin.String?, tradingVenueLte: kotlin.String?, tmxCompanyId: kotlin.Long?, tmxCompanyIdGt: kotlin.Long?, tmxCompanyIdGte: kotlin.Long?, tmxCompanyIdLt: kotlin.Long?, tmxCompanyIdLte: kotlin.Long?, tmxRecordId: kotlin.String?, tmxRecordIdAnyOf: kotlin.String?, tmxRecordIdGt: kotlin.String?, tmxRecordIdGte: kotlin.String?, tmxRecordIdLt: kotlin.String?, tmxRecordIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : ApiResponse<GetTmxV1CorporateEvents200Response?> {
        val localVariableConfig = getTmxV1CorporateEventsRequestConfig(date = date, dateAnyOf = dateAnyOf, dateGt = dateGt, dateGte = dateGte, dateLt = dateLt, dateLte = dateLte, type = type, typeAnyOf = typeAnyOf, typeGt = typeGt, typeGte = typeGte, typeLt = typeLt, typeLte = typeLte, status = status, statusAnyOf = statusAnyOf, statusGt = statusGt, statusGte = statusGte, statusLt = statusLt, statusLte = statusLte, ticker = ticker, tickerAnyOf = tickerAnyOf, tickerGt = tickerGt, tickerGte = tickerGte, tickerLt = tickerLt, tickerLte = tickerLte, isin = isin, isinAnyOf = isinAnyOf, isinGt = isinGt, isinGte = isinGte, isinLt = isinLt, isinLte = isinLte, tradingVenue = tradingVenue, tradingVenueAnyOf = tradingVenueAnyOf, tradingVenueGt = tradingVenueGt, tradingVenueGte = tradingVenueGte, tradingVenueLt = tradingVenueLt, tradingVenueLte = tradingVenueLte, tmxCompanyId = tmxCompanyId, tmxCompanyIdGt = tmxCompanyIdGt, tmxCompanyIdGte = tmxCompanyIdGte, tmxCompanyIdLt = tmxCompanyIdLt, tmxCompanyIdLte = tmxCompanyIdLte, tmxRecordId = tmxRecordId, tmxRecordIdAnyOf = tmxRecordIdAnyOf, tmxRecordIdGt = tmxRecordIdGt, tmxRecordIdGte = tmxRecordIdGte, tmxRecordIdLt = tmxRecordIdLt, tmxRecordIdLte = tmxRecordIdLte, limit = limit, sort = sort)

        return request<Unit, GetTmxV1CorporateEvents200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation getTmxV1CorporateEvents
     *
     * @param date Scheduled date of the corporate event, formatted as YYYY-MM-DD. (optional)
     * @param dateAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param dateGt Filter greater than the value. (optional)
     * @param dateGte Filter greater than or equal to the value. (optional)
     * @param dateLt Filter less than the value. (optional)
     * @param dateLte Filter less than or equal to the value. (optional)
     * @param type The normalized type of corporate event. Possible values include: analyst_day, business_update, capital_markets_day, conference, dividend, earnings_announcement_date, earnings_conference_call, earnings_results_announcement, forum, interim_statement, other_interim_announcement, production_update, research_and_development_day, seminar, shareholder_meeting, sales_update, stock_split, summit, service_level_update, tradeshow, company_travel, and workshop. (optional)
     * @param typeAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param typeGt Filter greater than the value. (optional)
     * @param typeGte Filter greater than or equal to the value. (optional)
     * @param typeLt Filter less than the value. (optional)
     * @param typeLte Filter less than or equal to the value. (optional)
     * @param status The current status of the event. Possible values include: approved, canceled, confirmed, historical, pending_approval, postponed, and unconfirmed. (optional)
     * @param statusAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param statusGt Filter greater than the value. (optional)
     * @param statusGte Filter greater than or equal to the value. (optional)
     * @param statusLt Filter less than the value. (optional)
     * @param statusLte Filter less than or equal to the value. (optional)
     * @param ticker The company&#39;s stock symbol. (optional)
     * @param tickerAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tickerGt Filter greater than the value. (optional)
     * @param tickerGte Filter greater than or equal to the value. (optional)
     * @param tickerLt Filter less than the value. (optional)
     * @param tickerLte Filter less than or equal to the value. (optional)
     * @param isin Standard international identifier for the company&#39;s common stock. (optional)
     * @param isinAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param isinGt Filter greater than the value. (optional)
     * @param isinGte Filter greater than or equal to the value. (optional)
     * @param isinLt Filter less than the value. (optional)
     * @param isinLte Filter less than or equal to the value. (optional)
     * @param tradingVenue MIC (Market Identifier Code) of the exchange where the company&#39;s stock is listed. (optional)
     * @param tradingVenueAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tradingVenueGt Filter greater than the value. (optional)
     * @param tradingVenueGte Filter greater than or equal to the value. (optional)
     * @param tradingVenueLt Filter less than the value. (optional)
     * @param tradingVenueLte Filter less than or equal to the value. (optional)
     * @param tmxCompanyId Unique numeric identifier for the company used by TMX. Value must be an integer. (optional)
     * @param tmxCompanyIdGt Filter greater than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdGte Filter greater than or equal to the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLt Filter less than the value. Value must be an integer. (optional)
     * @param tmxCompanyIdLte Filter less than or equal to the value. Value must be an integer. (optional)
     * @param tmxRecordId The unique alphanumeric identifier for the event record used by TMX. (optional)
     * @param tmxRecordIdAnyOf Filter equal to any of the values. Multiple values can be specified by using a comma separated list. (optional)
     * @param tmxRecordIdGt Filter greater than the value. (optional)
     * @param tmxRecordIdGte Filter greater than or equal to the value. (optional)
     * @param tmxRecordIdLt Filter less than the value. (optional)
     * @param tmxRecordIdLte Filter less than or equal to the value. (optional)
     * @param limit Limit the maximum number of results returned. Defaults to &#39;100&#39; if not specified. The maximum allowed limit is &#39;50000&#39;. (optional, default to 100)
     * @param sort A comma separated list of sort columns. For each column, append &#39;.asc&#39; or &#39;.desc&#39; to specify the sort direction. The sort column defaults to &#39;date&#39; if not specified. The sort order defaults to &#39;desc&#39; if not specified. (optional, default to "date.desc")
     * @return RequestConfig
     */
    fun getTmxV1CorporateEventsRequestConfig(date: kotlin.String?, dateAnyOf: kotlin.String?, dateGt: kotlin.String?, dateGte: kotlin.String?, dateLt: kotlin.String?, dateLte: kotlin.String?, type: kotlin.String?, typeAnyOf: kotlin.String?, typeGt: kotlin.String?, typeGte: kotlin.String?, typeLt: kotlin.String?, typeLte: kotlin.String?, status: kotlin.String?, statusAnyOf: kotlin.String?, statusGt: kotlin.String?, statusGte: kotlin.String?, statusLt: kotlin.String?, statusLte: kotlin.String?, ticker: kotlin.String?, tickerAnyOf: kotlin.String?, tickerGt: kotlin.String?, tickerGte: kotlin.String?, tickerLt: kotlin.String?, tickerLte: kotlin.String?, isin: kotlin.String?, isinAnyOf: kotlin.String?, isinGt: kotlin.String?, isinGte: kotlin.String?, isinLt: kotlin.String?, isinLte: kotlin.String?, tradingVenue: kotlin.String?, tradingVenueAnyOf: kotlin.String?, tradingVenueGt: kotlin.String?, tradingVenueGte: kotlin.String?, tradingVenueLt: kotlin.String?, tradingVenueLte: kotlin.String?, tmxCompanyId: kotlin.Long?, tmxCompanyIdGt: kotlin.Long?, tmxCompanyIdGte: kotlin.Long?, tmxCompanyIdLt: kotlin.Long?, tmxCompanyIdLte: kotlin.Long?, tmxRecordId: kotlin.String?, tmxRecordIdAnyOf: kotlin.String?, tmxRecordIdGt: kotlin.String?, tmxRecordIdGte: kotlin.String?, tmxRecordIdLt: kotlin.String?, tmxRecordIdLte: kotlin.String?, limit: kotlin.Int?, sort: kotlin.String?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (date != null) {
                    put("date", listOf(date.toString()))
                }
                if (dateAnyOf != null) {
                    put("date.any_of", listOf(dateAnyOf.toString()))
                }
                if (dateGt != null) {
                    put("date.gt", listOf(dateGt.toString()))
                }
                if (dateGte != null) {
                    put("date.gte", listOf(dateGte.toString()))
                }
                if (dateLt != null) {
                    put("date.lt", listOf(dateLt.toString()))
                }
                if (dateLte != null) {
                    put("date.lte", listOf(dateLte.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.toString()))
                }
                if (typeAnyOf != null) {
                    put("type.any_of", listOf(typeAnyOf.toString()))
                }
                if (typeGt != null) {
                    put("type.gt", listOf(typeGt.toString()))
                }
                if (typeGte != null) {
                    put("type.gte", listOf(typeGte.toString()))
                }
                if (typeLt != null) {
                    put("type.lt", listOf(typeLt.toString()))
                }
                if (typeLte != null) {
                    put("type.lte", listOf(typeLte.toString()))
                }
                if (status != null) {
                    put("status", listOf(status.toString()))
                }
                if (statusAnyOf != null) {
                    put("status.any_of", listOf(statusAnyOf.toString()))
                }
                if (statusGt != null) {
                    put("status.gt", listOf(statusGt.toString()))
                }
                if (statusGte != null) {
                    put("status.gte", listOf(statusGte.toString()))
                }
                if (statusLt != null) {
                    put("status.lt", listOf(statusLt.toString()))
                }
                if (statusLte != null) {
                    put("status.lte", listOf(statusLte.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (tickerAnyOf != null) {
                    put("ticker.any_of", listOf(tickerAnyOf.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (isin != null) {
                    put("isin", listOf(isin.toString()))
                }
                if (isinAnyOf != null) {
                    put("isin.any_of", listOf(isinAnyOf.toString()))
                }
                if (isinGt != null) {
                    put("isin.gt", listOf(isinGt.toString()))
                }
                if (isinGte != null) {
                    put("isin.gte", listOf(isinGte.toString()))
                }
                if (isinLt != null) {
                    put("isin.lt", listOf(isinLt.toString()))
                }
                if (isinLte != null) {
                    put("isin.lte", listOf(isinLte.toString()))
                }
                if (tradingVenue != null) {
                    put("trading_venue", listOf(tradingVenue.toString()))
                }
                if (tradingVenueAnyOf != null) {
                    put("trading_venue.any_of", listOf(tradingVenueAnyOf.toString()))
                }
                if (tradingVenueGt != null) {
                    put("trading_venue.gt", listOf(tradingVenueGt.toString()))
                }
                if (tradingVenueGte != null) {
                    put("trading_venue.gte", listOf(tradingVenueGte.toString()))
                }
                if (tradingVenueLt != null) {
                    put("trading_venue.lt", listOf(tradingVenueLt.toString()))
                }
                if (tradingVenueLte != null) {
                    put("trading_venue.lte", listOf(tradingVenueLte.toString()))
                }
                if (tmxCompanyId != null) {
                    put("tmx_company_id", listOf(tmxCompanyId.toString()))
                }
                if (tmxCompanyIdGt != null) {
                    put("tmx_company_id.gt", listOf(tmxCompanyIdGt.toString()))
                }
                if (tmxCompanyIdGte != null) {
                    put("tmx_company_id.gte", listOf(tmxCompanyIdGte.toString()))
                }
                if (tmxCompanyIdLt != null) {
                    put("tmx_company_id.lt", listOf(tmxCompanyIdLt.toString()))
                }
                if (tmxCompanyIdLte != null) {
                    put("tmx_company_id.lte", listOf(tmxCompanyIdLte.toString()))
                }
                if (tmxRecordId != null) {
                    put("tmx_record_id", listOf(tmxRecordId.toString()))
                }
                if (tmxRecordIdAnyOf != null) {
                    put("tmx_record_id.any_of", listOf(tmxRecordIdAnyOf.toString()))
                }
                if (tmxRecordIdGt != null) {
                    put("tmx_record_id.gt", listOf(tmxRecordIdGt.toString()))
                }
                if (tmxRecordIdGte != null) {
                    put("tmx_record_id.gte", listOf(tmxRecordIdGte.toString()))
                }
                if (tmxRecordIdLt != null) {
                    put("tmx_record_id.lt", listOf(tmxRecordIdLt.toString()))
                }
                if (tmxRecordIdLte != null) {
                    put("tmx_record_id.lte", listOf(tmxRecordIdLte.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.toString()))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/tmx/v1/corporate-events",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter assetClass
     */
     enum class AssetClassListConditions(val value: kotlin.String) {
         @Json(name = "stocks") stocks("stocks"),
         @Json(name = "options") options("options"),
         @Json(name = "crypto") crypto("crypto"),
         @Json(name = "fx") fx("fx");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter dataType
     */
     enum class DataTypeListConditions(val value: kotlin.String) {
         @Json(name = "trade") trade("trade"),
         @Json(name = "bbo") bbo("bbo"),
         @Json(name = "nbbo") nbbo("nbbo");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sip
     */
     enum class SipListConditions(val value: kotlin.String) {
         @Json(name = "CTA") cTA("CTA"),
         @Json(name = "UTP") uTP("UTP"),
         @Json(name = "OPRA") oPRA("OPRA");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListConditions(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListConditions(val value: kotlin.String) {
         @Json(name = "asset_class") assetClass("asset_class"),
         @Json(name = "id") id("id"),
         @Json(name = "type") type("type"),
         @Json(name = "name") nameEnum("name"),
         @Json(name = "data_types") dataTypes("data_types"),
         @Json(name = "legacy") legacy("legacy");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/conditions
     * Conditions
     * List all conditions that Massive uses.
     * @param assetClass Filter for conditions within a given asset class. (optional)
     * @param dataType Filter by data type. (optional)
     * @param id Filter for conditions with a given ID. (optional)
     * @param sip Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to asset_class)
     * @return ListConditions200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listConditions(assetClass: AssetClassListConditions? = null, dataType: DataTypeListConditions? = null, id: kotlin.Int? = null, sip: SipListConditions? = null, order: OrderListConditions? = null, limit: kotlin.Int? = 10, sort: SortListConditions? = SortListConditions.assetClass) : ListConditions200Response {
        val localVarResponse = listConditionsWithHttpInfo(assetClass = assetClass, dataType = dataType, id = id, sip = sip, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListConditions200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/conditions
     * Conditions
     * List all conditions that Massive uses.
     * @param assetClass Filter for conditions within a given asset class. (optional)
     * @param dataType Filter by data type. (optional)
     * @param id Filter for conditions with a given ID. (optional)
     * @param sip Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to asset_class)
     * @return ApiResponse<ListConditions200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listConditionsWithHttpInfo(assetClass: AssetClassListConditions?, dataType: DataTypeListConditions?, id: kotlin.Int?, sip: SipListConditions?, order: OrderListConditions?, limit: kotlin.Int?, sort: SortListConditions?) : ApiResponse<ListConditions200Response?> {
        val localVariableConfig = listConditionsRequestConfig(assetClass = assetClass, dataType = dataType, id = id, sip = sip, order = order, limit = limit, sort = sort)

        return request<Unit, ListConditions200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listConditions
     *
     * @param assetClass Filter for conditions within a given asset class. (optional)
     * @param dataType Filter by data type. (optional)
     * @param id Filter for conditions with a given ID. (optional)
     * @param sip Filter by SIP. If the condition contains a mapping for that SIP, the condition will be returned. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to asset_class)
     * @return RequestConfig
     */
    fun listConditionsRequestConfig(assetClass: AssetClassListConditions?, dataType: DataTypeListConditions?, id: kotlin.Int?, sip: SipListConditions?, order: OrderListConditions?, limit: kotlin.Int?, sort: SortListConditions?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (assetClass != null) {
                    put("asset_class", listOf(assetClass.value))
                }
                if (dataType != null) {
                    put("data_type", listOf(dataType.value))
                }
                if (id != null) {
                    put("id", listOf(id.toString()))
                }
                if (sip != null) {
                    put("sip", listOf(sip.value))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/conditions",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter active
     */
     enum class ActiveListContracts(val value: kotlin.String) {
         @Json(name = "all") all("all"),
         @Json(name = "true") `true`("true"),
         @Json(name = "false") `false`("false");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter type
     */
     enum class TypeListContracts(val value: kotlin.String) {
         @Json(name = "all") all("all"),
         @Json(name = "single") single("single"),
         @Json(name = "combo") combo("combo");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListContracts(val value: kotlin.String) {
         @Json(name = "product_code.asc") productCodePeriodAsc("product_code.asc"),
         @Json(name = "product_code.desc") productCodePeriodDesc("product_code.desc"),
         @Json(name = "first_trade_date.asc") firstTradeDatePeriodAsc("first_trade_date.asc"),
         @Json(name = "first_trade_date.desc") firstTradeDatePeriodDesc("first_trade_date.desc"),
         @Json(name = "last_trade_date.asc") lastTradeDatePeriodAsc("last_trade_date.asc"),
         @Json(name = "last_trade_date.desc") lastTradeDatePeriodDesc("last_trade_date.desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /futures/vX/contracts
     * Contracts
     * The Contracts endpoint returns a list of futures contracts. This endpoint can be used to query for contracts based on a variety of parameters, including the contract&#39;s ticker, product code, first trade date, last trade date, and whether or not the contract was active on a given date.
     * @param productCode A unique identifier for the Product a Contract belongs to. Note that multiple contracts can belong to the same product. (optional)
     * @param firstTradeDate The first day that a contract was tradeable. A date with the format YYYY-MM-DD. (optional)
     * @param lastTradeDate The last day that the contract was tradeable. A date with the format YYYY-MM-DD. (optional)
     * @param asOf Specify the point-in-time for which you want to retrieve information. Note that the contract data returned for a given date is the state of that contract as of that day. A date in the format YYYY-MM-DD (default&#x3D;today). (optional)
     * @param active Filter for contracts based on whether or not they were tradeable at the given point in time. For example, if the date queried is greater-than or equal-to a contract&#39;s &#39;first_trade_date&#39; and less-than-or-equal-to its &#39;last_trade_date&#39;, then the contract was active. If the date queried is greater-than-or-equal-to the contract&#39;s &#39;last_trade_date&#39; or less-than-or-equal-to its &#39;first_trade_date&#39;, then the contract was inactive. (optional, default to all)
     * @param type The type of contract, one of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all). (optional, default to all)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to product_code.asc)
     * @return ListContracts200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listContracts(productCode: kotlin.String? = null, firstTradeDate: java.time.LocalDate? = null, lastTradeDate: java.time.LocalDate? = null, asOf: java.time.LocalDate? = null, active: ActiveListContracts? = ActiveListContracts.all, type: TypeListContracts? = TypeListContracts.all, limit: kotlin.Int? = 100, sort: SortListContracts? = SortListContracts.productCodePeriodAsc) : ListContracts200Response {
        val localVarResponse = listContractsWithHttpInfo(productCode = productCode, firstTradeDate = firstTradeDate, lastTradeDate = lastTradeDate, asOf = asOf, active = active, type = type, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListContracts200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/contracts
     * Contracts
     * The Contracts endpoint returns a list of futures contracts. This endpoint can be used to query for contracts based on a variety of parameters, including the contract&#39;s ticker, product code, first trade date, last trade date, and whether or not the contract was active on a given date.
     * @param productCode A unique identifier for the Product a Contract belongs to. Note that multiple contracts can belong to the same product. (optional)
     * @param firstTradeDate The first day that a contract was tradeable. A date with the format YYYY-MM-DD. (optional)
     * @param lastTradeDate The last day that the contract was tradeable. A date with the format YYYY-MM-DD. (optional)
     * @param asOf Specify the point-in-time for which you want to retrieve information. Note that the contract data returned for a given date is the state of that contract as of that day. A date in the format YYYY-MM-DD (default&#x3D;today). (optional)
     * @param active Filter for contracts based on whether or not they were tradeable at the given point in time. For example, if the date queried is greater-than or equal-to a contract&#39;s &#39;first_trade_date&#39; and less-than-or-equal-to its &#39;last_trade_date&#39;, then the contract was active. If the date queried is greater-than-or-equal-to the contract&#39;s &#39;last_trade_date&#39; or less-than-or-equal-to its &#39;first_trade_date&#39;, then the contract was inactive. (optional, default to all)
     * @param type The type of contract, one of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all). (optional, default to all)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to product_code.asc)
     * @return ApiResponse<ListContracts200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listContractsWithHttpInfo(productCode: kotlin.String?, firstTradeDate: java.time.LocalDate?, lastTradeDate: java.time.LocalDate?, asOf: java.time.LocalDate?, active: ActiveListContracts?, type: TypeListContracts?, limit: kotlin.Int?, sort: SortListContracts?) : ApiResponse<ListContracts200Response?> {
        val localVariableConfig = listContractsRequestConfig(productCode = productCode, firstTradeDate = firstTradeDate, lastTradeDate = lastTradeDate, asOf = asOf, active = active, type = type, limit = limit, sort = sort)

        return request<Unit, ListContracts200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listContracts
     *
     * @param productCode A unique identifier for the Product a Contract belongs to. Note that multiple contracts can belong to the same product. (optional)
     * @param firstTradeDate The first day that a contract was tradeable. A date with the format YYYY-MM-DD. (optional)
     * @param lastTradeDate The last day that the contract was tradeable. A date with the format YYYY-MM-DD. (optional)
     * @param asOf Specify the point-in-time for which you want to retrieve information. Note that the contract data returned for a given date is the state of that contract as of that day. A date in the format YYYY-MM-DD (default&#x3D;today). (optional)
     * @param active Filter for contracts based on whether or not they were tradeable at the given point in time. For example, if the date queried is greater-than or equal-to a contract&#39;s &#39;first_trade_date&#39; and less-than-or-equal-to its &#39;last_trade_date&#39;, then the contract was active. If the date queried is greater-than-or-equal-to the contract&#39;s &#39;last_trade_date&#39; or less-than-or-equal-to its &#39;first_trade_date&#39;, then the contract was inactive. (optional, default to all)
     * @param type The type of contract, one of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all). (optional, default to all)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to product_code.asc)
     * @return RequestConfig
     */
    fun listContractsRequestConfig(productCode: kotlin.String?, firstTradeDate: java.time.LocalDate?, lastTradeDate: java.time.LocalDate?, asOf: java.time.LocalDate?, active: ActiveListContracts?, type: TypeListContracts?, limit: kotlin.Int?, sort: SortListContracts?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (productCode != null) {
                    put("product_code", listOf(productCode.toString()))
                }
                if (firstTradeDate != null) {
                    put("first_trade_date", listOf(parseDateToQueryString(firstTradeDate)))
                }
                if (lastTradeDate != null) {
                    put("last_trade_date", listOf(parseDateToQueryString(lastTradeDate)))
                }
                if (asOf != null) {
                    put("as_of", listOf(parseDateToQueryString(asOf)))
                }
                if (active != null) {
                    put("active", listOf(active.value))
                }
                if (type != null) {
                    put("type", listOf(type.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/contracts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter frequency
     */
     enum class FrequencyListDividends(val value: kotlin.Int) {
         @Json(name = "0") _0(0),
         @Json(name = "1") _1(1),
         @Json(name = "2") _2(2),
         @Json(name = "4") _4(4),
         @Json(name = "12") _12(12),
         @Json(name = "24") _24(24),
         @Json(name = "52") _52(52);

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter dividendType
     */
     enum class DividendTypeListDividends(val value: kotlin.String) {
         @Json(name = "CD") cD("CD"),
         @Json(name = "SC") sC("SC"),
         @Json(name = "LT") lT("LT"),
         @Json(name = "ST") sT("ST");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListDividends(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListDividends(val value: kotlin.String) {
         @Json(name = "ex_dividend_date") exDividendDate("ex_dividend_date"),
         @Json(name = "pay_date") payDate("pay_date"),
         @Json(name = "declaration_date") declarationDate("declaration_date"),
         @Json(name = "record_date") recordDate("record_date"),
         @Json(name = "cash_amount") cashAmount("cash_amount"),
         @Json(name = "ticker") ticker("ticker");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/dividends
     * Dividends v3
     * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param exDividendDate Query by ex-dividend date with the format YYYY-MM-DD. (optional)
     * @param recordDate Query by record date with the format YYYY-MM-DD. (optional)
     * @param declarationDate Query by declaration date with the format YYYY-MM-DD. (optional)
     * @param payDate Query by pay date with the format YYYY-MM-DD. (optional)
     * @param frequency Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly). (optional)
     * @param cashAmount Query by the cash amount of the dividend. (optional)
     * @param dividendType Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param exDividendDateGte Range by ex_dividend_date. (optional)
     * @param exDividendDateGt Range by ex_dividend_date. (optional)
     * @param exDividendDateLte Range by ex_dividend_date. (optional)
     * @param exDividendDateLt Range by ex_dividend_date. (optional)
     * @param recordDateGte Range by record_date. (optional)
     * @param recordDateGt Range by record_date. (optional)
     * @param recordDateLte Range by record_date. (optional)
     * @param recordDateLt Range by record_date. (optional)
     * @param declarationDateGte Range by declaration_date. (optional)
     * @param declarationDateGt Range by declaration_date. (optional)
     * @param declarationDateLte Range by declaration_date. (optional)
     * @param declarationDateLt Range by declaration_date. (optional)
     * @param payDateGte Range by pay_date. (optional)
     * @param payDateGt Range by pay_date. (optional)
     * @param payDateLte Range by pay_date. (optional)
     * @param payDateLt Range by pay_date. (optional)
     * @param cashAmountGte Range by cash_amount. (optional)
     * @param cashAmountGt Range by cash_amount. (optional)
     * @param cashAmountLte Range by cash_amount. (optional)
     * @param cashAmountLt Range by cash_amount. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ex_dividend_date)
     * @return ListDividends200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listDividends(ticker: kotlin.String? = null, exDividendDate: java.time.LocalDate? = null, recordDate: java.time.LocalDate? = null, declarationDate: java.time.LocalDate? = null, payDate: java.time.LocalDate? = null, frequency: FrequencyListDividends? = null, cashAmount: java.math.BigDecimal? = null, dividendType: DividendTypeListDividends? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, exDividendDateGte: java.time.LocalDate? = null, exDividendDateGt: java.time.LocalDate? = null, exDividendDateLte: java.time.LocalDate? = null, exDividendDateLt: java.time.LocalDate? = null, recordDateGte: java.time.LocalDate? = null, recordDateGt: java.time.LocalDate? = null, recordDateLte: java.time.LocalDate? = null, recordDateLt: java.time.LocalDate? = null, declarationDateGte: java.time.LocalDate? = null, declarationDateGt: java.time.LocalDate? = null, declarationDateLte: java.time.LocalDate? = null, declarationDateLt: java.time.LocalDate? = null, payDateGte: java.time.LocalDate? = null, payDateGt: java.time.LocalDate? = null, payDateLte: java.time.LocalDate? = null, payDateLt: java.time.LocalDate? = null, cashAmountGte: java.math.BigDecimal? = null, cashAmountGt: java.math.BigDecimal? = null, cashAmountLte: java.math.BigDecimal? = null, cashAmountLt: java.math.BigDecimal? = null, order: OrderListDividends? = null, limit: kotlin.Int? = 10, sort: SortListDividends? = SortListDividends.exDividendDate) : ListDividends200Response {
        val localVarResponse = listDividendsWithHttpInfo(ticker = ticker, exDividendDate = exDividendDate, recordDate = recordDate, declarationDate = declarationDate, payDate = payDate, frequency = frequency, cashAmount = cashAmount, dividendType = dividendType, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, exDividendDateGte = exDividendDateGte, exDividendDateGt = exDividendDateGt, exDividendDateLte = exDividendDateLte, exDividendDateLt = exDividendDateLt, recordDateGte = recordDateGte, recordDateGt = recordDateGt, recordDateLte = recordDateLte, recordDateLt = recordDateLt, declarationDateGte = declarationDateGte, declarationDateGt = declarationDateGt, declarationDateLte = declarationDateLte, declarationDateLt = declarationDateLt, payDateGte = payDateGte, payDateGt = payDateGt, payDateLte = payDateLte, payDateLt = payDateLt, cashAmountGte = cashAmountGte, cashAmountGt = cashAmountGt, cashAmountLte = cashAmountLte, cashAmountLt = cashAmountLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListDividends200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/dividends
     * Dividends v3
     * Get a list of historical cash dividends, including the ticker symbol, declaration date, ex-dividend date, record date, pay date, frequency, and amount.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param exDividendDate Query by ex-dividend date with the format YYYY-MM-DD. (optional)
     * @param recordDate Query by record date with the format YYYY-MM-DD. (optional)
     * @param declarationDate Query by declaration date with the format YYYY-MM-DD. (optional)
     * @param payDate Query by pay date with the format YYYY-MM-DD. (optional)
     * @param frequency Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly). (optional)
     * @param cashAmount Query by the cash amount of the dividend. (optional)
     * @param dividendType Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param exDividendDateGte Range by ex_dividend_date. (optional)
     * @param exDividendDateGt Range by ex_dividend_date. (optional)
     * @param exDividendDateLte Range by ex_dividend_date. (optional)
     * @param exDividendDateLt Range by ex_dividend_date. (optional)
     * @param recordDateGte Range by record_date. (optional)
     * @param recordDateGt Range by record_date. (optional)
     * @param recordDateLte Range by record_date. (optional)
     * @param recordDateLt Range by record_date. (optional)
     * @param declarationDateGte Range by declaration_date. (optional)
     * @param declarationDateGt Range by declaration_date. (optional)
     * @param declarationDateLte Range by declaration_date. (optional)
     * @param declarationDateLt Range by declaration_date. (optional)
     * @param payDateGte Range by pay_date. (optional)
     * @param payDateGt Range by pay_date. (optional)
     * @param payDateLte Range by pay_date. (optional)
     * @param payDateLt Range by pay_date. (optional)
     * @param cashAmountGte Range by cash_amount. (optional)
     * @param cashAmountGt Range by cash_amount. (optional)
     * @param cashAmountLte Range by cash_amount. (optional)
     * @param cashAmountLt Range by cash_amount. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ex_dividend_date)
     * @return ApiResponse<ListDividends200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listDividendsWithHttpInfo(ticker: kotlin.String?, exDividendDate: java.time.LocalDate?, recordDate: java.time.LocalDate?, declarationDate: java.time.LocalDate?, payDate: java.time.LocalDate?, frequency: FrequencyListDividends?, cashAmount: java.math.BigDecimal?, dividendType: DividendTypeListDividends?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, exDividendDateGte: java.time.LocalDate?, exDividendDateGt: java.time.LocalDate?, exDividendDateLte: java.time.LocalDate?, exDividendDateLt: java.time.LocalDate?, recordDateGte: java.time.LocalDate?, recordDateGt: java.time.LocalDate?, recordDateLte: java.time.LocalDate?, recordDateLt: java.time.LocalDate?, declarationDateGte: java.time.LocalDate?, declarationDateGt: java.time.LocalDate?, declarationDateLte: java.time.LocalDate?, declarationDateLt: java.time.LocalDate?, payDateGte: java.time.LocalDate?, payDateGt: java.time.LocalDate?, payDateLte: java.time.LocalDate?, payDateLt: java.time.LocalDate?, cashAmountGte: java.math.BigDecimal?, cashAmountGt: java.math.BigDecimal?, cashAmountLte: java.math.BigDecimal?, cashAmountLt: java.math.BigDecimal?, order: OrderListDividends?, limit: kotlin.Int?, sort: SortListDividends?) : ApiResponse<ListDividends200Response?> {
        val localVariableConfig = listDividendsRequestConfig(ticker = ticker, exDividendDate = exDividendDate, recordDate = recordDate, declarationDate = declarationDate, payDate = payDate, frequency = frequency, cashAmount = cashAmount, dividendType = dividendType, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, exDividendDateGte = exDividendDateGte, exDividendDateGt = exDividendDateGt, exDividendDateLte = exDividendDateLte, exDividendDateLt = exDividendDateLt, recordDateGte = recordDateGte, recordDateGt = recordDateGt, recordDateLte = recordDateLte, recordDateLt = recordDateLt, declarationDateGte = declarationDateGte, declarationDateGt = declarationDateGt, declarationDateLte = declarationDateLte, declarationDateLt = declarationDateLt, payDateGte = payDateGte, payDateGt = payDateGt, payDateLte = payDateLte, payDateLt = payDateLt, cashAmountGte = cashAmountGte, cashAmountGt = cashAmountGt, cashAmountLte = cashAmountLte, cashAmountLt = cashAmountLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListDividends200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listDividends
     *
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param exDividendDate Query by ex-dividend date with the format YYYY-MM-DD. (optional)
     * @param recordDate Query by record date with the format YYYY-MM-DD. (optional)
     * @param declarationDate Query by declaration date with the format YYYY-MM-DD. (optional)
     * @param payDate Query by pay date with the format YYYY-MM-DD. (optional)
     * @param frequency Query by the number of times per year the dividend is paid out.  Possible values are 0 (one-time), 1 (annually), 2 (bi-annually), 4 (quarterly), 12 (monthly), 24 (bi-monthly), and 52 (weekly). (optional)
     * @param cashAmount Query by the cash amount of the dividend. (optional)
     * @param dividendType Query by the type of dividend. Dividends that have been paid and/or are expected to be paid on consistent schedules are denoted as CD. Special Cash dividends that have been paid that are infrequent or unusual, and/or can not be expected to occur in the future are denoted as SC. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param exDividendDateGte Range by ex_dividend_date. (optional)
     * @param exDividendDateGt Range by ex_dividend_date. (optional)
     * @param exDividendDateLte Range by ex_dividend_date. (optional)
     * @param exDividendDateLt Range by ex_dividend_date. (optional)
     * @param recordDateGte Range by record_date. (optional)
     * @param recordDateGt Range by record_date. (optional)
     * @param recordDateLte Range by record_date. (optional)
     * @param recordDateLt Range by record_date. (optional)
     * @param declarationDateGte Range by declaration_date. (optional)
     * @param declarationDateGt Range by declaration_date. (optional)
     * @param declarationDateLte Range by declaration_date. (optional)
     * @param declarationDateLt Range by declaration_date. (optional)
     * @param payDateGte Range by pay_date. (optional)
     * @param payDateGt Range by pay_date. (optional)
     * @param payDateLte Range by pay_date. (optional)
     * @param payDateLt Range by pay_date. (optional)
     * @param cashAmountGte Range by cash_amount. (optional)
     * @param cashAmountGt Range by cash_amount. (optional)
     * @param cashAmountLte Range by cash_amount. (optional)
     * @param cashAmountLt Range by cash_amount. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ex_dividend_date)
     * @return RequestConfig
     */
    fun listDividendsRequestConfig(ticker: kotlin.String?, exDividendDate: java.time.LocalDate?, recordDate: java.time.LocalDate?, declarationDate: java.time.LocalDate?, payDate: java.time.LocalDate?, frequency: FrequencyListDividends?, cashAmount: java.math.BigDecimal?, dividendType: DividendTypeListDividends?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, exDividendDateGte: java.time.LocalDate?, exDividendDateGt: java.time.LocalDate?, exDividendDateLte: java.time.LocalDate?, exDividendDateLt: java.time.LocalDate?, recordDateGte: java.time.LocalDate?, recordDateGt: java.time.LocalDate?, recordDateLte: java.time.LocalDate?, recordDateLt: java.time.LocalDate?, declarationDateGte: java.time.LocalDate?, declarationDateGt: java.time.LocalDate?, declarationDateLte: java.time.LocalDate?, declarationDateLt: java.time.LocalDate?, payDateGte: java.time.LocalDate?, payDateGt: java.time.LocalDate?, payDateLte: java.time.LocalDate?, payDateLt: java.time.LocalDate?, cashAmountGte: java.math.BigDecimal?, cashAmountGt: java.math.BigDecimal?, cashAmountLte: java.math.BigDecimal?, cashAmountLt: java.math.BigDecimal?, order: OrderListDividends?, limit: kotlin.Int?, sort: SortListDividends?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (exDividendDate != null) {
                    put("ex_dividend_date", listOf(parseDateToQueryString(exDividendDate)))
                }
                if (recordDate != null) {
                    put("record_date", listOf(parseDateToQueryString(recordDate)))
                }
                if (declarationDate != null) {
                    put("declaration_date", listOf(parseDateToQueryString(declarationDate)))
                }
                if (payDate != null) {
                    put("pay_date", listOf(parseDateToQueryString(payDate)))
                }
                if (frequency != null) {
                    put("frequency", listOf(frequency.toString()))
                }
                if (cashAmount != null) {
                    put("cash_amount", listOf(cashAmount.toString()))
                }
                if (dividendType != null) {
                    put("dividend_type", listOf(dividendType.value))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (exDividendDateGte != null) {
                    put("ex_dividend_date.gte", listOf(parseDateToQueryString(exDividendDateGte)))
                }
                if (exDividendDateGt != null) {
                    put("ex_dividend_date.gt", listOf(parseDateToQueryString(exDividendDateGt)))
                }
                if (exDividendDateLte != null) {
                    put("ex_dividend_date.lte", listOf(parseDateToQueryString(exDividendDateLte)))
                }
                if (exDividendDateLt != null) {
                    put("ex_dividend_date.lt", listOf(parseDateToQueryString(exDividendDateLt)))
                }
                if (recordDateGte != null) {
                    put("record_date.gte", listOf(parseDateToQueryString(recordDateGte)))
                }
                if (recordDateGt != null) {
                    put("record_date.gt", listOf(parseDateToQueryString(recordDateGt)))
                }
                if (recordDateLte != null) {
                    put("record_date.lte", listOf(parseDateToQueryString(recordDateLte)))
                }
                if (recordDateLt != null) {
                    put("record_date.lt", listOf(parseDateToQueryString(recordDateLt)))
                }
                if (declarationDateGte != null) {
                    put("declaration_date.gte", listOf(parseDateToQueryString(declarationDateGte)))
                }
                if (declarationDateGt != null) {
                    put("declaration_date.gt", listOf(parseDateToQueryString(declarationDateGt)))
                }
                if (declarationDateLte != null) {
                    put("declaration_date.lte", listOf(parseDateToQueryString(declarationDateLte)))
                }
                if (declarationDateLt != null) {
                    put("declaration_date.lt", listOf(parseDateToQueryString(declarationDateLt)))
                }
                if (payDateGte != null) {
                    put("pay_date.gte", listOf(parseDateToQueryString(payDateGte)))
                }
                if (payDateGt != null) {
                    put("pay_date.gt", listOf(parseDateToQueryString(payDateGt)))
                }
                if (payDateLte != null) {
                    put("pay_date.lte", listOf(parseDateToQueryString(payDateLte)))
                }
                if (payDateLt != null) {
                    put("pay_date.lt", listOf(parseDateToQueryString(payDateLt)))
                }
                if (cashAmountGte != null) {
                    put("cash_amount.gte", listOf(cashAmountGte.toString()))
                }
                if (cashAmountGt != null) {
                    put("cash_amount.gt", listOf(cashAmountGt.toString()))
                }
                if (cashAmountLte != null) {
                    put("cash_amount.lte", listOf(cashAmountLte.toString()))
                }
                if (cashAmountLt != null) {
                    put("cash_amount.lt", listOf(cashAmountLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/dividends",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter assetClass
     */
     enum class AssetClassListExchanges(val value: kotlin.String) {
         @Json(name = "stocks") stocks("stocks"),
         @Json(name = "options") options("options"),
         @Json(name = "crypto") crypto("crypto"),
         @Json(name = "fx") fx("fx"),
         @Json(name = "futures") futures("futures");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter locale
     */
     enum class LocaleListExchanges(val value: kotlin.String) {
         @Json(name = "us") us("us"),
         @Json(name = "global") global("global");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/exchanges
     * Exchanges
     * List all exchanges that Massive knows about.
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return ListExchanges200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listExchanges(assetClass: AssetClassListExchanges? = null, locale: LocaleListExchanges? = null) : ListExchanges200Response {
        val localVarResponse = listExchangesWithHttpInfo(assetClass = assetClass, locale = locale)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListExchanges200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/exchanges
     * Exchanges
     * List all exchanges that Massive knows about.
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return ApiResponse<ListExchanges200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listExchangesWithHttpInfo(assetClass: AssetClassListExchanges?, locale: LocaleListExchanges?) : ApiResponse<ListExchanges200Response?> {
        val localVariableConfig = listExchangesRequestConfig(assetClass = assetClass, locale = locale)

        return request<Unit, ListExchanges200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listExchanges
     *
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return RequestConfig
     */
    fun listExchangesRequestConfig(assetClass: AssetClassListExchanges?, locale: LocaleListExchanges?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (assetClass != null) {
                    put("asset_class", listOf(assetClass.value))
                }
                if (locale != null) {
                    put("locale", listOf(locale.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/exchanges",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter timeframe
     */
     enum class TimeframeListFinancials(val value: kotlin.String) {
         @Json(name = "annual") annual("annual"),
         @Json(name = "quarterly") quarterly("quarterly"),
         @Json(name = "ttm") ttm("ttm");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListFinancials(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListFinancials(val value: kotlin.String) {
         @Json(name = "filing_date") filingDate("filing_date"),
         @Json(name = "period_of_report_date") periodOfReportDate("period_of_report_date");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /vX/reference/financials
     * Stock Financials vX
     * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined &lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\&quot;&gt;here&lt;/a&gt;.
     * @param ticker Query by company ticker. (optional)
     * @param cik Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number (optional)
     * @param companyName Query by company name. (optional)
     * @param sic Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;) (optional)
     * @param filingDate Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01 (optional)
     * @param periodOfReportDate The period of report for the filing with financials data in YYYY-MM-DD format. (optional)
     * @param timeframe Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4 (optional)
     * @param includeSources Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default. (optional, default to false)
     * @param companyNameSearch Search by company_name. (optional)
     * @param filingDateGte Search by filing_date. (optional)
     * @param filingDateGt Search by filing_date. (optional)
     * @param filingDateLte Search by filing_date. (optional)
     * @param filingDateLt Search by filing_date. (optional)
     * @param periodOfReportDateGte Search by period_of_report_date. (optional)
     * @param periodOfReportDateGt Search by period_of_report_date. (optional)
     * @param periodOfReportDateLte Search by period_of_report_date. (optional)
     * @param periodOfReportDateLt Search by period_of_report_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 100. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to period_of_report_date)
     * @return ListFinancials200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listFinancials(ticker: kotlin.String? = null, cik: kotlin.String? = null, companyName: kotlin.String? = null, sic: kotlin.String? = null, filingDate: java.time.LocalDate? = null, periodOfReportDate: java.time.LocalDate? = null, timeframe: TimeframeListFinancials? = null, includeSources: kotlin.Boolean? = false, companyNameSearch: kotlin.String? = null, filingDateGte: java.time.LocalDate? = null, filingDateGt: java.time.LocalDate? = null, filingDateLte: java.time.LocalDate? = null, filingDateLt: java.time.LocalDate? = null, periodOfReportDateGte: java.time.LocalDate? = null, periodOfReportDateGt: java.time.LocalDate? = null, periodOfReportDateLte: java.time.LocalDate? = null, periodOfReportDateLt: java.time.LocalDate? = null, order: OrderListFinancials? = null, limit: kotlin.Int? = 10, sort: SortListFinancials? = SortListFinancials.periodOfReportDate) : ListFinancials200Response {
        val localVarResponse = listFinancialsWithHttpInfo(ticker = ticker, cik = cik, companyName = companyName, sic = sic, filingDate = filingDate, periodOfReportDate = periodOfReportDate, timeframe = timeframe, includeSources = includeSources, companyNameSearch = companyNameSearch, filingDateGte = filingDateGte, filingDateGt = filingDateGt, filingDateLte = filingDateLte, filingDateLt = filingDateLt, periodOfReportDateGte = periodOfReportDateGte, periodOfReportDateGt = periodOfReportDateGt, periodOfReportDateLte = periodOfReportDateLte, periodOfReportDateLt = periodOfReportDateLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListFinancials200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vX/reference/financials
     * Stock Financials vX
     * Get historical financial data for a stock ticker. The financials data is extracted from XBRL from company SEC filings using the methodology outlined &lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;http://xbrl.squarespace.com/understanding-sec-xbrl-financi/\&quot;&gt;here&lt;/a&gt;.
     * @param ticker Query by company ticker. (optional)
     * @param cik Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number (optional)
     * @param companyName Query by company name. (optional)
     * @param sic Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;) (optional)
     * @param filingDate Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01 (optional)
     * @param periodOfReportDate The period of report for the filing with financials data in YYYY-MM-DD format. (optional)
     * @param timeframe Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4 (optional)
     * @param includeSources Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default. (optional, default to false)
     * @param companyNameSearch Search by company_name. (optional)
     * @param filingDateGte Search by filing_date. (optional)
     * @param filingDateGt Search by filing_date. (optional)
     * @param filingDateLte Search by filing_date. (optional)
     * @param filingDateLt Search by filing_date. (optional)
     * @param periodOfReportDateGte Search by period_of_report_date. (optional)
     * @param periodOfReportDateGt Search by period_of_report_date. (optional)
     * @param periodOfReportDateLte Search by period_of_report_date. (optional)
     * @param periodOfReportDateLt Search by period_of_report_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 100. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to period_of_report_date)
     * @return ApiResponse<ListFinancials200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listFinancialsWithHttpInfo(ticker: kotlin.String?, cik: kotlin.String?, companyName: kotlin.String?, sic: kotlin.String?, filingDate: java.time.LocalDate?, periodOfReportDate: java.time.LocalDate?, timeframe: TimeframeListFinancials?, includeSources: kotlin.Boolean?, companyNameSearch: kotlin.String?, filingDateGte: java.time.LocalDate?, filingDateGt: java.time.LocalDate?, filingDateLte: java.time.LocalDate?, filingDateLt: java.time.LocalDate?, periodOfReportDateGte: java.time.LocalDate?, periodOfReportDateGt: java.time.LocalDate?, periodOfReportDateLte: java.time.LocalDate?, periodOfReportDateLt: java.time.LocalDate?, order: OrderListFinancials?, limit: kotlin.Int?, sort: SortListFinancials?) : ApiResponse<ListFinancials200Response?> {
        val localVariableConfig = listFinancialsRequestConfig(ticker = ticker, cik = cik, companyName = companyName, sic = sic, filingDate = filingDate, periodOfReportDate = periodOfReportDate, timeframe = timeframe, includeSources = includeSources, companyNameSearch = companyNameSearch, filingDateGte = filingDateGte, filingDateGt = filingDateGt, filingDateLte = filingDateLte, filingDateLt = filingDateLt, periodOfReportDateGte = periodOfReportDateGte, periodOfReportDateGt = periodOfReportDateGt, periodOfReportDateLte = periodOfReportDateLte, periodOfReportDateLt = periodOfReportDateLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListFinancials200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listFinancials
     *
     * @param ticker Query by company ticker. (optional)
     * @param cik Query by central index key (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/edgar/searchedgar/cik.htm\&quot;&gt;CIK&lt;/a&gt;) Number (optional)
     * @param companyName Query by company name. (optional)
     * @param sic Query by standard industrial classification (&lt;a rel&#x3D;\&quot;noopener noreferrer nofollow\&quot; target&#x3D;\&quot;_blank\&quot; href&#x3D;\&quot;https://www.sec.gov/corpfin/division-of-corporation-finance-standard-industrial-classification-sic-code-list\&quot;&gt;SIC&lt;/a&gt;) (optional)
     * @param filingDate Query by the date when the filing with financials data was filed in YYYY-MM-DD format.  Best used when querying over date ranges to find financials based on filings that happen in a time period.  Examples:  To get financials based on filings that have happened after January 1, 2009 use the query param filing_date.gte&#x3D;2009-01-01  To get financials based on filings that happened in the year 2009 use the query params filing_date.gte&#x3D;2009-01-01&amp;filing_date.lt&#x3D;2010-01-01 (optional)
     * @param periodOfReportDate The period of report for the filing with financials data in YYYY-MM-DD format. (optional)
     * @param timeframe Query by timeframe. Annual financials originate from 10-K filings, and quarterly financials originate from 10-Q filings. Note: Most companies do not file quarterly reports for Q4 and instead include those financials in their annual report, so some companies my not return quarterly financials for Q4 (optional)
     * @param includeSources Whether or not to include the &#x60;xpath&#x60; and &#x60;formula&#x60; attributes for each financial data point. See the &#x60;xpath&#x60; and &#x60;formula&#x60; response attributes for more info. False by default. (optional, default to false)
     * @param companyNameSearch Search by company_name. (optional)
     * @param filingDateGte Search by filing_date. (optional)
     * @param filingDateGt Search by filing_date. (optional)
     * @param filingDateLte Search by filing_date. (optional)
     * @param filingDateLt Search by filing_date. (optional)
     * @param periodOfReportDateGte Search by period_of_report_date. (optional)
     * @param periodOfReportDateGt Search by period_of_report_date. (optional)
     * @param periodOfReportDateLte Search by period_of_report_date. (optional)
     * @param periodOfReportDateLt Search by period_of_report_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 100. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to period_of_report_date)
     * @return RequestConfig
     */
    fun listFinancialsRequestConfig(ticker: kotlin.String?, cik: kotlin.String?, companyName: kotlin.String?, sic: kotlin.String?, filingDate: java.time.LocalDate?, periodOfReportDate: java.time.LocalDate?, timeframe: TimeframeListFinancials?, includeSources: kotlin.Boolean?, companyNameSearch: kotlin.String?, filingDateGte: java.time.LocalDate?, filingDateGt: java.time.LocalDate?, filingDateLte: java.time.LocalDate?, filingDateLt: java.time.LocalDate?, periodOfReportDateGte: java.time.LocalDate?, periodOfReportDateGt: java.time.LocalDate?, periodOfReportDateLte: java.time.LocalDate?, periodOfReportDateLt: java.time.LocalDate?, order: OrderListFinancials?, limit: kotlin.Int?, sort: SortListFinancials?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (cik != null) {
                    put("cik", listOf(cik.toString()))
                }
                if (companyName != null) {
                    put("company_name", listOf(companyName.toString()))
                }
                if (sic != null) {
                    put("sic", listOf(sic.toString()))
                }
                if (filingDate != null) {
                    put("filing_date", listOf(parseDateToQueryString(filingDate)))
                }
                if (periodOfReportDate != null) {
                    put("period_of_report_date", listOf(parseDateToQueryString(periodOfReportDate)))
                }
                if (timeframe != null) {
                    put("timeframe", listOf(timeframe.value))
                }
                if (includeSources != null) {
                    put("include_sources", listOf(includeSources.toString()))
                }
                if (companyNameSearch != null) {
                    put("company_name.search", listOf(companyNameSearch.toString()))
                }
                if (filingDateGte != null) {
                    put("filing_date.gte", listOf(parseDateToQueryString(filingDateGte)))
                }
                if (filingDateGt != null) {
                    put("filing_date.gt", listOf(parseDateToQueryString(filingDateGt)))
                }
                if (filingDateLte != null) {
                    put("filing_date.lte", listOf(parseDateToQueryString(filingDateLte)))
                }
                if (filingDateLt != null) {
                    put("filing_date.lt", listOf(parseDateToQueryString(filingDateLt)))
                }
                if (periodOfReportDateGte != null) {
                    put("period_of_report_date.gte", listOf(parseDateToQueryString(periodOfReportDateGte)))
                }
                if (periodOfReportDateGt != null) {
                    put("period_of_report_date.gt", listOf(parseDateToQueryString(periodOfReportDateGt)))
                }
                if (periodOfReportDateLte != null) {
                    put("period_of_report_date.lte", listOf(parseDateToQueryString(periodOfReportDateLte)))
                }
                if (periodOfReportDateLt != null) {
                    put("period_of_report_date.lt", listOf(parseDateToQueryString(periodOfReportDateLt)))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vX/reference/financials",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter ipoStatus
     */
     enum class IpoStatusListIPOs(val value: kotlin.String) {
         @Json(name = "direct_listing_process") directListingProcess("direct_listing_process"),
         @Json(name = "history") history("history"),
         @Json(name = "new") new("new"),
         @Json(name = "pending") pending("pending"),
         @Json(name = "postponed") postponed("postponed"),
         @Json(name = "rumor") rumor("rumor"),
         @Json(name = "withdrawn") withdrawn("withdrawn");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListIPOs(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListIPOs(val value: kotlin.String) {
         @Json(name = "listing_date") listingDate("listing_date"),
         @Json(name = "ticker") ticker("ticker"),
         @Json(name = "last_updated") lastUpdated("last_updated"),
         @Json(name = "security_type") securityType("security_type"),
         @Json(name = "issuer_name") issuerName("issuer_name"),
         @Json(name = "currency_code") currencyCode("currency_code"),
         @Json(name = "isin") isin("isin"),
         @Json(name = "us_code") usCode("us_code"),
         @Json(name = "final_issue_price") finalIssuePrice("final_issue_price"),
         @Json(name = "min_shares_offered") minSharesOffered("min_shares_offered"),
         @Json(name = "max_shares_offered") maxSharesOffered("max_shares_offered"),
         @Json(name = "lowest_offer_price") lowestOfferPrice("lowest_offer_price"),
         @Json(name = "highest_offer_price") highestOfferPrice("highest_offer_price"),
         @Json(name = "total_offer_size") totalOfferSize("total_offer_size"),
         @Json(name = "shares_outstanding") sharesOutstanding("shares_outstanding"),
         @Json(name = "primary_exchange") primaryExchange("primary_exchange"),
         @Json(name = "lot_size") lotSize("lot_size"),
         @Json(name = "security_description") securityDescription("security_description"),
         @Json(name = "ipo_status") ipoStatus("ipo_status"),
         @Json(name = "announced_date") announcedDate("announced_date");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /vX/reference/ipos
     * IPOs
     * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
     * @param ticker Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc. (optional)
     * @param usCode Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. (optional)
     * @param isin Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world. (optional)
     * @param listingDate Specify a listing date. This is the first trading date for the newly listed entity. (optional)
     * @param ipoStatus Specify an IPO status. (optional)
     * @param listingDateGte Range by listing_date. (optional)
     * @param listingDateGt Range by listing_date. (optional)
     * @param listingDateLte Range by listing_date. (optional)
     * @param listingDateLt Range by listing_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to listing_date)
     * @return ListIPOs200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listIPOs(ticker: kotlin.String? = null, usCode: kotlin.String? = null, isin: kotlin.String? = null, listingDate: java.time.LocalDate? = null, ipoStatus: IpoStatusListIPOs? = null, listingDateGte: java.time.LocalDate? = null, listingDateGt: java.time.LocalDate? = null, listingDateLte: java.time.LocalDate? = null, listingDateLt: java.time.LocalDate? = null, order: OrderListIPOs? = OrderListIPOs.desc, limit: kotlin.Int? = 10, sort: SortListIPOs? = SortListIPOs.listingDate) : ListIPOs200Response {
        val localVarResponse = listIPOsWithHttpInfo(ticker = ticker, usCode = usCode, isin = isin, listingDate = listingDate, ipoStatus = ipoStatus, listingDateGte = listingDateGte, listingDateGt = listingDateGt, listingDateLte = listingDateLte, listingDateLt = listingDateLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListIPOs200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /vX/reference/ipos
     * IPOs
     * The IPOs API provides access to detailed information about Initial Public Offerings (IPOs), including both upcoming and historical events. With this API, you can query for a comprehensive list of IPOs, along with key details such as the issuer name, ticker symbol, ISIN, IPO date, number of shares offered, expected price range, and final offering price. You can filter the results by status to focus on new, rumors, pending, historical, and more.
     * @param ticker Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc. (optional)
     * @param usCode Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. (optional)
     * @param isin Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world. (optional)
     * @param listingDate Specify a listing date. This is the first trading date for the newly listed entity. (optional)
     * @param ipoStatus Specify an IPO status. (optional)
     * @param listingDateGte Range by listing_date. (optional)
     * @param listingDateGt Range by listing_date. (optional)
     * @param listingDateLte Range by listing_date. (optional)
     * @param listingDateLt Range by listing_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to listing_date)
     * @return ApiResponse<ListIPOs200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listIPOsWithHttpInfo(ticker: kotlin.String?, usCode: kotlin.String?, isin: kotlin.String?, listingDate: java.time.LocalDate?, ipoStatus: IpoStatusListIPOs?, listingDateGte: java.time.LocalDate?, listingDateGt: java.time.LocalDate?, listingDateLte: java.time.LocalDate?, listingDateLt: java.time.LocalDate?, order: OrderListIPOs?, limit: kotlin.Int?, sort: SortListIPOs?) : ApiResponse<ListIPOs200Response?> {
        val localVariableConfig = listIPOsRequestConfig(ticker = ticker, usCode = usCode, isin = isin, listingDate = listingDate, ipoStatus = ipoStatus, listingDateGte = listingDateGte, listingDateGt = listingDateGt, listingDateLte = listingDateLte, listingDateLt = listingDateLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListIPOs200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listIPOs
     *
     * @param ticker Specify a case-sensitive ticker symbol. For example, TSLA represents Tesla Inc. (optional)
     * @param usCode Specify a us_code. This is a unique nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. (optional)
     * @param isin Specify an International Securities Identification Number (ISIN). This is a unique twelve-digit code that is assigned to every security issuance in the world. (optional)
     * @param listingDate Specify a listing date. This is the first trading date for the newly listed entity. (optional)
     * @param ipoStatus Specify an IPO status. (optional)
     * @param listingDateGte Range by listing_date. (optional)
     * @param listingDateGt Range by listing_date. (optional)
     * @param listingDateLte Range by listing_date. (optional)
     * @param listingDateLt Range by listing_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional, default to desc)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to listing_date)
     * @return RequestConfig
     */
    fun listIPOsRequestConfig(ticker: kotlin.String?, usCode: kotlin.String?, isin: kotlin.String?, listingDate: java.time.LocalDate?, ipoStatus: IpoStatusListIPOs?, listingDateGte: java.time.LocalDate?, listingDateGt: java.time.LocalDate?, listingDateLte: java.time.LocalDate?, listingDateLt: java.time.LocalDate?, order: OrderListIPOs?, limit: kotlin.Int?, sort: SortListIPOs?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (usCode != null) {
                    put("us_code", listOf(usCode.toString()))
                }
                if (isin != null) {
                    put("isin", listOf(isin.toString()))
                }
                if (listingDate != null) {
                    put("listing_date", listOf(parseDateToQueryString(listingDate)))
                }
                if (ipoStatus != null) {
                    put("ipo_status", listOf(ipoStatus.value))
                }
                if (listingDateGte != null) {
                    put("listing_date.gte", listOf(parseDateToQueryString(listingDateGte)))
                }
                if (listingDateGt != null) {
                    put("listing_date.gt", listOf(parseDateToQueryString(listingDateGt)))
                }
                if (listingDateLte != null) {
                    put("listing_date.lte", listOf(parseDateToQueryString(listingDateLte)))
                }
                if (listingDateLt != null) {
                    put("listing_date.lt", listOf(parseDateToQueryString(listingDateLt)))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/vX/reference/ipos",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sort
     */
     enum class SortListMarketStatuses(val value: kotlin.String) {
         @Json(name = "product_code.asc") productCodePeriodAsc("product_code.asc"),
         @Json(name = "product_code.desc") productCodePeriodDesc("product_code.desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /futures/vX/market-status
     * Market Status
     * The market status endpoint returns the current status of the futures market for the given product code(s).
     * @param productCodeAnyOf The product code(s) to return market statuses for.  Multiple product codes can be specified by separating them with a comma. Currently, the limit is 250 product codes. (optional)
     * @param productCode The product code to return market statuses for. (optional)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to product_code.asc)
     * @return ListMarketStatuses200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listMarketStatuses(productCodeAnyOf: kotlin.String? = null, productCode: kotlin.String? = null, limit: kotlin.Int? = 100, sort: SortListMarketStatuses? = SortListMarketStatuses.productCodePeriodAsc) : ListMarketStatuses200Response {
        val localVarResponse = listMarketStatusesWithHttpInfo(productCodeAnyOf = productCodeAnyOf, productCode = productCode, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListMarketStatuses200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/market-status
     * Market Status
     * The market status endpoint returns the current status of the futures market for the given product code(s).
     * @param productCodeAnyOf The product code(s) to return market statuses for.  Multiple product codes can be specified by separating them with a comma. Currently, the limit is 250 product codes. (optional)
     * @param productCode The product code to return market statuses for. (optional)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to product_code.asc)
     * @return ApiResponse<ListMarketStatuses200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listMarketStatusesWithHttpInfo(productCodeAnyOf: kotlin.String?, productCode: kotlin.String?, limit: kotlin.Int?, sort: SortListMarketStatuses?) : ApiResponse<ListMarketStatuses200Response?> {
        val localVariableConfig = listMarketStatusesRequestConfig(productCodeAnyOf = productCodeAnyOf, productCode = productCode, limit = limit, sort = sort)

        return request<Unit, ListMarketStatuses200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listMarketStatuses
     *
     * @param productCodeAnyOf The product code(s) to return market statuses for.  Multiple product codes can be specified by separating them with a comma. Currently, the limit is 250 product codes. (optional)
     * @param productCode The product code to return market statuses for. (optional)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to product_code.asc)
     * @return RequestConfig
     */
    fun listMarketStatusesRequestConfig(productCodeAnyOf: kotlin.String?, productCode: kotlin.String?, limit: kotlin.Int?, sort: SortListMarketStatuses?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (productCodeAnyOf != null) {
                    put("product_code.any_of", listOf(productCodeAnyOf.toString()))
                }
                if (productCode != null) {
                    put("product_code", listOf(productCode.toString()))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/market-status",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderListNews(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListNews(val value: kotlin.String) {
         @Json(name = "published_utc") publishedUtc("published_utc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v2/reference/news
     * Ticker News
     * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param publishedUtc Return results published on, before, or after this date. (optional)
     * @param tickerGte Search by ticker. (optional)
     * @param tickerGt Search by ticker. (optional)
     * @param tickerLte Search by ticker. (optional)
     * @param tickerLt Search by ticker. (optional)
     * @param publishedUtcGte Search by published_utc. (optional)
     * @param publishedUtcGt Search by published_utc. (optional)
     * @param publishedUtcLte Search by published_utc. (optional)
     * @param publishedUtcLt Search by published_utc. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to published_utc)
     * @return ListNews200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listNews(ticker: kotlin.String? = null, publishedUtc: ListNewsPublishedUtcParameter? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, publishedUtcGte: ListNewsPublishedUtcParameter? = null, publishedUtcGt: ListNewsPublishedUtcParameter? = null, publishedUtcLte: ListNewsPublishedUtcParameter? = null, publishedUtcLt: ListNewsPublishedUtcParameter? = null, order: OrderListNews? = null, limit: kotlin.Int? = 10, sort: SortListNews? = SortListNews.publishedUtc) : ListNews200Response {
        val localVarResponse = listNewsWithHttpInfo(ticker = ticker, publishedUtc = publishedUtc, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, publishedUtcGte = publishedUtcGte, publishedUtcGt = publishedUtcGt, publishedUtcLte = publishedUtcLte, publishedUtcLt = publishedUtcLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListNews200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v2/reference/news
     * Ticker News
     * Get the most recent news articles relating to a stock ticker symbol, including a summary of the article and a link to the original source.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param publishedUtc Return results published on, before, or after this date. (optional)
     * @param tickerGte Search by ticker. (optional)
     * @param tickerGt Search by ticker. (optional)
     * @param tickerLte Search by ticker. (optional)
     * @param tickerLt Search by ticker. (optional)
     * @param publishedUtcGte Search by published_utc. (optional)
     * @param publishedUtcGt Search by published_utc. (optional)
     * @param publishedUtcLte Search by published_utc. (optional)
     * @param publishedUtcLt Search by published_utc. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to published_utc)
     * @return ApiResponse<ListNews200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listNewsWithHttpInfo(ticker: kotlin.String?, publishedUtc: ListNewsPublishedUtcParameter?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, publishedUtcGte: ListNewsPublishedUtcParameter?, publishedUtcGt: ListNewsPublishedUtcParameter?, publishedUtcLte: ListNewsPublishedUtcParameter?, publishedUtcLt: ListNewsPublishedUtcParameter?, order: OrderListNews?, limit: kotlin.Int?, sort: SortListNews?) : ApiResponse<ListNews200Response?> {
        val localVariableConfig = listNewsRequestConfig(ticker = ticker, publishedUtc = publishedUtc, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, publishedUtcGte = publishedUtcGte, publishedUtcGt = publishedUtcGt, publishedUtcLte = publishedUtcLte, publishedUtcLt = publishedUtcLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListNews200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listNews
     *
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param publishedUtc Return results published on, before, or after this date. (optional)
     * @param tickerGte Search by ticker. (optional)
     * @param tickerGt Search by ticker. (optional)
     * @param tickerLte Search by ticker. (optional)
     * @param tickerLt Search by ticker. (optional)
     * @param publishedUtcGte Search by published_utc. (optional)
     * @param publishedUtcGt Search by published_utc. (optional)
     * @param publishedUtcLte Search by published_utc. (optional)
     * @param publishedUtcLt Search by published_utc. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to published_utc)
     * @return RequestConfig
     */
    fun listNewsRequestConfig(ticker: kotlin.String?, publishedUtc: ListNewsPublishedUtcParameter?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, publishedUtcGte: ListNewsPublishedUtcParameter?, publishedUtcGt: ListNewsPublishedUtcParameter?, publishedUtcLte: ListNewsPublishedUtcParameter?, publishedUtcLt: ListNewsPublishedUtcParameter?, order: OrderListNews?, limit: kotlin.Int?, sort: SortListNews?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (publishedUtc != null) {
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (publishedUtcGte != null) {
                }
                if (publishedUtcGt != null) {
                }
                if (publishedUtcLte != null) {
                }
                if (publishedUtcLt != null) {
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v2/reference/news",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter contractType
     */
     enum class ContractTypeListOptionsContracts(val value: kotlin.String) {
         @Json(name = "call") call("call"),
         @Json(name = "put") put("put");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListOptionsContracts(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListOptionsContracts(val value: kotlin.String) {
         @Json(name = "ticker") ticker("ticker"),
         @Json(name = "underlying_ticker") underlyingTicker("underlying_ticker"),
         @Json(name = "expiration_date") expirationDate("expiration_date"),
         @Json(name = "strike_price") strikePrice("strike_price");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/options/contracts
     * Options Contracts
     * Query for historical options contracts. This provides both active and expired options contracts.
     * @param underlyingTicker Query for contracts relating to an underlying stock ticker. (optional)
     * @param ticker This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://massive.com/docs/rest/options/contracts/contract-overview). (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param asOf Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expired Query for expired contracts. Default is false. (optional)
     * @param underlyingTickerGte Range by underlying_ticker. (optional)
     * @param underlyingTickerGt Range by underlying_ticker. (optional)
     * @param underlyingTickerLte Range by underlying_ticker. (optional)
     * @param underlyingTickerLt Range by underlying_ticker. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ListOptionsContracts200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listOptionsContracts(underlyingTicker: kotlin.String? = null, ticker: kotlin.String? = null, contractType: ContractTypeListOptionsContracts? = null, expirationDate: kotlin.String? = null, asOf: kotlin.String? = null, strikePrice: java.math.BigDecimal? = null, expired: kotlin.Boolean? = null, underlyingTickerGte: kotlin.String? = null, underlyingTickerGt: kotlin.String? = null, underlyingTickerLte: kotlin.String? = null, underlyingTickerLt: kotlin.String? = null, expirationDateGte: kotlin.String? = null, expirationDateGt: kotlin.String? = null, expirationDateLte: kotlin.String? = null, expirationDateLt: kotlin.String? = null, strikePriceGte: java.math.BigDecimal? = null, strikePriceGt: java.math.BigDecimal? = null, strikePriceLte: java.math.BigDecimal? = null, strikePriceLt: java.math.BigDecimal? = null, order: OrderListOptionsContracts? = null, limit: kotlin.Int? = 10, sort: SortListOptionsContracts? = SortListOptionsContracts.ticker) : ListOptionsContracts200Response {
        val localVarResponse = listOptionsContractsWithHttpInfo(underlyingTicker = underlyingTicker, ticker = ticker, contractType = contractType, expirationDate = expirationDate, asOf = asOf, strikePrice = strikePrice, expired = expired, underlyingTickerGte = underlyingTickerGte, underlyingTickerGt = underlyingTickerGt, underlyingTickerLte = underlyingTickerLte, underlyingTickerLt = underlyingTickerLt, expirationDateGte = expirationDateGte, expirationDateGt = expirationDateGt, expirationDateLte = expirationDateLte, expirationDateLt = expirationDateLt, strikePriceGte = strikePriceGte, strikePriceGt = strikePriceGt, strikePriceLte = strikePriceLte, strikePriceLt = strikePriceLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListOptionsContracts200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/options/contracts
     * Options Contracts
     * Query for historical options contracts. This provides both active and expired options contracts.
     * @param underlyingTicker Query for contracts relating to an underlying stock ticker. (optional)
     * @param ticker This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://massive.com/docs/rest/options/contracts/contract-overview). (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param asOf Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expired Query for expired contracts. Default is false. (optional)
     * @param underlyingTickerGte Range by underlying_ticker. (optional)
     * @param underlyingTickerGt Range by underlying_ticker. (optional)
     * @param underlyingTickerLte Range by underlying_ticker. (optional)
     * @param underlyingTickerLt Range by underlying_ticker. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ApiResponse<ListOptionsContracts200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listOptionsContractsWithHttpInfo(underlyingTicker: kotlin.String?, ticker: kotlin.String?, contractType: ContractTypeListOptionsContracts?, expirationDate: kotlin.String?, asOf: kotlin.String?, strikePrice: java.math.BigDecimal?, expired: kotlin.Boolean?, underlyingTickerGte: kotlin.String?, underlyingTickerGt: kotlin.String?, underlyingTickerLte: kotlin.String?, underlyingTickerLt: kotlin.String?, expirationDateGte: kotlin.String?, expirationDateGt: kotlin.String?, expirationDateLte: kotlin.String?, expirationDateLt: kotlin.String?, strikePriceGte: java.math.BigDecimal?, strikePriceGt: java.math.BigDecimal?, strikePriceLte: java.math.BigDecimal?, strikePriceLt: java.math.BigDecimal?, order: OrderListOptionsContracts?, limit: kotlin.Int?, sort: SortListOptionsContracts?) : ApiResponse<ListOptionsContracts200Response?> {
        val localVariableConfig = listOptionsContractsRequestConfig(underlyingTicker = underlyingTicker, ticker = ticker, contractType = contractType, expirationDate = expirationDate, asOf = asOf, strikePrice = strikePrice, expired = expired, underlyingTickerGte = underlyingTickerGte, underlyingTickerGt = underlyingTickerGt, underlyingTickerLte = underlyingTickerLte, underlyingTickerLt = underlyingTickerLt, expirationDateGte = expirationDateGte, expirationDateGt = expirationDateGt, expirationDateLte = expirationDateLte, expirationDateLt = expirationDateLt, strikePriceGte = strikePriceGte, strikePriceGt = strikePriceGt, strikePriceLte = strikePriceLte, strikePriceLt = strikePriceLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListOptionsContracts200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listOptionsContracts
     *
     * @param underlyingTicker Query for contracts relating to an underlying stock ticker. (optional)
     * @param ticker This parameter has been deprecated. To search by specific options ticker, use the Options Contract endpoint [here](https://massive.com/docs/rest/options/contracts/contract-overview). (optional)
     * @param contractType Query by the type of contract. (optional)
     * @param expirationDate Query by contract expiration with date format YYYY-MM-DD. (optional)
     * @param asOf Specify a point in time for contracts as of this date with format YYYY-MM-DD. Defaults to today&#39;s date. (optional)
     * @param strikePrice Query by strike price of a contract. (optional)
     * @param expired Query for expired contracts. Default is false. (optional)
     * @param underlyingTickerGte Range by underlying_ticker. (optional)
     * @param underlyingTickerGt Range by underlying_ticker. (optional)
     * @param underlyingTickerLte Range by underlying_ticker. (optional)
     * @param underlyingTickerLt Range by underlying_ticker. (optional)
     * @param expirationDateGte Range by expiration_date. (optional)
     * @param expirationDateGt Range by expiration_date. (optional)
     * @param expirationDateLte Range by expiration_date. (optional)
     * @param expirationDateLt Range by expiration_date. (optional)
     * @param strikePriceGte Range by strike_price. (optional)
     * @param strikePriceGt Range by strike_price. (optional)
     * @param strikePriceLte Range by strike_price. (optional)
     * @param strikePriceLt Range by strike_price. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return RequestConfig
     */
    fun listOptionsContractsRequestConfig(underlyingTicker: kotlin.String?, ticker: kotlin.String?, contractType: ContractTypeListOptionsContracts?, expirationDate: kotlin.String?, asOf: kotlin.String?, strikePrice: java.math.BigDecimal?, expired: kotlin.Boolean?, underlyingTickerGte: kotlin.String?, underlyingTickerGt: kotlin.String?, underlyingTickerLte: kotlin.String?, underlyingTickerLt: kotlin.String?, expirationDateGte: kotlin.String?, expirationDateGt: kotlin.String?, expirationDateLte: kotlin.String?, expirationDateLt: kotlin.String?, strikePriceGte: java.math.BigDecimal?, strikePriceGt: java.math.BigDecimal?, strikePriceLte: java.math.BigDecimal?, strikePriceLt: java.math.BigDecimal?, order: OrderListOptionsContracts?, limit: kotlin.Int?, sort: SortListOptionsContracts?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (underlyingTicker != null) {
                    put("underlying_ticker", listOf(underlyingTicker.toString()))
                }
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (contractType != null) {
                    put("contract_type", listOf(contractType.value))
                }
                if (expirationDate != null) {
                    put("expiration_date", listOf(expirationDate.toString()))
                }
                if (asOf != null) {
                    put("as_of", listOf(asOf.toString()))
                }
                if (strikePrice != null) {
                    put("strike_price", listOf(strikePrice.toString()))
                }
                if (expired != null) {
                    put("expired", listOf(expired.toString()))
                }
                if (underlyingTickerGte != null) {
                    put("underlying_ticker.gte", listOf(underlyingTickerGte.toString()))
                }
                if (underlyingTickerGt != null) {
                    put("underlying_ticker.gt", listOf(underlyingTickerGt.toString()))
                }
                if (underlyingTickerLte != null) {
                    put("underlying_ticker.lte", listOf(underlyingTickerLte.toString()))
                }
                if (underlyingTickerLt != null) {
                    put("underlying_ticker.lt", listOf(underlyingTickerLt.toString()))
                }
                if (expirationDateGte != null) {
                    put("expiration_date.gte", listOf(expirationDateGte.toString()))
                }
                if (expirationDateGt != null) {
                    put("expiration_date.gt", listOf(expirationDateGt.toString()))
                }
                if (expirationDateLte != null) {
                    put("expiration_date.lte", listOf(expirationDateLte.toString()))
                }
                if (expirationDateLt != null) {
                    put("expiration_date.lt", listOf(expirationDateLt.toString()))
                }
                if (strikePriceGte != null) {
                    put("strike_price.gte", listOf(strikePriceGte.toString()))
                }
                if (strikePriceGt != null) {
                    put("strike_price.gt", listOf(strikePriceGt.toString()))
                }
                if (strikePriceLte != null) {
                    put("strike_price.lte", listOf(strikePriceLte.toString()))
                }
                if (strikePriceLt != null) {
                    put("strike_price.lt", listOf(strikePriceLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/options/contracts",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sector
     */
     enum class SectorListProducts(val value: kotlin.String) {
         @Json(name = "asia") asia("asia"),
         @Json(name = "base") base("base"),
         @Json(name = "biofuels") biofuels("biofuels"),
         @Json(name = "coal") coal("coal"),
         @Json(name = "cross_rates") crossRates("cross_rates"),
         @Json(name = "crude_oil") crudeOil("crude_oil"),
         @Json(name = "custom_index") customIndex("custom_index"),
         @Json(name = "dairy") dairy("dairy"),
         @Json(name = "dj_ubs_ci") djUbsCi("dj_ubs_ci"),
         @Json(name = "electricity") electricity("electricity"),
         @Json(name = "emissions") emissions("emissions"),
         @Json(name = "europe") europe("europe"),
         @Json(name = "fertilizer") fertilizer("fertilizer"),
         @Json(name = "forestry") forestry("forestry"),
         @Json(name = "grains_and_oilseeds") grainsAndOilseeds("grains_and_oilseeds"),
         @Json(name = "intl_index") intlIndex("intl_index"),
         @Json(name = "liq_nat_gas_lng") liqNatGasLng("liq_nat_gas_lng"),
         @Json(name = "livestock") livestock("livestock"),
         @Json(name = "long_term_gov") longTermGov("long_term_gov"),
         @Json(name = "long_term_non_gov") longTermNonGov("long_term_non_gov"),
         @Json(name = "majors") majors("majors"),
         @Json(name = "minors") minors("minors"),
         @Json(name = "nat_gas") natGas("nat_gas"),
         @Json(name = "nat_gas_liq_petro") natGasLiqPetro("nat_gas_liq_petro"),
         @Json(name = "precious") precious("precious"),
         @Json(name = "refined_products") refinedProducts("refined_products"),
         @Json(name = "s_and_p_gsci") sAndPGsci("s_and_p_gsci"),
         @Json(name = "sel_sector_index") selSectorIndex("sel_sector_index"),
         @Json(name = "short_term_gov") shortTermGov("short_term_gov"),
         @Json(name = "short_term_non_gov") shortTermNonGov("short_term_non_gov"),
         @Json(name = "softs") softs("softs"),
         @Json(name = "us") us("us"),
         @Json(name = "us_index") usIndex("us_index"),
         @Json(name = "wet_bulk") wetBulk("wet_bulk");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter subSector
     */
     enum class SubSectorListProducts(val value: kotlin.String) {
         @Json(name = "asian") asian("asian"),
         @Json(name = "canadian") canadian("canadian"),
         @Json(name = "cat") cat("cat"),
         @Json(name = "cooling_degree_days") coolingDegreeDays("cooling_degree_days"),
         @Json(name = "ercot") ercot("ercot"),
         @Json(name = "european") european("european"),
         @Json(name = "gulf") gulf("gulf"),
         @Json(name = "heating_degree_days") heatingDegreeDays("heating_degree_days"),
         @Json(name = "iso_ne") isoNe("iso_ne"),
         @Json(name = "large_cap_index") largeCapIndex("large_cap_index"),
         @Json(name = "mid_cap_index") midCapIndex("mid_cap_index"),
         @Json(name = "miso") miso("miso"),
         @Json(name = "north_american") northAmerican("north_american"),
         @Json(name = "nyiso") nyiso("nyiso"),
         @Json(name = "pjm") pjm("pjm"),
         @Json(name = "small_cap_index") smallCapIndex("small_cap_index"),
         @Json(name = "west") west("west"),
         @Json(name = "western_power") westernPower("western_power");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter assetClass
     */
     enum class AssetClassListProducts(val value: kotlin.String) {
         @Json(name = "alt_investment") altInvestment("alt_investment"),
         @Json(name = "commodity") commodity("commodity"),
         @Json(name = "financials") financials("financials");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter assetSubClass
     */
     enum class AssetSubClassListProducts(val value: kotlin.String) {
         @Json(name = "agricultural") agricultural("agricultural"),
         @Json(name = "commodity_index") commodityIndex("commodity_index"),
         @Json(name = "energy") energy("energy"),
         @Json(name = "equity") equity("equity"),
         @Json(name = "foreign_exchange") foreignExchange("foreign_exchange"),
         @Json(name = "freight") freight("freight"),
         @Json(name = "housing") housing("housing"),
         @Json(name = "interest_rate") interestRate("interest_rate"),
         @Json(name = "metals") metals("metals"),
         @Json(name = "weather") weather("weather");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter type
     */
     enum class TypeListProducts(val value: kotlin.String) {
         @Json(name = "all") all("all"),
         @Json(name = "single") single("single"),
         @Json(name = "combo") combo("combo");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListProducts(val value: kotlin.String) {
         @Json(name = "name.asc") namePeriodAsc("name.asc"),
         @Json(name = "name.desc") namePeriodDesc("name.desc"),
         @Json(name = "trading_venue.asc") tradingVenuePeriodAsc("trading_venue.asc"),
         @Json(name = "trading_venue.desc") tradingVenuePeriodDesc("trading_venue.desc"),
         @Json(name = "sector.asc") sectorPeriodAsc("sector.asc"),
         @Json(name = "sector.desc") sectorPeriodDesc("sector.desc"),
         @Json(name = "sub_sector.asc") subSectorPeriodAsc("sub_sector.asc"),
         @Json(name = "sub_sector.desc") subSectorPeriodDesc("sub_sector.desc"),
         @Json(name = "asset_class.asc") assetClassPeriodAsc("asset_class.asc"),
         @Json(name = "asset_class.desc") assetClassPeriodDesc("asset_class.desc"),
         @Json(name = "asset_sub_class.asc") assetSubClassPeriodAsc("asset_sub_class.asc"),
         @Json(name = "asset_sub_class.desc") assetSubClassPeriodDesc("asset_sub_class.desc"),
         @Json(name = "type.asc") typePeriodAsc("type.asc"),
         @Json(name = "type.desc") typePeriodDesc("type.desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /futures/vX/products
     * Products
     * The Products endpoint returns a list of futures products. This endpoint can be used to query for products based on a variety of parameters, including by the product&#39;s name, exchange, sector, sub-sector, asset class, asset sub-class, and type.
     * @param name Search for products by Product Name. This parameter supports an exact match, while a name-contains search can be performed using the &#x60;name.search&#x60; parameter. Note that the search is case-sensitive. (optional)
     * @param asOf A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today). (optional)
     * @param tradingVenue The trading venue (MIC) for the exchange on which the products trades. (optional)
     * @param sector The sector to which the products belong. (optional)
     * @param subSector The sub-sector to which the products belong. (optional)
     * @param assetClass The asset class to which the products belong. (optional)
     * @param assetSubClass The asset sub-class to which the products belong. (optional)
     * @param type The type of products to return. One of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all). (optional, default to all)
     * @param limit The number of results to return per page (default&#x3D;100, maximum&#x3D;1000, minimum&#x3D;1). (optional, default to 100)
     * @param nameSearch Search by name. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to name.asc)
     * @return ListProducts200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listProducts(name: kotlin.String? = null, asOf: java.time.LocalDate? = null, tradingVenue: kotlin.String? = null, sector: SectorListProducts? = null, subSector: SubSectorListProducts? = null, assetClass: AssetClassListProducts? = null, assetSubClass: AssetSubClassListProducts? = null, type: TypeListProducts? = TypeListProducts.all, limit: kotlin.Int? = 100, nameSearch: kotlin.String? = null, sort: SortListProducts? = SortListProducts.namePeriodAsc) : ListProducts200Response {
        val localVarResponse = listProductsWithHttpInfo(name = name, asOf = asOf, tradingVenue = tradingVenue, sector = sector, subSector = subSector, assetClass = assetClass, assetSubClass = assetSubClass, type = type, limit = limit, nameSearch = nameSearch, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListProducts200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/products
     * Products
     * The Products endpoint returns a list of futures products. This endpoint can be used to query for products based on a variety of parameters, including by the product&#39;s name, exchange, sector, sub-sector, asset class, asset sub-class, and type.
     * @param name Search for products by Product Name. This parameter supports an exact match, while a name-contains search can be performed using the &#x60;name.search&#x60; parameter. Note that the search is case-sensitive. (optional)
     * @param asOf A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today). (optional)
     * @param tradingVenue The trading venue (MIC) for the exchange on which the products trades. (optional)
     * @param sector The sector to which the products belong. (optional)
     * @param subSector The sub-sector to which the products belong. (optional)
     * @param assetClass The asset class to which the products belong. (optional)
     * @param assetSubClass The asset sub-class to which the products belong. (optional)
     * @param type The type of products to return. One of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all). (optional, default to all)
     * @param limit The number of results to return per page (default&#x3D;100, maximum&#x3D;1000, minimum&#x3D;1). (optional, default to 100)
     * @param nameSearch Search by name. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to name.asc)
     * @return ApiResponse<ListProducts200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listProductsWithHttpInfo(name: kotlin.String?, asOf: java.time.LocalDate?, tradingVenue: kotlin.String?, sector: SectorListProducts?, subSector: SubSectorListProducts?, assetClass: AssetClassListProducts?, assetSubClass: AssetSubClassListProducts?, type: TypeListProducts?, limit: kotlin.Int?, nameSearch: kotlin.String?, sort: SortListProducts?) : ApiResponse<ListProducts200Response?> {
        val localVariableConfig = listProductsRequestConfig(name = name, asOf = asOf, tradingVenue = tradingVenue, sector = sector, subSector = subSector, assetClass = assetClass, assetSubClass = assetSubClass, type = type, limit = limit, nameSearch = nameSearch, sort = sort)

        return request<Unit, ListProducts200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listProducts
     *
     * @param name Search for products by Product Name. This parameter supports an exact match, while a name-contains search can be performed using the &#x60;name.search&#x60; parameter. Note that the search is case-sensitive. (optional)
     * @param asOf A date string in the format YYYY-MM-DD. This parameter will return point-in-time information about products for the specified day (default&#x3D;today). (optional)
     * @param tradingVenue The trading venue (MIC) for the exchange on which the products trades. (optional)
     * @param sector The sector to which the products belong. (optional)
     * @param subSector The sub-sector to which the products belong. (optional)
     * @param assetClass The asset class to which the products belong. (optional)
     * @param assetSubClass The asset sub-class to which the products belong. (optional)
     * @param type The type of products to return. One of \&quot;all\&quot;, \&quot;single\&quot;, or \&quot;combo\&quot; (default&#x3D;all). (optional, default to all)
     * @param limit The number of results to return per page (default&#x3D;100, maximum&#x3D;1000, minimum&#x3D;1). (optional, default to 100)
     * @param nameSearch Search by name. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to name.asc)
     * @return RequestConfig
     */
    fun listProductsRequestConfig(name: kotlin.String?, asOf: java.time.LocalDate?, tradingVenue: kotlin.String?, sector: SectorListProducts?, subSector: SubSectorListProducts?, assetClass: AssetClassListProducts?, assetSubClass: AssetSubClassListProducts?, type: TypeListProducts?, limit: kotlin.Int?, nameSearch: kotlin.String?, sort: SortListProducts?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (name != null) {
                    put("name", listOf(name.toString()))
                }
                if (asOf != null) {
                    put("as_of", listOf(parseDateToQueryString(asOf)))
                }
                if (tradingVenue != null) {
                    put("trading_venue", listOf(tradingVenue.toString()))
                }
                if (sector != null) {
                    put("sector", listOf(sector.value))
                }
                if (subSector != null) {
                    put("sub_sector", listOf(subSector.value))
                }
                if (assetClass != null) {
                    put("asset_class", listOf(assetClass.value))
                }
                if (assetSubClass != null) {
                    put("asset_sub_class", listOf(assetSubClass.value))
                }
                if (type != null) {
                    put("type", listOf(type.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (nameSearch != null) {
                    put("name.search", listOf(nameSearch.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/products",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter order
     */
     enum class OrderListStockSplits(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListStockSplits(val value: kotlin.String) {
         @Json(name = "execution_date") executionDate("execution_date"),
         @Json(name = "ticker") ticker("ticker");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/splits
     * Stock Splits v3
     * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param executionDate Query by execution date with the format YYYY-MM-DD. (optional)
     * @param reverseSplit Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param executionDateGte Range by execution_date. (optional)
     * @param executionDateGt Range by execution_date. (optional)
     * @param executionDateLte Range by execution_date. (optional)
     * @param executionDateLt Range by execution_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to execution_date)
     * @return ListStockSplits200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listStockSplits(ticker: kotlin.String? = null, executionDate: java.time.LocalDate? = null, reverseSplit: kotlin.Boolean? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, executionDateGte: java.time.LocalDate? = null, executionDateGt: java.time.LocalDate? = null, executionDateLte: java.time.LocalDate? = null, executionDateLt: java.time.LocalDate? = null, order: OrderListStockSplits? = null, limit: kotlin.Int? = 10, sort: SortListStockSplits? = SortListStockSplits.executionDate) : ListStockSplits200Response {
        val localVarResponse = listStockSplitsWithHttpInfo(ticker = ticker, executionDate = executionDate, reverseSplit = reverseSplit, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, executionDateGte = executionDateGte, executionDateGt = executionDateGt, executionDateLte = executionDateLte, executionDateLt = executionDateLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListStockSplits200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/splits
     * Stock Splits v3
     * Get a list of historical stock splits, including the ticker symbol, the execution date, and the factors of the split ratio.
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param executionDate Query by execution date with the format YYYY-MM-DD. (optional)
     * @param reverseSplit Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param executionDateGte Range by execution_date. (optional)
     * @param executionDateGt Range by execution_date. (optional)
     * @param executionDateLte Range by execution_date. (optional)
     * @param executionDateLt Range by execution_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to execution_date)
     * @return ApiResponse<ListStockSplits200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listStockSplitsWithHttpInfo(ticker: kotlin.String?, executionDate: java.time.LocalDate?, reverseSplit: kotlin.Boolean?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, executionDateGte: java.time.LocalDate?, executionDateGt: java.time.LocalDate?, executionDateLte: java.time.LocalDate?, executionDateLt: java.time.LocalDate?, order: OrderListStockSplits?, limit: kotlin.Int?, sort: SortListStockSplits?) : ApiResponse<ListStockSplits200Response?> {
        val localVariableConfig = listStockSplitsRequestConfig(ticker = ticker, executionDate = executionDate, reverseSplit = reverseSplit, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, executionDateGte = executionDateGte, executionDateGt = executionDateGt, executionDateLte = executionDateLte, executionDateLt = executionDateLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListStockSplits200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listStockSplits
     *
     * @param ticker Specify a case-sensitive ticker symbol. For example, AAPL represents Apple Inc. (optional)
     * @param executionDate Query by execution date with the format YYYY-MM-DD. (optional)
     * @param reverseSplit Query for reverse stock splits. A split ratio where split_from is greater than split_to represents a reverse split. By default this filter is not used. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param executionDateGte Range by execution_date. (optional)
     * @param executionDateGt Range by execution_date. (optional)
     * @param executionDateLte Range by execution_date. (optional)
     * @param executionDateLt Range by execution_date. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 10 and max is 1000. (optional, default to 10)
     * @param sort Sort field used for ordering. (optional, default to execution_date)
     * @return RequestConfig
     */
    fun listStockSplitsRequestConfig(ticker: kotlin.String?, executionDate: java.time.LocalDate?, reverseSplit: kotlin.Boolean?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, executionDateGte: java.time.LocalDate?, executionDateGt: java.time.LocalDate?, executionDateLte: java.time.LocalDate?, executionDateLt: java.time.LocalDate?, order: OrderListStockSplits?, limit: kotlin.Int?, sort: SortListStockSplits?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (executionDate != null) {
                    put("execution_date", listOf(parseDateToQueryString(executionDate)))
                }
                if (reverseSplit != null) {
                    put("reverse_split", listOf(reverseSplit.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (executionDateGte != null) {
                    put("execution_date.gte", listOf(parseDateToQueryString(executionDateGte)))
                }
                if (executionDateGt != null) {
                    put("execution_date.gt", listOf(parseDateToQueryString(executionDateGt)))
                }
                if (executionDateLte != null) {
                    put("execution_date.lte", listOf(parseDateToQueryString(executionDateLte)))
                }
                if (executionDateLt != null) {
                    put("execution_date.lt", listOf(parseDateToQueryString(executionDateLt)))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/splits",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter assetClass
     */
     enum class AssetClassListTickerTypes(val value: kotlin.String) {
         @Json(name = "stocks") stocks("stocks"),
         @Json(name = "options") options("options"),
         @Json(name = "crypto") crypto("crypto"),
         @Json(name = "fx") fx("fx"),
         @Json(name = "indices") indices("indices");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter locale
     */
     enum class LocaleListTickerTypes(val value: kotlin.String) {
         @Json(name = "us") us("us"),
         @Json(name = "global") global("global");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/tickers/types
     * Ticker Types
     * List all ticker types that Massive has.
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return ListTickerTypes200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTickerTypes(assetClass: AssetClassListTickerTypes? = null, locale: LocaleListTickerTypes? = null) : ListTickerTypes200Response {
        val localVarResponse = listTickerTypesWithHttpInfo(assetClass = assetClass, locale = locale)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListTickerTypes200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/tickers/types
     * Ticker Types
     * List all ticker types that Massive has.
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return ApiResponse<ListTickerTypes200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listTickerTypesWithHttpInfo(assetClass: AssetClassListTickerTypes?, locale: LocaleListTickerTypes?) : ApiResponse<ListTickerTypes200Response?> {
        val localVariableConfig = listTickerTypesRequestConfig(assetClass = assetClass, locale = locale)

        return request<Unit, ListTickerTypes200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listTickerTypes
     *
     * @param assetClass Filter by asset class. (optional)
     * @param locale Filter by locale. (optional)
     * @return RequestConfig
     */
    fun listTickerTypesRequestConfig(assetClass: AssetClassListTickerTypes?, locale: LocaleListTickerTypes?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (assetClass != null) {
                    put("asset_class", listOf(assetClass.value))
                }
                if (locale != null) {
                    put("locale", listOf(locale.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/tickers/types",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter type
     */
     enum class TypeListTickers(val value: kotlin.String) {
         @Json(name = "CS") cS("CS"),
         @Json(name = "ADRC") aDRC("ADRC"),
         @Json(name = "ADRP") aDRP("ADRP"),
         @Json(name = "ADRR") aDRR("ADRR"),
         @Json(name = "UNIT") uNIT("UNIT"),
         @Json(name = "RIGHT") rIGHT("RIGHT"),
         @Json(name = "PFD") pFD("PFD"),
         @Json(name = "FUND") fUND("FUND"),
         @Json(name = "SP") sP("SP"),
         @Json(name = "WARRANT") wARRANT("WARRANT"),
         @Json(name = "INDEX") iNDEX("INDEX"),
         @Json(name = "ETF") eTF("ETF"),
         @Json(name = "ETN") eTN("ETN"),
         @Json(name = "OS") oS("OS"),
         @Json(name = "GDR") gDR("GDR"),
         @Json(name = "OTHER") oTHER("OTHER"),
         @Json(name = "NYRS") nYRS("NYRS"),
         @Json(name = "AGEN") aGEN("AGEN"),
         @Json(name = "EQLK") eQLK("EQLK"),
         @Json(name = "BOND") bOND("BOND"),
         @Json(name = "ADRW") aDRW("ADRW"),
         @Json(name = "BASKET") bASKET("BASKET"),
         @Json(name = "LT") lT("LT");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter market
     */
     enum class MarketListTickers(val value: kotlin.String) {
         @Json(name = "stocks") stocks("stocks"),
         @Json(name = "crypto") crypto("crypto"),
         @Json(name = "fx") fx("fx"),
         @Json(name = "otc") otc("otc"),
         @Json(name = "indices") indices("indices");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter order
     */
     enum class OrderListTickers(val value: kotlin.String) {
         @Json(name = "asc") asc("asc"),
         @Json(name = "desc") desc("desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * enum for parameter sort
     */
     enum class SortListTickers(val value: kotlin.String) {
         @Json(name = "ticker") ticker("ticker"),
         @Json(name = "name") nameEnum("name"),
         @Json(name = "market") market("market"),
         @Json(name = "locale") locale("locale"),
         @Json(name = "primary_exchange") primaryExchange("primary_exchange"),
         @Json(name = "type") type("type"),
         @Json(name = "currency_symbol") currencySymbol("currency_symbol"),
         @Json(name = "currency_name") currencyName("currency_name"),
         @Json(name = "base_currency_symbol") baseCurrencySymbol("base_currency_symbol"),
         @Json(name = "base_currency_name") baseCurrencyName("base_currency_name"),
         @Json(name = "cik") cik("cik"),
         @Json(name = "composite_figi") compositeFigi("composite_figi"),
         @Json(name = "share_class_figi") shareClassFigi("share_class_figi"),
         @Json(name = "last_updated_utc") lastUpdatedUtc("last_updated_utc"),
         @Json(name = "delisted_utc") delistedUtc("delisted_utc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /v3/reference/tickers
     * Tickers
     * Query all ticker symbols which are supported by Massive. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
     * @param ticker Specify a ticker symbol. Defaults to empty string which queries all tickers. (optional)
     * @param type Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types). Defaults to empty string which queries all types. (optional)
     * @param market Filter by market type. By default all markets are included. (optional)
     * @param exchange Specify the asset&#39;s primary exchange Market Identifier Code (MIC) according to [ISO 10383](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges. (optional)
     * @param cusip Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response. (optional)
     * @param cik Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs. (optional)
     * @param date Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date. (optional)
     * @param search Search for terms within the ticker and/or company name. (optional)
     * @param active Specify if the tickers returned should be actively traded on the queried date. Default is true. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 100 and max is 1000. (optional, default to 100)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ListTickers200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun listTickers(ticker: kotlin.String? = null, type: TypeListTickers? = null, market: MarketListTickers? = null, exchange: kotlin.String? = null, cusip: kotlin.String? = null, cik: kotlin.String? = null, date: java.time.LocalDate? = null, search: kotlin.String? = null, active: kotlin.Boolean? = null, tickerGte: kotlin.String? = null, tickerGt: kotlin.String? = null, tickerLte: kotlin.String? = null, tickerLt: kotlin.String? = null, order: OrderListTickers? = null, limit: kotlin.Int? = 100, sort: SortListTickers? = SortListTickers.ticker) : ListTickers200Response {
        val localVarResponse = listTickersWithHttpInfo(ticker = ticker, type = type, market = market, exchange = exchange, cusip = cusip, cik = cik, date = date, search = search, active = active, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, order = order, limit = limit, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ListTickers200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /v3/reference/tickers
     * Tickers
     * Query all ticker symbols which are supported by Massive. This API currently includes Stocks/Equities, Indices, Forex, and Crypto.
     * @param ticker Specify a ticker symbol. Defaults to empty string which queries all tickers. (optional)
     * @param type Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types). Defaults to empty string which queries all types. (optional)
     * @param market Filter by market type. By default all markets are included. (optional)
     * @param exchange Specify the asset&#39;s primary exchange Market Identifier Code (MIC) according to [ISO 10383](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges. (optional)
     * @param cusip Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response. (optional)
     * @param cik Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs. (optional)
     * @param date Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date. (optional)
     * @param search Search for terms within the ticker and/or company name. (optional)
     * @param active Specify if the tickers returned should be actively traded on the queried date. Default is true. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 100 and max is 1000. (optional, default to 100)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return ApiResponse<ListTickers200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun listTickersWithHttpInfo(ticker: kotlin.String?, type: TypeListTickers?, market: MarketListTickers?, exchange: kotlin.String?, cusip: kotlin.String?, cik: kotlin.String?, date: java.time.LocalDate?, search: kotlin.String?, active: kotlin.Boolean?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, order: OrderListTickers?, limit: kotlin.Int?, sort: SortListTickers?) : ApiResponse<ListTickers200Response?> {
        val localVariableConfig = listTickersRequestConfig(ticker = ticker, type = type, market = market, exchange = exchange, cusip = cusip, cik = cik, date = date, search = search, active = active, tickerGte = tickerGte, tickerGt = tickerGt, tickerLte = tickerLte, tickerLt = tickerLt, order = order, limit = limit, sort = sort)

        return request<Unit, ListTickers200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation listTickers
     *
     * @param ticker Specify a ticker symbol. Defaults to empty string which queries all tickers. (optional)
     * @param type Specify the type of the tickers. Find the types that we support via our [Ticker Types API](https://massive.com/docs/rest/stocks/tickers/ticker-types). Defaults to empty string which queries all types. (optional)
     * @param market Filter by market type. By default all markets are included. (optional)
     * @param exchange Specify the asset&#39;s primary exchange Market Identifier Code (MIC) according to [ISO 10383](https://www.iso20022.org/market-identifier-codes). Defaults to empty string which queries all exchanges. (optional)
     * @param cusip Specify the CUSIP code of the asset you want to search for. Find more information about CUSIP codes [at their website](https://www.cusip.com/identifiers.html#/CUSIP). Defaults to empty string which queries all CUSIPs.  Note: Although you can query by CUSIP, due to legal reasons we do not return the CUSIP in the response. (optional)
     * @param cik Specify the CIK of the asset you want to search for. Find more information about CIK codes [at their website](https://www.sec.gov/edgar/searchedgar/cik.htm). Defaults to empty string which queries all CIKs. (optional)
     * @param date Specify a point in time to retrieve tickers available on that date. Defaults to the most recent available date. (optional)
     * @param search Search for terms within the ticker and/or company name. (optional)
     * @param active Specify if the tickers returned should be actively traded on the queried date. Default is true. (optional)
     * @param tickerGte Range by ticker. (optional)
     * @param tickerGt Range by ticker. (optional)
     * @param tickerLte Range by ticker. (optional)
     * @param tickerLt Range by ticker. (optional)
     * @param order Order results based on the &#x60;sort&#x60; field. (optional)
     * @param limit Limit the number of results returned, default is 100 and max is 1000. (optional, default to 100)
     * @param sort Sort field used for ordering. (optional, default to ticker)
     * @return RequestConfig
     */
    fun listTickersRequestConfig(ticker: kotlin.String?, type: TypeListTickers?, market: MarketListTickers?, exchange: kotlin.String?, cusip: kotlin.String?, cik: kotlin.String?, date: java.time.LocalDate?, search: kotlin.String?, active: kotlin.Boolean?, tickerGte: kotlin.String?, tickerGt: kotlin.String?, tickerLte: kotlin.String?, tickerLt: kotlin.String?, order: OrderListTickers?, limit: kotlin.Int?, sort: SortListTickers?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (ticker != null) {
                    put("ticker", listOf(ticker.toString()))
                }
                if (type != null) {
                    put("type", listOf(type.value))
                }
                if (market != null) {
                    put("market", listOf(market.value))
                }
                if (exchange != null) {
                    put("exchange", listOf(exchange.toString()))
                }
                if (cusip != null) {
                    put("cusip", listOf(cusip.toString()))
                }
                if (cik != null) {
                    put("cik", listOf(cik.toString()))
                }
                if (date != null) {
                    put("date", listOf(parseDateToQueryString(date)))
                }
                if (search != null) {
                    put("search", listOf(search.toString()))
                }
                if (active != null) {
                    put("active", listOf(active.toString()))
                }
                if (tickerGte != null) {
                    put("ticker.gte", listOf(tickerGte.toString()))
                }
                if (tickerGt != null) {
                    put("ticker.gt", listOf(tickerGt.toString()))
                }
                if (tickerLte != null) {
                    put("ticker.lte", listOf(tickerLte.toString()))
                }
                if (tickerLt != null) {
                    put("ticker.lt", listOf(tickerLt.toString()))
                }
                if (order != null) {
                    put("order", listOf(order.value))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/v3/reference/tickers",
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter type
     */
     enum class TypeProductDetails(val value: kotlin.String) {
         @Json(name = "single") single("single"),
         @Json(name = "combo") combo("combo");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /futures/vX/products/{product_code}
     * Product Details
     * The Product Details endpoint returns the details for a single product as of a specific day.
     * @param productCode The unique identifier for a product.
     * @param type The type of product to return. One of \&quot;single\&quot; or \&quot;combo\&quot; (default&#x3D;single). (optional, default to single)
     * @param asOf A date string in the format YYYY-MM-DD. Note that the data returned is the state of this product&#39;s data at that point-in-time. (optional)
     * @return ProductDetails200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productDetails(productCode: kotlin.String, type: TypeProductDetails? = TypeProductDetails.single, asOf: java.time.LocalDate? = null) : ProductDetails200Response {
        val localVarResponse = productDetailsWithHttpInfo(productCode = productCode, type = type, asOf = asOf)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductDetails200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/products/{product_code}
     * Product Details
     * The Product Details endpoint returns the details for a single product as of a specific day.
     * @param productCode The unique identifier for a product.
     * @param type The type of product to return. One of \&quot;single\&quot; or \&quot;combo\&quot; (default&#x3D;single). (optional, default to single)
     * @param asOf A date string in the format YYYY-MM-DD. Note that the data returned is the state of this product&#39;s data at that point-in-time. (optional)
     * @return ApiResponse<ProductDetails200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productDetailsWithHttpInfo(productCode: kotlin.String, type: TypeProductDetails?, asOf: java.time.LocalDate?) : ApiResponse<ProductDetails200Response?> {
        val localVariableConfig = productDetailsRequestConfig(productCode = productCode, type = type, asOf = asOf)

        return request<Unit, ProductDetails200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productDetails
     *
     * @param productCode The unique identifier for a product.
     * @param type The type of product to return. One of \&quot;single\&quot; or \&quot;combo\&quot; (default&#x3D;single). (optional, default to single)
     * @param asOf A date string in the format YYYY-MM-DD. Note that the data returned is the state of this product&#39;s data at that point-in-time. (optional)
     * @return RequestConfig
     */
    fun productDetailsRequestConfig(productCode: kotlin.String, type: TypeProductDetails?, asOf: java.time.LocalDate?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (type != null) {
                    put("type", listOf(type.value))
                }
                if (asOf != null) {
                    put("as_of", listOf(parseDateToQueryString(asOf)))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/products/{product_code}".replace("{"+"product_code"+"}", encodeURIComponent(productCode.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }

    /**
     * enum for parameter sort
     */
     enum class SortProductSchedules(val value: kotlin.String) {
         @Json(name = "session_end_date.asc") sessionEndDatePeriodAsc("session_end_date.asc"),
         @Json(name = "session_end_date.desc") sessionEndDatePeriodDesc("session_end_date.desc");

        /**
         * Override [toString()] to avoid using the enum variable name as the value, and instead use
         * the actual value defined in the API spec file.
         *
         * This solves a problem when the variable name and its value are different, and ensures that
         * the client sends the correct enum values to the server always.
         */
        override fun toString(): kotlin.String = "$value"
     }

    /**
     * GET /futures/vX/products/{product_code}/schedules
     * Product Schedules
     * The Product-Specific Futures Schedules API provides detailed trading schedules for a specific futures product. This API allows you to query schedules for a single product across a range of dates. Users can access comprehensive information about trading sessions, including market events such as preopen, open, and closed, along with their precise timestamps.
     * @param productCode The product code for the futures product.
     * @param sessionEndDate The date on which the schedule&#39;s trading day ended (sometimes referred to as trading date). Defaults to today. Formatted as &#x60;YYYY-MM-DD&#x60;. Note that although there is no time component the day is assumed to be that day in Central Time. (optional)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sessionEndDateGte Range by session_end_date. (optional)
     * @param sessionEndDateGt Range by session_end_date. (optional)
     * @param sessionEndDateLte Range by session_end_date. (optional)
     * @param sessionEndDateLt Range by session_end_date. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to session_end_date.desc)
     * @return ProductSchedules200Response
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     * @throws UnsupportedOperationException If the API returns an informational or redirection response
     * @throws ClientException If the API returns a client error response
     * @throws ServerException If the API returns a server error response
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class, UnsupportedOperationException::class, ClientException::class, ServerException::class)
    fun productSchedules(productCode: kotlin.String, sessionEndDate: java.time.LocalDate? = null, limit: kotlin.Int? = 100, sessionEndDateGte: java.time.LocalDate? = null, sessionEndDateGt: java.time.LocalDate? = null, sessionEndDateLte: java.time.LocalDate? = null, sessionEndDateLt: java.time.LocalDate? = null, sort: SortProductSchedules? = SortProductSchedules.sessionEndDatePeriodDesc) : ProductSchedules200Response {
        val localVarResponse = productSchedulesWithHttpInfo(productCode = productCode, sessionEndDate = sessionEndDate, limit = limit, sessionEndDateGte = sessionEndDateGte, sessionEndDateGt = sessionEndDateGt, sessionEndDateLte = sessionEndDateLte, sessionEndDateLt = sessionEndDateLt, sort = sort)

        return when (localVarResponse.responseType) {
            ResponseType.Success -> (localVarResponse as Success<*>).data as ProductSchedules200Response
            ResponseType.Informational -> throw UnsupportedOperationException("Client does not support Informational responses.")
            ResponseType.Redirection -> throw UnsupportedOperationException("Client does not support Redirection responses.")
            ResponseType.ClientError -> {
                val localVarError = localVarResponse as ClientError<*>
                throw ClientException("Client error : ${localVarError.statusCode} ${localVarError.message.orEmpty()}", localVarError.statusCode, localVarResponse)
            }
            ResponseType.ServerError -> {
                val localVarError = localVarResponse as ServerError<*>
                throw ServerException("Server error : ${localVarError.statusCode} ${localVarError.message.orEmpty()} ${localVarError.body}", localVarError.statusCode, localVarResponse)
            }
        }
    }

    /**
     * GET /futures/vX/products/{product_code}/schedules
     * Product Schedules
     * The Product-Specific Futures Schedules API provides detailed trading schedules for a specific futures product. This API allows you to query schedules for a single product across a range of dates. Users can access comprehensive information about trading sessions, including market events such as preopen, open, and closed, along with their precise timestamps.
     * @param productCode The product code for the futures product.
     * @param sessionEndDate The date on which the schedule&#39;s trading day ended (sometimes referred to as trading date). Defaults to today. Formatted as &#x60;YYYY-MM-DD&#x60;. Note that although there is no time component the day is assumed to be that day in Central Time. (optional)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sessionEndDateGte Range by session_end_date. (optional)
     * @param sessionEndDateGt Range by session_end_date. (optional)
     * @param sessionEndDateLte Range by session_end_date. (optional)
     * @param sessionEndDateLt Range by session_end_date. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to session_end_date.desc)
     * @return ApiResponse<ProductSchedules200Response?>
     * @throws IllegalStateException If the request is not correctly configured
     * @throws IOException Rethrows the OkHttp execute method exception
     */
    @Suppress("UNCHECKED_CAST")
    @Throws(IllegalStateException::class, IOException::class)
    fun productSchedulesWithHttpInfo(productCode: kotlin.String, sessionEndDate: java.time.LocalDate?, limit: kotlin.Int?, sessionEndDateGte: java.time.LocalDate?, sessionEndDateGt: java.time.LocalDate?, sessionEndDateLte: java.time.LocalDate?, sessionEndDateLt: java.time.LocalDate?, sort: SortProductSchedules?) : ApiResponse<ProductSchedules200Response?> {
        val localVariableConfig = productSchedulesRequestConfig(productCode = productCode, sessionEndDate = sessionEndDate, limit = limit, sessionEndDateGte = sessionEndDateGte, sessionEndDateGt = sessionEndDateGt, sessionEndDateLte = sessionEndDateLte, sessionEndDateLt = sessionEndDateLt, sort = sort)

        return request<Unit, ProductSchedules200Response>(
            localVariableConfig
        )
    }

    /**
     * To obtain the request config of the operation productSchedules
     *
     * @param productCode The product code for the futures product.
     * @param sessionEndDate The date on which the schedule&#39;s trading day ended (sometimes referred to as trading date). Defaults to today. Formatted as &#x60;YYYY-MM-DD&#x60;. Note that although there is no time component the day is assumed to be that day in Central Time. (optional)
     * @param limit The number of results to return per page (default&#x3D;100, max&#x3D;1000, min&#x3D;1). (optional, default to 100)
     * @param sessionEndDateGte Range by session_end_date. (optional)
     * @param sessionEndDateGt Range by session_end_date. (optional)
     * @param sessionEndDateLte Range by session_end_date. (optional)
     * @param sessionEndDateLt Range by session_end_date. (optional)
     * @param sort Sort results by field and direction using dotted notation (e.g., &#39;ticker.asc&#39;, &#39;name.desc&#39;). (optional, default to session_end_date.desc)
     * @return RequestConfig
     */
    fun productSchedulesRequestConfig(productCode: kotlin.String, sessionEndDate: java.time.LocalDate?, limit: kotlin.Int?, sessionEndDateGte: java.time.LocalDate?, sessionEndDateGt: java.time.LocalDate?, sessionEndDateLte: java.time.LocalDate?, sessionEndDateLt: java.time.LocalDate?, sort: SortProductSchedules?) : RequestConfig<Unit> {
        val localVariableBody = null
        val localVariableQuery: MultiValueMap = mutableMapOf<kotlin.String, kotlin.collections.List<kotlin.String>>()
            .apply {
                if (sessionEndDate != null) {
                    put("session_end_date", listOf(parseDateToQueryString(sessionEndDate)))
                }
                if (limit != null) {
                    put("limit", listOf(limit.toString()))
                }
                if (sessionEndDateGte != null) {
                    put("session_end_date.gte", listOf(parseDateToQueryString(sessionEndDateGte)))
                }
                if (sessionEndDateGt != null) {
                    put("session_end_date.gt", listOf(parseDateToQueryString(sessionEndDateGt)))
                }
                if (sessionEndDateLte != null) {
                    put("session_end_date.lte", listOf(parseDateToQueryString(sessionEndDateLte)))
                }
                if (sessionEndDateLt != null) {
                    put("session_end_date.lt", listOf(parseDateToQueryString(sessionEndDateLt)))
                }
                if (sort != null) {
                    put("sort", listOf(sort.value))
                }
            }
        val localVariableHeaders: MutableMap<String, String> = mutableMapOf()
        localVariableHeaders["Accept"] = "application/json"

        return RequestConfig(
            method = RequestMethod.GET,
            path = "/futures/vX/products/{product_code}/schedules".replace("{"+"product_code"+"}", encodeURIComponent(productCode.toString())),
            query = localVariableQuery,
            headers = localVariableHeaders,
            requiresAuthentication = true,
            body = localVariableBody
        )
    }


    private fun encodeURIComponent(uriComponent: kotlin.String): kotlin.String =
        HttpUrl.Builder().scheme("http").host("localhost").addPathSegment(uriComponent).build().encodedPathSegments[0]
}
